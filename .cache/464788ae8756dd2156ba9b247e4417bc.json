{"dependencies":[{"name":"/Users/tommy/Downloads/TryIt/package.json","includedInParent":true,"mtime":1539397829000},{"name":"/Users/tommy/Downloads/TryIt/.babelrc","includedInParent":true,"mtime":1539397829000},{"name":"/Users/tommy/Downloads/TryIt/node_modules/@tensorflow/tfjs-converter/package.json","includedInParent":true,"mtime":1541754030000},{"name":"@tensorflow/tfjs-core","loc":{"line":17,"column":808}}],"generated":{"js":"var global = (1,eval)(\"this\");\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.version_converter = exports.loadFrozenModel = exports.FrozenModel = undefined;\n\nvar _tfjsCore = require(\"@tensorflow/tfjs-core\");\n\nvar __assign = Object.assign || function (e) {\n  for (var t, a = 1, r = arguments.length; a < r; a++) for (var n in t = arguments[a]) Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);return e;\n}; /**\n    * @license\n    * Copyright 2018 Google LLC. All Rights Reserved.\n    * Licensed under the Apache License, Version 2.0 (the \"License\");\n    * you may not use this file except in compliance with the License.\n    * You may obtain a copy of the License at\n    *\n    * http://www.apache.org/licenses/LICENSE-2.0\n    *\n    * Unless required by applicable law or agreed to in writing, software\n    * distributed under the License is distributed on an \"AS IS\" BASIS,\n    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    * See the License for the specific language governing permissions and\n    * limitations under the License.\n    * =============================================================================\n    */\nfunction __awaiter(e, t, a, r) {\n  return new (a || (a = Promise))(function (n, o) {\n    function s(e) {\n      try {\n        p(r.next(e));\n      } catch (e) {\n        o(e);\n      }\n    }function i(e) {\n      try {\n        p(r.throw(e));\n      } catch (e) {\n        o(e);\n      }\n    }function p(e) {\n      e.done ? n(e.value) : new a(function (t) {\n        t(e.value);\n      }).then(s, i);\n    }p((r = r.apply(e, t || [])).next());\n  });\n}function __generator(e, t) {\n  var a,\n      r,\n      n,\n      o,\n      s = { label: 0, sent: function () {\n      if (1 & n[0]) throw n[1];return n[1];\n    }, trys: [], ops: [] };return o = { next: i(0), throw: i(1), return: i(2) }, \"function\" == typeof Symbol && (o[Symbol.iterator] = function () {\n    return this;\n  }), o;function i(o) {\n    return function (i) {\n      return function (o) {\n        if (a) throw new TypeError(\"Generator is already executing.\");for (; s;) try {\n          if (a = 1, r && (n = r[2 & o[0] ? \"return\" : o[0] ? \"throw\" : \"next\"]) && !(n = n.call(r, o[1])).done) return n;switch (r = 0, n && (o = [0, n.value]), o[0]) {case 0:case 1:\n              n = o;break;case 4:\n              return s.label++, { value: o[1], done: !1 };case 5:\n              s.label++, r = o[1], o = [0];continue;case 7:\n              o = s.ops.pop(), s.trys.pop();continue;default:\n              if (!(n = (n = s.trys).length > 0 && n[n.length - 1]) && (6 === o[0] || 2 === o[0])) {\n                s = 0;continue;\n              }if (3 === o[0] && (!n || o[1] > n[0] && o[1] < n[3])) {\n                s.label = o[1];break;\n              }if (6 === o[0] && s.label < n[1]) {\n                s.label = n[1], n = o;break;\n              }if (n && s.label < n[2]) {\n                s.label = n[2], s.ops.push(o);break;\n              }n[2] && s.ops.pop(), s.trys.pop();continue;}o = t.call(e, s);\n        } catch (e) {\n          o = [6, e], r = 0;\n        } finally {\n          a = n = 0;\n        }if (5 & o[0]) throw o[1];return { value: o[0] ? o[1] : void 0, done: !0 };\n      }([o, i]);\n    };\n  }\n}var commonjsGlobal = \"undefined\" != typeof window ? window : \"undefined\" != typeof global ? global : \"undefined\" != typeof self ? self : {};function createCommonjsModule(e, t) {\n  return e(t = { exports: {} }, t.exports), t.exports;\n}var aspromise = asPromise;function asPromise(e, t) {\n  for (var a = new Array(arguments.length - 1), r = 0, n = 2, o = !0; n < arguments.length;) a[r++] = arguments[n++];return new Promise(function (n, s) {\n    a[r] = function (e) {\n      if (o) if (o = !1, e) s(e);else {\n        for (var t = new Array(arguments.length - 1), a = 0; a < t.length;) t[a++] = arguments[a];n.apply(null, t);\n      }\n    };try {\n      e.apply(t || null, a);\n    } catch (e) {\n      o && (o = !1, s(e));\n    }\n  });\n}var base64_1 = createCommonjsModule(function (e, t) {\n  var a = t;a.length = function (e) {\n    var t = e.length;if (!t) return 0;for (var a = 0; --t % 4 > 1 && \"=\" === e.charAt(t);) ++a;return Math.ceil(3 * e.length) / 4 - a;\n  };for (var r = new Array(64), n = new Array(123), o = 0; o < 64;) n[r[o] = o < 26 ? o + 65 : o < 52 ? o + 71 : o < 62 ? o - 4 : o - 59 | 43] = o++;a.encode = function (e, t, a) {\n    for (var n, o = null, s = [], i = 0, p = 0; t < a;) {\n      var u = e[t++];switch (p) {case 0:\n          s[i++] = r[u >> 2], n = (3 & u) << 4, p = 1;break;case 1:\n          s[i++] = r[n | u >> 4], n = (15 & u) << 2, p = 2;break;case 2:\n          s[i++] = r[n | u >> 6], s[i++] = r[63 & u], p = 0;}i > 8191 && ((o || (o = [])).push(String.fromCharCode.apply(String, s)), i = 0);\n    }return p && (s[i++] = r[n], s[i++] = 61, 1 === p && (s[i++] = 61)), o ? (i && o.push(String.fromCharCode.apply(String, s.slice(0, i))), o.join(\"\")) : String.fromCharCode.apply(String, s.slice(0, i));\n  };a.decode = function (e, t, a) {\n    for (var r, o = a, s = 0, i = 0; i < e.length;) {\n      var p = e.charCodeAt(i++);if (61 === p && s > 1) break;if (void 0 === (p = n[p])) throw Error(\"invalid encoding\");switch (s) {case 0:\n          r = p, s = 1;break;case 1:\n          t[a++] = r << 2 | (48 & p) >> 4, r = p, s = 2;break;case 2:\n          t[a++] = (15 & r) << 4 | (60 & p) >> 2, r = p, s = 3;break;case 3:\n          t[a++] = (3 & r) << 6 | p, s = 0;}\n    }if (1 === s) throw Error(\"invalid encoding\");return a - o;\n  }, a.test = function (e) {\n    return (/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(e)\n    );\n  };\n}),\n    eventemitter = EventEmitter;function EventEmitter() {\n  this._listeners = {};\n}EventEmitter.prototype.on = function (e, t, a) {\n  return (this._listeners[e] || (this._listeners[e] = [])).push({ fn: t, ctx: a || this }), this;\n}, EventEmitter.prototype.off = function (e, t) {\n  if (void 0 === e) this._listeners = {};else if (void 0 === t) this._listeners[e] = [];else for (var a = this._listeners[e], r = 0; r < a.length;) a[r].fn === t ? a.splice(r, 1) : ++r;return this;\n}, EventEmitter.prototype.emit = function (e) {\n  var t = this._listeners[e];if (t) {\n    for (var a = [], r = 1; r < arguments.length;) a.push(arguments[r++]);for (r = 0; r < t.length;) t[r].fn.apply(t[r++].ctx, a);\n  }return this;\n};var float_1 = factory(factory);function factory(e) {\n  return \"undefined\" != typeof Float32Array ? function () {\n    var t = new Float32Array([-0]),\n        a = new Uint8Array(t.buffer),\n        r = 128 === a[3];function n(e, r, n) {\n      t[0] = e, r[n] = a[0], r[n + 1] = a[1], r[n + 2] = a[2], r[n + 3] = a[3];\n    }function o(e, r, n) {\n      t[0] = e, r[n] = a[3], r[n + 1] = a[2], r[n + 2] = a[1], r[n + 3] = a[0];\n    }function s(e, r) {\n      return a[0] = e[r], a[1] = e[r + 1], a[2] = e[r + 2], a[3] = e[r + 3], t[0];\n    }function i(e, r) {\n      return a[3] = e[r], a[2] = e[r + 1], a[1] = e[r + 2], a[0] = e[r + 3], t[0];\n    }e.writeFloatLE = r ? n : o, e.writeFloatBE = r ? o : n, e.readFloatLE = r ? s : i, e.readFloatBE = r ? i : s;\n  }() : function () {\n    function t(e, t, a, r) {\n      var n = t < 0 ? 1 : 0;if (n && (t = -t), 0 === t) e(1 / t > 0 ? 0 : 2147483648, a, r);else if (isNaN(t)) e(2143289344, a, r);else if (t > 3.4028234663852886e38) e((n << 31 | 2139095040) >>> 0, a, r);else if (t < 1.1754943508222875e-38) e((n << 31 | Math.round(t / 1.401298464324817e-45)) >>> 0, a, r);else {\n        var o = Math.floor(Math.log(t) / Math.LN2);e((n << 31 | o + 127 << 23 | 8388607 & Math.round(t * Math.pow(2, -o) * 8388608)) >>> 0, a, r);\n      }\n    }function a(e, t, a) {\n      var r = e(t, a),\n          n = 2 * (r >> 31) + 1,\n          o = r >>> 23 & 255,\n          s = 8388607 & r;return 255 === o ? s ? NaN : n * (1 / 0) : 0 === o ? 1.401298464324817e-45 * n * s : n * Math.pow(2, o - 150) * (s + 8388608);\n    }e.writeFloatLE = t.bind(null, writeUintLE), e.writeFloatBE = t.bind(null, writeUintBE), e.readFloatLE = a.bind(null, readUintLE), e.readFloatBE = a.bind(null, readUintBE);\n  }(), \"undefined\" != typeof Float64Array ? function () {\n    var t = new Float64Array([-0]),\n        a = new Uint8Array(t.buffer),\n        r = 128 === a[7];function n(e, r, n) {\n      t[0] = e, r[n] = a[0], r[n + 1] = a[1], r[n + 2] = a[2], r[n + 3] = a[3], r[n + 4] = a[4], r[n + 5] = a[5], r[n + 6] = a[6], r[n + 7] = a[7];\n    }function o(e, r, n) {\n      t[0] = e, r[n] = a[7], r[n + 1] = a[6], r[n + 2] = a[5], r[n + 3] = a[4], r[n + 4] = a[3], r[n + 5] = a[2], r[n + 6] = a[1], r[n + 7] = a[0];\n    }function s(e, r) {\n      return a[0] = e[r], a[1] = e[r + 1], a[2] = e[r + 2], a[3] = e[r + 3], a[4] = e[r + 4], a[5] = e[r + 5], a[6] = e[r + 6], a[7] = e[r + 7], t[0];\n    }function i(e, r) {\n      return a[7] = e[r], a[6] = e[r + 1], a[5] = e[r + 2], a[4] = e[r + 3], a[3] = e[r + 4], a[2] = e[r + 5], a[1] = e[r + 6], a[0] = e[r + 7], t[0];\n    }e.writeDoubleLE = r ? n : o, e.writeDoubleBE = r ? o : n, e.readDoubleLE = r ? s : i, e.readDoubleBE = r ? i : s;\n  }() : function () {\n    function t(e, t, a, r, n, o) {\n      var s = r < 0 ? 1 : 0;if (s && (r = -r), 0 === r) e(0, n, o + t), e(1 / r > 0 ? 0 : 2147483648, n, o + a);else if (isNaN(r)) e(0, n, o + t), e(2146959360, n, o + a);else if (r > 1.7976931348623157e308) e(0, n, o + t), e((s << 31 | 2146435072) >>> 0, n, o + a);else {\n        var i;if (r < 2.2250738585072014e-308) e((i = r / 5e-324) >>> 0, n, o + t), e((s << 31 | i / 4294967296) >>> 0, n, o + a);else {\n          var p = Math.floor(Math.log(r) / Math.LN2);1024 === p && (p = 1023), e(4503599627370496 * (i = r * Math.pow(2, -p)) >>> 0, n, o + t), e((s << 31 | p + 1023 << 20 | 1048576 * i & 1048575) >>> 0, n, o + a);\n        }\n      }\n    }function a(e, t, a, r, n) {\n      var o = e(r, n + t),\n          s = e(r, n + a),\n          i = 2 * (s >> 31) + 1,\n          p = s >>> 20 & 2047,\n          u = 4294967296 * (1048575 & s) + o;return 2047 === p ? u ? NaN : i * (1 / 0) : 0 === p ? 5e-324 * i * u : i * Math.pow(2, p - 1075) * (u + 4503599627370496);\n    }e.writeDoubleLE = t.bind(null, writeUintLE, 0, 4), e.writeDoubleBE = t.bind(null, writeUintBE, 4, 0), e.readDoubleLE = a.bind(null, readUintLE, 0, 4), e.readDoubleBE = a.bind(null, readUintBE, 4, 0);\n  }(), e;\n}function writeUintLE(e, t, a) {\n  t[a] = 255 & e, t[a + 1] = e >>> 8 & 255, t[a + 2] = e >>> 16 & 255, t[a + 3] = e >>> 24;\n}function writeUintBE(e, t, a) {\n  t[a] = e >>> 24, t[a + 1] = e >>> 16 & 255, t[a + 2] = e >>> 8 & 255, t[a + 3] = 255 & e;\n}function readUintLE(e, t) {\n  return (e[t] | e[t + 1] << 8 | e[t + 2] << 16 | e[t + 3] << 24) >>> 0;\n}function readUintBE(e, t) {\n  return (e[t] << 24 | e[t + 1] << 16 | e[t + 2] << 8 | e[t + 3]) >>> 0;\n}var inquire_1 = inquire;function inquire(moduleName) {\n  try {\n    var mod$$1 = eval(\"quire\".replace(/^/, \"re\"))(moduleName);if (mod$$1 && (mod$$1.length || Object.keys(mod$$1).length)) return mod$$1;\n  } catch (e) {}return null;\n}var utf8_1 = createCommonjsModule(function (e, t) {\n  var a = t;a.length = function (e) {\n    for (var t = 0, a = 0, r = 0; r < e.length; ++r) (a = e.charCodeAt(r)) < 128 ? t += 1 : a < 2048 ? t += 2 : 55296 == (64512 & a) && 56320 == (64512 & e.charCodeAt(r + 1)) ? (++r, t += 4) : t += 3;return t;\n  }, a.read = function (e, t, a) {\n    if (a - t < 1) return \"\";for (var r, n = null, o = [], s = 0; t < a;) (r = e[t++]) < 128 ? o[s++] = r : r > 191 && r < 224 ? o[s++] = (31 & r) << 6 | 63 & e[t++] : r > 239 && r < 365 ? (r = ((7 & r) << 18 | (63 & e[t++]) << 12 | (63 & e[t++]) << 6 | 63 & e[t++]) - 65536, o[s++] = 55296 + (r >> 10), o[s++] = 56320 + (1023 & r)) : o[s++] = (15 & r) << 12 | (63 & e[t++]) << 6 | 63 & e[t++], s > 8191 && ((n || (n = [])).push(String.fromCharCode.apply(String, o)), s = 0);return n ? (s && n.push(String.fromCharCode.apply(String, o.slice(0, s))), n.join(\"\")) : String.fromCharCode.apply(String, o.slice(0, s));\n  }, a.write = function (e, t, a) {\n    for (var r, n, o = a, s = 0; s < e.length; ++s) (r = e.charCodeAt(s)) < 128 ? t[a++] = r : r < 2048 ? (t[a++] = r >> 6 | 192, t[a++] = 63 & r | 128) : 55296 == (64512 & r) && 56320 == (64512 & (n = e.charCodeAt(s + 1))) ? (r = 65536 + ((1023 & r) << 10) + (1023 & n), ++s, t[a++] = r >> 18 | 240, t[a++] = r >> 12 & 63 | 128, t[a++] = r >> 6 & 63 | 128, t[a++] = 63 & r | 128) : (t[a++] = r >> 12 | 224, t[a++] = r >> 6 & 63 | 128, t[a++] = 63 & r | 128);return a - o;\n  };\n}),\n    pool_1 = pool;function pool(e, t, a) {\n  var r = a || 8192,\n      n = r >>> 1,\n      o = null,\n      s = r;return function (a) {\n    if (a < 1 || a > n) return e(a);s + a > r && (o = e(r), s = 0);var i = t.call(o, s, s += a);return 7 & s && (s = 1 + (7 | s)), i;\n  };\n}var longbits = LongBits;function LongBits(e, t) {\n  this.lo = e >>> 0, this.hi = t >>> 0;\n}var zero = LongBits.zero = new LongBits(0, 0);zero.toNumber = function () {\n  return 0;\n}, zero.zzEncode = zero.zzDecode = function () {\n  return this;\n}, zero.length = function () {\n  return 1;\n};var zeroHash = LongBits.zeroHash = \"\\0\\0\\0\\0\\0\\0\\0\\0\";LongBits.fromNumber = function (e) {\n  if (0 === e) return zero;var t = e < 0;t && (e = -e);var a = e >>> 0,\n      r = (e - a) / 4294967296 >>> 0;return t && (r = ~r >>> 0, a = ~a >>> 0, ++a > 4294967295 && (a = 0, ++r > 4294967295 && (r = 0))), new LongBits(a, r);\n}, LongBits.from = function (e) {\n  if (\"number\" == typeof e) return LongBits.fromNumber(e);if (minimal.isString(e)) {\n    if (!minimal.Long) return LongBits.fromNumber(parseInt(e, 10));e = minimal.Long.fromString(e);\n  }return e.low || e.high ? new LongBits(e.low >>> 0, e.high >>> 0) : zero;\n}, LongBits.prototype.toNumber = function (e) {\n  if (!e && this.hi >>> 31) {\n    var t = 1 + ~this.lo >>> 0,\n        a = ~this.hi >>> 0;return t || (a = a + 1 >>> 0), -(t + 4294967296 * a);\n  }return this.lo + 4294967296 * this.hi;\n}, LongBits.prototype.toLong = function (e) {\n  return minimal.Long ? new minimal.Long(0 | this.lo, 0 | this.hi, Boolean(e)) : { low: 0 | this.lo, high: 0 | this.hi, unsigned: Boolean(e) };\n};var charCodeAt = String.prototype.charCodeAt;LongBits.fromHash = function (e) {\n  return e === zeroHash ? zero : new LongBits((charCodeAt.call(e, 0) | charCodeAt.call(e, 1) << 8 | charCodeAt.call(e, 2) << 16 | charCodeAt.call(e, 3) << 24) >>> 0, (charCodeAt.call(e, 4) | charCodeAt.call(e, 5) << 8 | charCodeAt.call(e, 6) << 16 | charCodeAt.call(e, 7) << 24) >>> 0);\n}, LongBits.prototype.toHash = function () {\n  return String.fromCharCode(255 & this.lo, this.lo >>> 8 & 255, this.lo >>> 16 & 255, this.lo >>> 24, 255 & this.hi, this.hi >>> 8 & 255, this.hi >>> 16 & 255, this.hi >>> 24);\n}, LongBits.prototype.zzEncode = function () {\n  var e = this.hi >> 31;return this.hi = ((this.hi << 1 | this.lo >>> 31) ^ e) >>> 0, this.lo = (this.lo << 1 ^ e) >>> 0, this;\n}, LongBits.prototype.zzDecode = function () {\n  var e = -(1 & this.lo);return this.lo = ((this.lo >>> 1 | this.hi << 31) ^ e) >>> 0, this.hi = (this.hi >>> 1 ^ e) >>> 0, this;\n}, LongBits.prototype.length = function () {\n  var e = this.lo,\n      t = (this.lo >>> 28 | this.hi << 4) >>> 0,\n      a = this.hi >>> 24;return 0 === a ? 0 === t ? e < 16384 ? e < 128 ? 1 : 2 : e < 2097152 ? 3 : 4 : t < 16384 ? t < 128 ? 5 : 6 : t < 2097152 ? 7 : 8 : a < 128 ? 9 : 10;\n};var minimal = createCommonjsModule(function (e, t) {\n  var a = t;function r(e, t, a) {\n    for (var r = Object.keys(t), n = 0; n < r.length; ++n) void 0 !== e[r[n]] && a || (e[r[n]] = t[r[n]]);return e;\n  }function n(e) {\n    function t(e, a) {\n      if (!(this instanceof t)) return new t(e, a);Object.defineProperty(this, \"message\", { get: function () {\n          return e;\n        } }), Error.captureStackTrace ? Error.captureStackTrace(this, t) : Object.defineProperty(this, \"stack\", { value: new Error().stack || \"\" }), a && r(this, a);\n    }return (t.prototype = Object.create(Error.prototype)).constructor = t, Object.defineProperty(t.prototype, \"name\", { get: function () {\n        return e;\n      } }), t.prototype.toString = function () {\n      return this.name + \": \" + this.message;\n    }, t;\n  }a.asPromise = aspromise, a.base64 = base64_1, a.EventEmitter = eventemitter, a.float = float_1, a.inquire = inquire_1, a.utf8 = utf8_1, a.pool = pool_1, a.LongBits = longbits, a.emptyArray = Object.freeze ? Object.freeze([]) : [], a.emptyObject = Object.freeze ? Object.freeze({}) : {}, a.isNode = Boolean(commonjsGlobal.process && commonjsGlobal.process.versions && commonjsGlobal.process.versions.node), a.isInteger = Number.isInteger || function (e) {\n    return \"number\" == typeof e && isFinite(e) && Math.floor(e) === e;\n  }, a.isString = function (e) {\n    return \"string\" == typeof e || e instanceof String;\n  }, a.isObject = function (e) {\n    return e && \"object\" == typeof e;\n  }, a.isset = a.isSet = function (e, t) {\n    var a = e[t];return !(null == a || !e.hasOwnProperty(t)) && (\"object\" != typeof a || (Array.isArray(a) ? a.length : Object.keys(a).length) > 0);\n  }, a.Buffer = function () {\n    try {\n      var e = a.inquire(\"buffer\").Buffer;return e.prototype.utf8Write ? e : null;\n    } catch (e) {\n      return null;\n    }\n  }(), a._Buffer_from = null, a._Buffer_allocUnsafe = null, a.newBuffer = function (e) {\n    return \"number\" == typeof e ? a.Buffer ? a._Buffer_allocUnsafe(e) : new a.Array(e) : a.Buffer ? a._Buffer_from(e) : \"undefined\" == typeof Uint8Array ? e : new Uint8Array(e);\n  }, a.Array = \"undefined\" != typeof Uint8Array ? Uint8Array : Array, a.Long = commonjsGlobal.dcodeIO && commonjsGlobal.dcodeIO.Long || a.inquire(\"long\"), a.key2Re = /^true|false|0|1$/, a.key32Re = /^-?(?:0|[1-9][0-9]*)$/, a.key64Re = /^(?:[\\\\x00-\\\\xff]{8}|-?(?:0|[1-9][0-9]*))$/, a.longToHash = function (e) {\n    return e ? a.LongBits.from(e).toHash() : a.LongBits.zeroHash;\n  }, a.longFromHash = function (e, t) {\n    var r = a.LongBits.fromHash(e);return a.Long ? a.Long.fromBits(r.lo, r.hi, t) : r.toNumber(Boolean(t));\n  }, a.merge = r, a.lcFirst = function (e) {\n    return e.charAt(0).toLowerCase() + e.substring(1);\n  }, a.newError = n, a.ProtocolError = n(\"ProtocolError\"), a.oneOfGetter = function (e) {\n    for (var t = {}, a = 0; a < e.length; ++a) t[e[a]] = 1;return function () {\n      for (var e = Object.keys(this), a = e.length - 1; a > -1; --a) if (1 === t[e[a]] && void 0 !== this[e[a]] && null !== this[e[a]]) return e[a];\n    };\n  }, a.oneOfSetter = function (e) {\n    return function (t) {\n      for (var a = 0; a < e.length; ++a) e[a] !== t && delete this[e[a]];\n    };\n  }, a.toJSONOptions = { longs: String, enums: String, bytes: String, json: !0 }, a._configure = function () {\n    var e = a.Buffer;e ? (a._Buffer_from = e.from !== Uint8Array.from && e.from || function (t, a) {\n      return new e(t, a);\n    }, a._Buffer_allocUnsafe = e.allocUnsafe || function (t) {\n      return new e(t);\n    }) : a._Buffer_from = a._Buffer_allocUnsafe = null;\n  };\n}),\n    writer = Writer,\n    BufferWriter,\n    LongBits$1 = minimal.LongBits,\n    base64 = minimal.base64,\n    utf8 = minimal.utf8;function Op(e, t, a) {\n  this.fn = e, this.len = t, this.next = void 0, this.val = a;\n}function noop() {}function State(e) {\n  this.head = e.head, this.tail = e.tail, this.len = e.len, this.next = e.states;\n}function Writer() {\n  this.len = 0, this.head = new Op(noop, 0, 0), this.tail = this.head, this.states = null;\n}function writeByte(e, t, a) {\n  t[a] = 255 & e;\n}function writeVarint32(e, t, a) {\n  for (; e > 127;) t[a++] = 127 & e | 128, e >>>= 7;t[a] = e;\n}function VarintOp(e, t) {\n  this.len = e, this.next = void 0, this.val = t;\n}function writeVarint64(e, t, a) {\n  for (; e.hi;) t[a++] = 127 & e.lo | 128, e.lo = (e.lo >>> 7 | e.hi << 25) >>> 0, e.hi >>>= 7;for (; e.lo > 127;) t[a++] = 127 & e.lo | 128, e.lo = e.lo >>> 7;t[a++] = e.lo;\n}function writeFixed32(e, t, a) {\n  t[a] = 255 & e, t[a + 1] = e >>> 8 & 255, t[a + 2] = e >>> 16 & 255, t[a + 3] = e >>> 24;\n}Writer.create = minimal.Buffer ? function () {\n  return (Writer.create = function () {\n    return new BufferWriter();\n  })();\n} : function () {\n  return new Writer();\n}, Writer.alloc = function (e) {\n  return new minimal.Array(e);\n}, minimal.Array !== Array && (Writer.alloc = minimal.pool(Writer.alloc, minimal.Array.prototype.subarray)), Writer.prototype._push = function (e, t, a) {\n  return this.tail = this.tail.next = new Op(e, t, a), this.len += t, this;\n}, VarintOp.prototype = Object.create(Op.prototype), VarintOp.prototype.fn = writeVarint32, Writer.prototype.uint32 = function (e) {\n  return this.len += (this.tail = this.tail.next = new VarintOp((e >>>= 0) < 128 ? 1 : e < 16384 ? 2 : e < 2097152 ? 3 : e < 268435456 ? 4 : 5, e)).len, this;\n}, Writer.prototype.int32 = function (e) {\n  return e < 0 ? this._push(writeVarint64, 10, LongBits$1.fromNumber(e)) : this.uint32(e);\n}, Writer.prototype.sint32 = function (e) {\n  return this.uint32((e << 1 ^ e >> 31) >>> 0);\n}, Writer.prototype.uint64 = function (e) {\n  var t = LongBits$1.from(e);return this._push(writeVarint64, t.length(), t);\n}, Writer.prototype.int64 = Writer.prototype.uint64, Writer.prototype.sint64 = function (e) {\n  var t = LongBits$1.from(e).zzEncode();return this._push(writeVarint64, t.length(), t);\n}, Writer.prototype.bool = function (e) {\n  return this._push(writeByte, 1, e ? 1 : 0);\n}, Writer.prototype.fixed32 = function (e) {\n  return this._push(writeFixed32, 4, e >>> 0);\n}, Writer.prototype.sfixed32 = Writer.prototype.fixed32, Writer.prototype.fixed64 = function (e) {\n  var t = LongBits$1.from(e);return this._push(writeFixed32, 4, t.lo)._push(writeFixed32, 4, t.hi);\n}, Writer.prototype.sfixed64 = Writer.prototype.fixed64, Writer.prototype.float = function (e) {\n  return this._push(minimal.float.writeFloatLE, 4, e);\n}, Writer.prototype.double = function (e) {\n  return this._push(minimal.float.writeDoubleLE, 8, e);\n};var writeBytes = minimal.Array.prototype.set ? function (e, t, a) {\n  t.set(e, a);\n} : function (e, t, a) {\n  for (var r = 0; r < e.length; ++r) t[a + r] = e[r];\n};Writer.prototype.bytes = function (e) {\n  var t = e.length >>> 0;if (!t) return this._push(writeByte, 1, 0);if (minimal.isString(e)) {\n    var a = Writer.alloc(t = base64.length(e));base64.decode(e, a, 0), e = a;\n  }return this.uint32(t)._push(writeBytes, t, e);\n}, Writer.prototype.string = function (e) {\n  var t = utf8.length(e);return t ? this.uint32(t)._push(utf8.write, t, e) : this._push(writeByte, 1, 0);\n}, Writer.prototype.fork = function () {\n  return this.states = new State(this), this.head = this.tail = new Op(noop, 0, 0), this.len = 0, this;\n}, Writer.prototype.reset = function () {\n  return this.states ? (this.head = this.states.head, this.tail = this.states.tail, this.len = this.states.len, this.states = this.states.next) : (this.head = this.tail = new Op(noop, 0, 0), this.len = 0), this;\n}, Writer.prototype.ldelim = function () {\n  var e = this.head,\n      t = this.tail,\n      a = this.len;return this.reset().uint32(a), a && (this.tail.next = e.next, this.tail = t, this.len += a), this;\n}, Writer.prototype.finish = function () {\n  for (var e = this.head.next, t = this.constructor.alloc(this.len), a = 0; e;) e.fn(e.val, t, a), a += e.len, e = e.next;return t;\n}, Writer._configure = function (e) {\n  BufferWriter = e;\n};var writer_buffer = BufferWriter$1;(BufferWriter$1.prototype = Object.create(writer.prototype)).constructor = BufferWriter$1;var Buffer = minimal.Buffer;function BufferWriter$1() {\n  writer.call(this);\n}BufferWriter$1.alloc = function (e) {\n  return (BufferWriter$1.alloc = minimal._Buffer_allocUnsafe)(e);\n};var writeBytesBuffer = Buffer && Buffer.prototype instanceof Uint8Array && \"set\" === Buffer.prototype.set.name ? function (e, t, a) {\n  t.set(e, a);\n} : function (e, t, a) {\n  if (e.copy) e.copy(t, a, 0, e.length);else for (var r = 0; r < e.length;) t[a++] = e[r++];\n};function writeStringBuffer(e, t, a) {\n  e.length < 40 ? minimal.utf8.write(e, t, a) : t.utf8Write(e, a);\n}BufferWriter$1.prototype.bytes = function (e) {\n  minimal.isString(e) && (e = minimal._Buffer_from(e, \"base64\"));var t = e.length >>> 0;return this.uint32(t), t && this._push(writeBytesBuffer, t, e), this;\n}, BufferWriter$1.prototype.string = function (e) {\n  var t = Buffer.byteLength(e);return this.uint32(t), t && this._push(writeStringBuffer, t, e), this;\n};var reader = Reader,\n    BufferReader,\n    LongBits$2 = minimal.LongBits,\n    utf8$1 = minimal.utf8;function indexOutOfRange(e, t) {\n  return RangeError(\"index out of range: \" + e.pos + \" + \" + (t || 1) + \" > \" + e.len);\n}function Reader(e) {\n  this.buf = e, this.pos = 0, this.len = e.length;\n}var create_array = \"undefined\" != typeof Uint8Array ? function (e) {\n  if (e instanceof Uint8Array || Array.isArray(e)) return new Reader(e);throw Error(\"illegal buffer\");\n} : function (e) {\n  if (Array.isArray(e)) return new Reader(e);throw Error(\"illegal buffer\");\n};function readLongVarint() {\n  var e = new LongBits$2(0, 0),\n      t = 0;if (!(this.len - this.pos > 4)) {\n    for (; t < 3; ++t) {\n      if (this.pos >= this.len) throw indexOutOfRange(this);if (e.lo = (e.lo | (127 & this.buf[this.pos]) << 7 * t) >>> 0, this.buf[this.pos++] < 128) return e;\n    }return e.lo = (e.lo | (127 & this.buf[this.pos++]) << 7 * t) >>> 0, e;\n  }for (; t < 4; ++t) if (e.lo = (e.lo | (127 & this.buf[this.pos]) << 7 * t) >>> 0, this.buf[this.pos++] < 128) return e;if (e.lo = (e.lo | (127 & this.buf[this.pos]) << 28) >>> 0, e.hi = (e.hi | (127 & this.buf[this.pos]) >> 4) >>> 0, this.buf[this.pos++] < 128) return e;if (t = 0, this.len - this.pos > 4) {\n    for (; t < 5; ++t) if (e.hi = (e.hi | (127 & this.buf[this.pos]) << 7 * t + 3) >>> 0, this.buf[this.pos++] < 128) return e;\n  } else for (; t < 5; ++t) {\n    if (this.pos >= this.len) throw indexOutOfRange(this);if (e.hi = (e.hi | (127 & this.buf[this.pos]) << 7 * t + 3) >>> 0, this.buf[this.pos++] < 128) return e;\n  }throw Error(\"invalid varint encoding\");\n}function readFixed32_end(e, t) {\n  return (e[t - 4] | e[t - 3] << 8 | e[t - 2] << 16 | e[t - 1] << 24) >>> 0;\n}function readFixed64() {\n  if (this.pos + 8 > this.len) throw indexOutOfRange(this, 8);return new LongBits$2(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));\n}Reader.create = minimal.Buffer ? function (e) {\n  return (Reader.create = function (e) {\n    return minimal.Buffer.isBuffer(e) ? new BufferReader(e) : create_array(e);\n  })(e);\n} : create_array, Reader.prototype._slice = minimal.Array.prototype.subarray || minimal.Array.prototype.slice, Reader.prototype.uint32 = function () {\n  var e = 4294967295;return function () {\n    if (e = (127 & this.buf[this.pos]) >>> 0, this.buf[this.pos++] < 128) return e;if (e = (e | (127 & this.buf[this.pos]) << 7) >>> 0, this.buf[this.pos++] < 128) return e;if (e = (e | (127 & this.buf[this.pos]) << 14) >>> 0, this.buf[this.pos++] < 128) return e;if (e = (e | (127 & this.buf[this.pos]) << 21) >>> 0, this.buf[this.pos++] < 128) return e;if (e = (e | (15 & this.buf[this.pos]) << 28) >>> 0, this.buf[this.pos++] < 128) return e;if ((this.pos += 5) > this.len) throw this.pos = this.len, indexOutOfRange(this, 10);return e;\n  };\n}(), Reader.prototype.int32 = function () {\n  return 0 | this.uint32();\n}, Reader.prototype.sint32 = function () {\n  var e = this.uint32();return e >>> 1 ^ -(1 & e) | 0;\n}, Reader.prototype.bool = function () {\n  return 0 !== this.uint32();\n}, Reader.prototype.fixed32 = function () {\n  if (this.pos + 4 > this.len) throw indexOutOfRange(this, 4);return readFixed32_end(this.buf, this.pos += 4);\n}, Reader.prototype.sfixed32 = function () {\n  if (this.pos + 4 > this.len) throw indexOutOfRange(this, 4);return 0 | readFixed32_end(this.buf, this.pos += 4);\n}, Reader.prototype.float = function () {\n  if (this.pos + 4 > this.len) throw indexOutOfRange(this, 4);var e = minimal.float.readFloatLE(this.buf, this.pos);return this.pos += 4, e;\n}, Reader.prototype.double = function () {\n  if (this.pos + 8 > this.len) throw indexOutOfRange(this, 4);var e = minimal.float.readDoubleLE(this.buf, this.pos);return this.pos += 8, e;\n}, Reader.prototype.bytes = function () {\n  var e = this.uint32(),\n      t = this.pos,\n      a = this.pos + e;if (a > this.len) throw indexOutOfRange(this, e);return this.pos += e, Array.isArray(this.buf) ? this.buf.slice(t, a) : t === a ? new this.buf.constructor(0) : this._slice.call(this.buf, t, a);\n}, Reader.prototype.string = function () {\n  var e = this.bytes();return utf8$1.read(e, 0, e.length);\n}, Reader.prototype.skip = function (e) {\n  if (\"number\" == typeof e) {\n    if (this.pos + e > this.len) throw indexOutOfRange(this, e);this.pos += e;\n  } else do {\n    if (this.pos >= this.len) throw indexOutOfRange(this);\n  } while (128 & this.buf[this.pos++]);return this;\n}, Reader.prototype.skipType = function (e) {\n  switch (e) {case 0:\n      this.skip();break;case 1:\n      this.skip(8);break;case 2:\n      this.skip(this.uint32());break;case 3:\n      for (;;) {\n        if (4 == (e = 7 & this.uint32())) break;this.skipType(e);\n      }break;case 5:\n      this.skip(4);break;default:\n      throw Error(\"invalid wire type \" + e + \" at offset \" + this.pos);}return this;\n}, Reader._configure = function (e) {\n  BufferReader = e;var t = minimal.Long ? \"toLong\" : \"toNumber\";minimal.merge(Reader.prototype, { int64: function () {\n      return readLongVarint.call(this)[t](!1);\n    }, uint64: function () {\n      return readLongVarint.call(this)[t](!0);\n    }, sint64: function () {\n      return readLongVarint.call(this).zzDecode()[t](!1);\n    }, fixed64: function () {\n      return readFixed64.call(this)[t](!0);\n    }, sfixed64: function () {\n      return readFixed64.call(this)[t](!1);\n    } });\n};var reader_buffer = BufferReader$1;function BufferReader$1(e) {\n  reader.call(this, e);\n}(BufferReader$1.prototype = Object.create(reader.prototype)).constructor = BufferReader$1, minimal.Buffer && (BufferReader$1.prototype._slice = minimal.Buffer.prototype.slice), BufferReader$1.prototype.string = function () {\n  var e = this.uint32();return this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + e, this.len));\n};var service = Service;function Service(e, t, a) {\n  if (\"function\" != typeof e) throw TypeError(\"rpcImpl must be a function\");minimal.EventEmitter.call(this), this.rpcImpl = e, this.requestDelimited = Boolean(t), this.responseDelimited = Boolean(a);\n}(Service.prototype = Object.create(minimal.EventEmitter.prototype)).constructor = Service, Service.prototype.rpcCall = function e(t, a, r, n, o) {\n  if (!n) throw TypeError(\"request must be specified\");var s = this;if (!o) return minimal.asPromise(e, s, t, a, r, n);if (s.rpcImpl) try {\n    return s.rpcImpl(t, a[s.requestDelimited ? \"encodeDelimited\" : \"encode\"](n).finish(), function (e, a) {\n      if (e) return s.emit(\"error\", e, t), o(e);if (null !== a) {\n        if (!(a instanceof r)) try {\n          a = r[s.responseDelimited ? \"decodeDelimited\" : \"decode\"](a);\n        } catch (e) {\n          return s.emit(\"error\", e, t), o(e);\n        }return s.emit(\"data\", a, t), o(null, a);\n      }s.end(!0);\n    });\n  } catch (e) {\n    return s.emit(\"error\", e, t), void setTimeout(function () {\n      o(e);\n    }, 0);\n  } else setTimeout(function () {\n    o(Error(\"already ended\"));\n  }, 0);\n}, Service.prototype.end = function (e) {\n  return this.rpcImpl && (e || this.rpcImpl(null, null, null), this.rpcImpl = null, this.emit(\"end\").off()), this;\n};var rpc_1 = createCommonjsModule(function (e, t) {\n  t.Service = service;\n}),\n    roots = {},\n    indexMinimal = createCommonjsModule(function (e, t) {\n  var a = t;function r() {\n    a.Reader._configure(a.BufferReader), a.util._configure();\n  }a.build = \"minimal\", a.Writer = writer, a.BufferWriter = writer_buffer, a.Reader = reader, a.BufferReader = reader_buffer, a.util = minimal, a.rpc = rpc_1, a.roots = roots, a.configure = r, a.Writer._configure(a.BufferWriter), r();\n}),\n    minimal$1 = indexMinimal,\n    minimal_1 = minimal$1.roots,\n    minimal_2 = minimal$1.Reader,\n    minimal_3 = minimal$1.util,\n    $Reader = minimal$1.Reader,\n    $util = minimal$1.util,\n    $root = minimal$1.roots.default || (minimal$1.roots.default = {});$root.tensorflow = function () {\n  var e,\n      t,\n      a = {};return a.Any = function () {\n    function e(e) {\n      if (e) for (var t = Object.keys(e), a = 0; a < t.length; ++a) null != e[t[a]] && (this[t[a]] = e[t[a]]);\n    }return e.prototype.typeUrl = \"\", e.prototype.value = $util.newBuffer([]), e.decode = function (e, t) {\n      e instanceof $Reader || (e = $Reader.create(e));for (var a = void 0 === t ? e.len : e.pos + t, r = new $root.tensorflow.Any(); e.pos < a;) {\n        var n = e.uint32();switch (n >>> 3) {case 1:\n            r.typeUrl = e.string();break;case 2:\n            r.value = e.bytes();break;default:\n            e.skipType(7 & n);}\n      }return r;\n    }, e;\n  }(), a.DataType = (e = {}, (t = Object.create(e))[e[0] = \"DT_INVALID\"] = 0, t[e[1] = \"DT_FLOAT\"] = 1, t[e[2] = \"DT_DOUBLE\"] = 2, t[e[3] = \"DT_INT32\"] = 3, t[e[4] = \"DT_UINT8\"] = 4, t[e[5] = \"DT_INT16\"] = 5, t[e[6] = \"DT_INT8\"] = 6, t[e[7] = \"DT_STRING\"] = 7, t[e[8] = \"DT_COMPLEX64\"] = 8, t[e[9] = \"DT_INT64\"] = 9, t[e[10] = \"DT_BOOL\"] = 10, t[e[11] = \"DT_QINT8\"] = 11, t[e[12] = \"DT_QUINT8\"] = 12, t[e[13] = \"DT_QINT32\"] = 13, t[e[14] = \"DT_BFLOAT16\"] = 14, t[e[101] = \"DT_FLOAT_REF\"] = 101, t[e[102] = \"DT_DOUBLE_REF\"] = 102, t[e[103] = \"DT_INT32_REF\"] = 103, t[e[104] = \"DT_UINT8_REF\"] = 104, t[e[105] = \"DT_INT16_REF\"] = 105, t[e[106] = \"DT_INT8_REF\"] = 106, t[e[107] = \"DT_STRING_REF\"] = 107, t[e[108] = \"DT_COMPLEX64_REF\"] = 108, t[e[109] = \"DT_INT64_REF\"] = 109, t[e[110] = \"DT_BOOL_REF\"] = 110, t[e[111] = \"DT_QINT8_REF\"] = 111, t[e[112] = \"DT_QUINT8_REF\"] = 112, t[e[113] = \"DT_QINT32_REF\"] = 113, t[e[114] = \"DT_BFLOAT16_REF\"] = 114, t), a.TensorShape = function () {\n    function e(e) {\n      if (this.dim = [], e) for (var t = Object.keys(e), a = 0; a < t.length; ++a) null != e[t[a]] && (this[t[a]] = e[t[a]]);\n    }return e.prototype.dim = $util.emptyArray, e.prototype.unknownRank = !1, e.decode = function (e, t) {\n      e instanceof $Reader || (e = $Reader.create(e));for (var a = void 0 === t ? e.len : e.pos + t, r = new $root.tensorflow.TensorShape(); e.pos < a;) {\n        var n = e.uint32();switch (n >>> 3) {case 2:\n            r.dim && r.dim.length || (r.dim = []), r.dim.push($root.tensorflow.TensorShape.Dim.decode(e, e.uint32()));break;case 3:\n            r.unknownRank = e.bool();break;default:\n            e.skipType(7 & n);}\n      }return r;\n    }, e.Dim = function () {\n      function e(e) {\n        if (e) for (var t = Object.keys(e), a = 0; a < t.length; ++a) null != e[t[a]] && (this[t[a]] = e[t[a]]);\n      }return e.prototype.size = $util.Long ? $util.Long.fromBits(0, 0, !1) : 0, e.prototype.name = \"\", e.decode = function (e, t) {\n        e instanceof $Reader || (e = $Reader.create(e));for (var a = void 0 === t ? e.len : e.pos + t, r = new $root.tensorflow.TensorShape.Dim(); e.pos < a;) {\n          var n = e.uint32();switch (n >>> 3) {case 1:\n              r.size = e.int64();break;case 2:\n              r.name = e.string();break;default:\n              e.skipType(7 & n);}\n        }return r;\n      }, e;\n    }(), e;\n  }(), a.Tensor = function () {\n    function e(e) {\n      if (this.floatVal = [], this.doubleVal = [], this.intVal = [], this.stringVal = [], this.scomplexVal = [], this.int64Val = [], this.boolVal = [], this.uint32Val = [], this.uint64Val = [], e) for (var t = Object.keys(e), a = 0; a < t.length; ++a) null != e[t[a]] && (this[t[a]] = e[t[a]]);\n    }return e.prototype.dtype = 0, e.prototype.tensorShape = null, e.prototype.versionNumber = 0, e.prototype.tensorContent = $util.newBuffer([]), e.prototype.floatVal = $util.emptyArray, e.prototype.doubleVal = $util.emptyArray, e.prototype.intVal = $util.emptyArray, e.prototype.stringVal = $util.emptyArray, e.prototype.scomplexVal = $util.emptyArray, e.prototype.int64Val = $util.emptyArray, e.prototype.boolVal = $util.emptyArray, e.prototype.uint32Val = $util.emptyArray, e.prototype.uint64Val = $util.emptyArray, e.decode = function (e, t) {\n      e instanceof $Reader || (e = $Reader.create(e));for (var a = void 0 === t ? e.len : e.pos + t, r = new $root.tensorflow.Tensor(); e.pos < a;) {\n        var n = e.uint32();switch (n >>> 3) {case 1:\n            r.dtype = e.int32();break;case 2:\n            r.tensorShape = $root.tensorflow.TensorShape.decode(e, e.uint32());break;case 3:\n            r.versionNumber = e.int32();break;case 4:\n            r.tensorContent = e.bytes();break;case 5:\n            if (r.floatVal && r.floatVal.length || (r.floatVal = []), 2 == (7 & n)) for (var o = e.uint32() + e.pos; e.pos < o;) r.floatVal.push(e.float());else r.floatVal.push(e.float());break;case 6:\n            if (r.doubleVal && r.doubleVal.length || (r.doubleVal = []), 2 == (7 & n)) for (o = e.uint32() + e.pos; e.pos < o;) r.doubleVal.push(e.double());else r.doubleVal.push(e.double());break;case 7:\n            if (r.intVal && r.intVal.length || (r.intVal = []), 2 == (7 & n)) for (o = e.uint32() + e.pos; e.pos < o;) r.intVal.push(e.int32());else r.intVal.push(e.int32());break;case 8:\n            r.stringVal && r.stringVal.length || (r.stringVal = []), r.stringVal.push(e.bytes());break;case 9:\n            if (r.scomplexVal && r.scomplexVal.length || (r.scomplexVal = []), 2 == (7 & n)) for (o = e.uint32() + e.pos; e.pos < o;) r.scomplexVal.push(e.float());else r.scomplexVal.push(e.float());break;case 10:\n            if (r.int64Val && r.int64Val.length || (r.int64Val = []), 2 == (7 & n)) for (o = e.uint32() + e.pos; e.pos < o;) r.int64Val.push(e.int64());else r.int64Val.push(e.int64());break;case 11:\n            if (r.boolVal && r.boolVal.length || (r.boolVal = []), 2 == (7 & n)) for (o = e.uint32() + e.pos; e.pos < o;) r.boolVal.push(e.bool());else r.boolVal.push(e.bool());break;case 16:\n            if (r.uint32Val && r.uint32Val.length || (r.uint32Val = []), 2 == (7 & n)) for (o = e.uint32() + e.pos; e.pos < o;) r.uint32Val.push(e.uint32());else r.uint32Val.push(e.uint32());break;case 17:\n            if (r.uint64Val && r.uint64Val.length || (r.uint64Val = []), 2 == (7 & n)) for (o = e.uint32() + e.pos; e.pos < o;) r.uint64Val.push(e.uint64());else r.uint64Val.push(e.uint64());break;default:\n            e.skipType(7 & n);}\n      }return r;\n    }, e;\n  }(), a.AttrValue = function () {\n    function e(e) {\n      if (e) for (var t = Object.keys(e), a = 0; a < t.length; ++a) null != e[t[a]] && (this[t[a]] = e[t[a]]);\n    }var t;return e.prototype.list = null, e.prototype.s = $util.newBuffer([]), e.prototype.i = $util.Long ? $util.Long.fromBits(0, 0, !1) : 0, e.prototype.f = 0, e.prototype.b = !1, e.prototype.type = 0, e.prototype.shape = null, e.prototype.tensor = null, e.prototype.placeholder = \"\", e.prototype.func = null, Object.defineProperty(e.prototype, \"value\", { get: $util.oneOfGetter(t = [\"list\", \"s\", \"i\", \"f\", \"b\", \"type\", \"shape\", \"tensor\", \"placeholder\", \"func\"]), set: $util.oneOfSetter(t) }), e.decode = function (e, t) {\n      e instanceof $Reader || (e = $Reader.create(e));for (var a = void 0 === t ? e.len : e.pos + t, r = new $root.tensorflow.AttrValue(); e.pos < a;) {\n        var n = e.uint32();switch (n >>> 3) {case 1:\n            r.list = $root.tensorflow.AttrValue.ListValue.decode(e, e.uint32());break;case 2:\n            r.s = e.bytes();break;case 3:\n            r.i = e.int64();break;case 4:\n            r.f = e.float();break;case 5:\n            r.b = e.bool();break;case 6:\n            r.type = e.int32();break;case 7:\n            r.shape = $root.tensorflow.TensorShape.decode(e, e.uint32());break;case 8:\n            r.tensor = $root.tensorflow.Tensor.decode(e, e.uint32());break;case 9:\n            r.placeholder = e.string();break;case 10:\n            r.func = $root.tensorflow.NameAttrList.decode(e, e.uint32());break;default:\n            e.skipType(7 & n);}\n      }return r;\n    }, e.ListValue = function () {\n      function e(e) {\n        if (this.s = [], this.i = [], this.f = [], this.b = [], this.type = [], this.shape = [], this.tensor = [], this.func = [], e) for (var t = Object.keys(e), a = 0; a < t.length; ++a) null != e[t[a]] && (this[t[a]] = e[t[a]]);\n      }return e.prototype.s = $util.emptyArray, e.prototype.i = $util.emptyArray, e.prototype.f = $util.emptyArray, e.prototype.b = $util.emptyArray, e.prototype.type = $util.emptyArray, e.prototype.shape = $util.emptyArray, e.prototype.tensor = $util.emptyArray, e.prototype.func = $util.emptyArray, e.decode = function (e, t) {\n        e instanceof $Reader || (e = $Reader.create(e));for (var a = void 0 === t ? e.len : e.pos + t, r = new $root.tensorflow.AttrValue.ListValue(); e.pos < a;) {\n          var n = e.uint32();switch (n >>> 3) {case 2:\n              r.s && r.s.length || (r.s = []), r.s.push(e.bytes());break;case 3:\n              if (r.i && r.i.length || (r.i = []), 2 == (7 & n)) for (var o = e.uint32() + e.pos; e.pos < o;) r.i.push(e.int64());else r.i.push(e.int64());break;case 4:\n              if (r.f && r.f.length || (r.f = []), 2 == (7 & n)) for (o = e.uint32() + e.pos; e.pos < o;) r.f.push(e.float());else r.f.push(e.float());break;case 5:\n              if (r.b && r.b.length || (r.b = []), 2 == (7 & n)) for (o = e.uint32() + e.pos; e.pos < o;) r.b.push(e.bool());else r.b.push(e.bool());break;case 6:\n              if (r.type && r.type.length || (r.type = []), 2 == (7 & n)) for (o = e.uint32() + e.pos; e.pos < o;) r.type.push(e.int32());else r.type.push(e.int32());break;case 7:\n              r.shape && r.shape.length || (r.shape = []), r.shape.push($root.tensorflow.TensorShape.decode(e, e.uint32()));break;case 8:\n              r.tensor && r.tensor.length || (r.tensor = []), r.tensor.push($root.tensorflow.Tensor.decode(e, e.uint32()));break;case 9:\n              r.func && r.func.length || (r.func = []), r.func.push($root.tensorflow.NameAttrList.decode(e, e.uint32()));break;default:\n              e.skipType(7 & n);}\n        }return r;\n      }, e;\n    }(), e;\n  }(), a.NameAttrList = function () {\n    function e(e) {\n      if (this.attr = {}, e) for (var t = Object.keys(e), a = 0; a < t.length; ++a) null != e[t[a]] && (this[t[a]] = e[t[a]]);\n    }return e.prototype.name = \"\", e.prototype.attr = $util.emptyObject, e.decode = function (e, t) {\n      e instanceof $Reader || (e = $Reader.create(e));for (var a, r = void 0 === t ? e.len : e.pos + t, n = new $root.tensorflow.NameAttrList(); e.pos < r;) {\n        var o = e.uint32();switch (o >>> 3) {case 1:\n            n.name = e.string();break;case 2:\n            e.skip().pos++, n.attr === $util.emptyObject && (n.attr = {}), a = e.string(), e.pos++, n.attr[a] = $root.tensorflow.AttrValue.decode(e, e.uint32());break;default:\n            e.skipType(7 & o);}\n      }return n;\n    }, e;\n  }(), a.NodeDef = function () {\n    function e(e) {\n      if (this.input = [], this.attr = {}, e) for (var t = Object.keys(e), a = 0; a < t.length; ++a) null != e[t[a]] && (this[t[a]] = e[t[a]]);\n    }return e.prototype.name = \"\", e.prototype.op = \"\", e.prototype.input = $util.emptyArray, e.prototype.device = \"\", e.prototype.attr = $util.emptyObject, e.decode = function (e, t) {\n      e instanceof $Reader || (e = $Reader.create(e));for (var a, r = void 0 === t ? e.len : e.pos + t, n = new $root.tensorflow.NodeDef(); e.pos < r;) {\n        var o = e.uint32();switch (o >>> 3) {case 1:\n            n.name = e.string();break;case 2:\n            n.op = e.string();break;case 3:\n            n.input && n.input.length || (n.input = []), n.input.push(e.string());break;case 4:\n            n.device = e.string();break;case 5:\n            e.skip().pos++, n.attr === $util.emptyObject && (n.attr = {}), a = e.string(), e.pos++, n.attr[a] = $root.tensorflow.AttrValue.decode(e, e.uint32());break;default:\n            e.skipType(7 & o);}\n      }return n;\n    }, e;\n  }(), a.VersionDef = function () {\n    function e(e) {\n      if (this.badConsumers = [], e) for (var t = Object.keys(e), a = 0; a < t.length; ++a) null != e[t[a]] && (this[t[a]] = e[t[a]]);\n    }return e.prototype.producer = 0, e.prototype.minConsumer = 0, e.prototype.badConsumers = $util.emptyArray, e.decode = function (e, t) {\n      e instanceof $Reader || (e = $Reader.create(e));for (var a = void 0 === t ? e.len : e.pos + t, r = new $root.tensorflow.VersionDef(); e.pos < a;) {\n        var n = e.uint32();switch (n >>> 3) {case 1:\n            r.producer = e.int32();break;case 2:\n            r.minConsumer = e.int32();break;case 3:\n            if (r.badConsumers && r.badConsumers.length || (r.badConsumers = []), 2 == (7 & n)) for (var o = e.uint32() + e.pos; e.pos < o;) r.badConsumers.push(e.int32());else r.badConsumers.push(e.int32());break;default:\n            e.skipType(7 & n);}\n      }return r;\n    }, e;\n  }(), a.GraphDef = function () {\n    function e(e) {\n      if (this.node = [], e) for (var t = Object.keys(e), a = 0; a < t.length; ++a) null != e[t[a]] && (this[t[a]] = e[t[a]]);\n    }return e.prototype.node = $util.emptyArray, e.prototype.versions = null, e.prototype.library = null, e.decode = function (e, t) {\n      e instanceof $Reader || (e = $Reader.create(e));for (var a = void 0 === t ? e.len : e.pos + t, r = new $root.tensorflow.GraphDef(); e.pos < a;) {\n        var n = e.uint32();switch (n >>> 3) {case 1:\n            r.node && r.node.length || (r.node = []), r.node.push($root.tensorflow.NodeDef.decode(e, e.uint32()));break;case 4:\n            r.versions = $root.tensorflow.VersionDef.decode(e, e.uint32());break;case 2:\n            r.library = $root.tensorflow.FunctionDefLibrary.decode(e, e.uint32());break;default:\n            e.skipType(7 & n);}\n      }return r;\n    }, e;\n  }(), a.CollectionDef = function () {\n    function e(e) {\n      if (e) for (var t = Object.keys(e), a = 0; a < t.length; ++a) null != e[t[a]] && (this[t[a]] = e[t[a]]);\n    }var t;return e.prototype.nodeList = null, e.prototype.bytesList = null, e.prototype.int64List = null, e.prototype.floatList = null, e.prototype.anyList = null, Object.defineProperty(e.prototype, \"kind\", { get: $util.oneOfGetter(t = [\"nodeList\", \"bytesList\", \"int64List\", \"floatList\", \"anyList\"]), set: $util.oneOfSetter(t) }), e.decode = function (e, t) {\n      e instanceof $Reader || (e = $Reader.create(e));for (var a = void 0 === t ? e.len : e.pos + t, r = new $root.tensorflow.CollectionDef(); e.pos < a;) {\n        var n = e.uint32();switch (n >>> 3) {case 1:\n            r.nodeList = $root.tensorflow.CollectionDef.NodeList.decode(e, e.uint32());break;case 2:\n            r.bytesList = $root.tensorflow.CollectionDef.BytesList.decode(e, e.uint32());break;case 3:\n            r.int64List = $root.tensorflow.CollectionDef.Int64List.decode(e, e.uint32());break;case 4:\n            r.floatList = $root.tensorflow.CollectionDef.FloatList.decode(e, e.uint32());break;case 5:\n            r.anyList = $root.tensorflow.CollectionDef.AnyList.decode(e, e.uint32());break;default:\n            e.skipType(7 & n);}\n      }return r;\n    }, e.NodeList = function () {\n      function e(e) {\n        if (this.value = [], e) for (var t = Object.keys(e), a = 0; a < t.length; ++a) null != e[t[a]] && (this[t[a]] = e[t[a]]);\n      }return e.prototype.value = $util.emptyArray, e.decode = function (e, t) {\n        e instanceof $Reader || (e = $Reader.create(e));for (var a = void 0 === t ? e.len : e.pos + t, r = new $root.tensorflow.CollectionDef.NodeList(); e.pos < a;) {\n          var n = e.uint32();switch (n >>> 3) {case 1:\n              r.value && r.value.length || (r.value = []), r.value.push(e.string());break;default:\n              e.skipType(7 & n);}\n        }return r;\n      }, e;\n    }(), e.BytesList = function () {\n      function e(e) {\n        if (this.value = [], e) for (var t = Object.keys(e), a = 0; a < t.length; ++a) null != e[t[a]] && (this[t[a]] = e[t[a]]);\n      }return e.prototype.value = $util.emptyArray, e.decode = function (e, t) {\n        e instanceof $Reader || (e = $Reader.create(e));for (var a = void 0 === t ? e.len : e.pos + t, r = new $root.tensorflow.CollectionDef.BytesList(); e.pos < a;) {\n          var n = e.uint32();switch (n >>> 3) {case 1:\n              r.value && r.value.length || (r.value = []), r.value.push(e.bytes());break;default:\n              e.skipType(7 & n);}\n        }return r;\n      }, e;\n    }(), e.Int64List = function () {\n      function e(e) {\n        if (this.value = [], e) for (var t = Object.keys(e), a = 0; a < t.length; ++a) null != e[t[a]] && (this[t[a]] = e[t[a]]);\n      }return e.prototype.value = $util.emptyArray, e.decode = function (e, t) {\n        e instanceof $Reader || (e = $Reader.create(e));for (var a = void 0 === t ? e.len : e.pos + t, r = new $root.tensorflow.CollectionDef.Int64List(); e.pos < a;) {\n          var n = e.uint32();switch (n >>> 3) {case 1:\n              if (r.value && r.value.length || (r.value = []), 2 == (7 & n)) for (var o = e.uint32() + e.pos; e.pos < o;) r.value.push(e.int64());else r.value.push(e.int64());break;default:\n              e.skipType(7 & n);}\n        }return r;\n      }, e;\n    }(), e.FloatList = function () {\n      function e(e) {\n        if (this.value = [], e) for (var t = Object.keys(e), a = 0; a < t.length; ++a) null != e[t[a]] && (this[t[a]] = e[t[a]]);\n      }return e.prototype.value = $util.emptyArray, e.decode = function (e, t) {\n        e instanceof $Reader || (e = $Reader.create(e));for (var a = void 0 === t ? e.len : e.pos + t, r = new $root.tensorflow.CollectionDef.FloatList(); e.pos < a;) {\n          var n = e.uint32();switch (n >>> 3) {case 1:\n              if (r.value && r.value.length || (r.value = []), 2 == (7 & n)) for (var o = e.uint32() + e.pos; e.pos < o;) r.value.push(e.float());else r.value.push(e.float());break;default:\n              e.skipType(7 & n);}\n        }return r;\n      }, e;\n    }(), e.AnyList = function () {\n      function e(e) {\n        if (this.value = [], e) for (var t = Object.keys(e), a = 0; a < t.length; ++a) null != e[t[a]] && (this[t[a]] = e[t[a]]);\n      }return e.prototype.value = $util.emptyArray, e.decode = function (e, t) {\n        e instanceof $Reader || (e = $Reader.create(e));for (var a = void 0 === t ? e.len : e.pos + t, r = new $root.tensorflow.CollectionDef.AnyList(); e.pos < a;) {\n          var n = e.uint32();switch (n >>> 3) {case 1:\n              r.value && r.value.length || (r.value = []), r.value.push($root.tensorflow.Any.decode(e, e.uint32()));break;default:\n              e.skipType(7 & n);}\n        }return r;\n      }, e;\n    }(), e;\n  }(), a.SaverDef = function () {\n    function e(e) {\n      if (e) for (var t = Object.keys(e), a = 0; a < t.length; ++a) null != e[t[a]] && (this[t[a]] = e[t[a]]);\n    }var t, a;return e.prototype.filenameTensorName = \"\", e.prototype.saveTensorName = \"\", e.prototype.restoreOpName = \"\", e.prototype.maxToKeep = 0, e.prototype.sharded = !1, e.prototype.keepCheckpointEveryNHours = 0, e.prototype.version = 0, e.decode = function (e, t) {\n      e instanceof $Reader || (e = $Reader.create(e));for (var a = void 0 === t ? e.len : e.pos + t, r = new $root.tensorflow.SaverDef(); e.pos < a;) {\n        var n = e.uint32();switch (n >>> 3) {case 1:\n            r.filenameTensorName = e.string();break;case 2:\n            r.saveTensorName = e.string();break;case 3:\n            r.restoreOpName = e.string();break;case 4:\n            r.maxToKeep = e.int32();break;case 5:\n            r.sharded = e.bool();break;case 6:\n            r.keepCheckpointEveryNHours = e.float();break;case 7:\n            r.version = e.int32();break;default:\n            e.skipType(7 & n);}\n      }return r;\n    }, e.CheckpointFormatVersion = (t = {}, (a = Object.create(t))[t[0] = \"LEGACY\"] = 0, a[t[1] = \"V1\"] = 1, a[t[2] = \"V2\"] = 2, a), e;\n  }(), a.TensorInfo = function () {\n    function e(e) {\n      if (e) for (var t = Object.keys(e), a = 0; a < t.length; ++a) null != e[t[a]] && (this[t[a]] = e[t[a]]);\n    }var t;return e.prototype.name = \"\", e.prototype.cooSparse = null, e.prototype.dtype = 0, e.prototype.tensorShape = null, Object.defineProperty(e.prototype, \"encoding\", { get: $util.oneOfGetter(t = [\"name\", \"cooSparse\"]), set: $util.oneOfSetter(t) }), e.decode = function (e, t) {\n      e instanceof $Reader || (e = $Reader.create(e));for (var a = void 0 === t ? e.len : e.pos + t, r = new $root.tensorflow.TensorInfo(); e.pos < a;) {\n        var n = e.uint32();switch (n >>> 3) {case 1:\n            r.name = e.string();break;case 4:\n            r.cooSparse = $root.tensorflow.TensorInfo.CooSparse.decode(e, e.uint32());break;case 2:\n            r.dtype = e.int32();break;case 3:\n            r.tensorShape = $root.tensorflow.TensorShape.decode(e, e.uint32());break;default:\n            e.skipType(7 & n);}\n      }return r;\n    }, e.CooSparse = function () {\n      function e(e) {\n        if (e) for (var t = Object.keys(e), a = 0; a < t.length; ++a) null != e[t[a]] && (this[t[a]] = e[t[a]]);\n      }return e.prototype.valuesTensorName = \"\", e.prototype.indicesTensorName = \"\", e.prototype.denseShapeTensorName = \"\", e.decode = function (e, t) {\n        e instanceof $Reader || (e = $Reader.create(e));for (var a = void 0 === t ? e.len : e.pos + t, r = new $root.tensorflow.TensorInfo.CooSparse(); e.pos < a;) {\n          var n = e.uint32();switch (n >>> 3) {case 1:\n              r.valuesTensorName = e.string();break;case 2:\n              r.indicesTensorName = e.string();break;case 3:\n              r.denseShapeTensorName = e.string();break;default:\n              e.skipType(7 & n);}\n        }return r;\n      }, e;\n    }(), e;\n  }(), a.SignatureDef = function () {\n    function e(e) {\n      if (this.inputs = {}, this.outputs = {}, e) for (var t = Object.keys(e), a = 0; a < t.length; ++a) null != e[t[a]] && (this[t[a]] = e[t[a]]);\n    }return e.prototype.inputs = $util.emptyObject, e.prototype.outputs = $util.emptyObject, e.prototype.methodName = \"\", e.decode = function (e, t) {\n      e instanceof $Reader || (e = $Reader.create(e));for (var a, r = void 0 === t ? e.len : e.pos + t, n = new $root.tensorflow.SignatureDef(); e.pos < r;) {\n        var o = e.uint32();switch (o >>> 3) {case 1:\n            e.skip().pos++, n.inputs === $util.emptyObject && (n.inputs = {}), a = e.string(), e.pos++, n.inputs[a] = $root.tensorflow.TensorInfo.decode(e, e.uint32());break;case 2:\n            e.skip().pos++, n.outputs === $util.emptyObject && (n.outputs = {}), a = e.string(), e.pos++, n.outputs[a] = $root.tensorflow.TensorInfo.decode(e, e.uint32());break;case 3:\n            n.methodName = e.string();break;default:\n            e.skipType(7 & o);}\n      }return n;\n    }, e;\n  }(), a.AssetFileDef = function () {\n    function e(e) {\n      if (e) for (var t = Object.keys(e), a = 0; a < t.length; ++a) null != e[t[a]] && (this[t[a]] = e[t[a]]);\n    }return e.prototype.tensorInfo = null, e.prototype.filename = \"\", e.decode = function (e, t) {\n      e instanceof $Reader || (e = $Reader.create(e));for (var a = void 0 === t ? e.len : e.pos + t, r = new $root.tensorflow.AssetFileDef(); e.pos < a;) {\n        var n = e.uint32();switch (n >>> 3) {case 1:\n            r.tensorInfo = $root.tensorflow.TensorInfo.decode(e, e.uint32());break;case 2:\n            r.filename = e.string();break;default:\n            e.skipType(7 & n);}\n      }return r;\n    }, e;\n  }(), a.OpDef = function () {\n    function e(e) {\n      if (this.inputArg = [], this.outputArg = [], this.attr = [], e) for (var t = Object.keys(e), a = 0; a < t.length; ++a) null != e[t[a]] && (this[t[a]] = e[t[a]]);\n    }return e.prototype.name = \"\", e.prototype.inputArg = $util.emptyArray, e.prototype.outputArg = $util.emptyArray, e.prototype.attr = $util.emptyArray, e.prototype.deprecation = null, e.prototype.summary = \"\", e.prototype.description = \"\", e.prototype.isCommutative = !1, e.prototype.isAggregate = !1, e.prototype.isStateful = !1, e.prototype.allowsUninitializedInput = !1, e.decode = function (e, t) {\n      e instanceof $Reader || (e = $Reader.create(e));for (var a = void 0 === t ? e.len : e.pos + t, r = new $root.tensorflow.OpDef(); e.pos < a;) {\n        var n = e.uint32();switch (n >>> 3) {case 1:\n            r.name = e.string();break;case 2:\n            r.inputArg && r.inputArg.length || (r.inputArg = []), r.inputArg.push($root.tensorflow.OpDef.ArgDef.decode(e, e.uint32()));break;case 3:\n            r.outputArg && r.outputArg.length || (r.outputArg = []), r.outputArg.push($root.tensorflow.OpDef.ArgDef.decode(e, e.uint32()));break;case 4:\n            r.attr && r.attr.length || (r.attr = []), r.attr.push($root.tensorflow.OpDef.AttrDef.decode(e, e.uint32()));break;case 8:\n            r.deprecation = $root.tensorflow.OpDef.OpDeprecation.decode(e, e.uint32());break;case 5:\n            r.summary = e.string();break;case 6:\n            r.description = e.string();break;case 18:\n            r.isCommutative = e.bool();break;case 16:\n            r.isAggregate = e.bool();break;case 17:\n            r.isStateful = e.bool();break;case 19:\n            r.allowsUninitializedInput = e.bool();break;default:\n            e.skipType(7 & n);}\n      }return r;\n    }, e.ArgDef = function () {\n      function e(e) {\n        if (e) for (var t = Object.keys(e), a = 0; a < t.length; ++a) null != e[t[a]] && (this[t[a]] = e[t[a]]);\n      }return e.prototype.name = \"\", e.prototype.description = \"\", e.prototype.type = 0, e.prototype.typeAttr = \"\", e.prototype.numberAttr = \"\", e.prototype.typeListAttr = \"\", e.prototype.isRef = !1, e.decode = function (e, t) {\n        e instanceof $Reader || (e = $Reader.create(e));for (var a = void 0 === t ? e.len : e.pos + t, r = new $root.tensorflow.OpDef.ArgDef(); e.pos < a;) {\n          var n = e.uint32();switch (n >>> 3) {case 1:\n              r.name = e.string();break;case 2:\n              r.description = e.string();break;case 3:\n              r.type = e.int32();break;case 4:\n              r.typeAttr = e.string();break;case 5:\n              r.numberAttr = e.string();break;case 6:\n              r.typeListAttr = e.string();break;case 16:\n              r.isRef = e.bool();break;default:\n              e.skipType(7 & n);}\n        }return r;\n      }, e;\n    }(), e.AttrDef = function () {\n      function e(e) {\n        if (e) for (var t = Object.keys(e), a = 0; a < t.length; ++a) null != e[t[a]] && (this[t[a]] = e[t[a]]);\n      }return e.prototype.name = \"\", e.prototype.type = \"\", e.prototype.defaultValue = null, e.prototype.description = \"\", e.prototype.hasMinimum = !1, e.prototype.minimum = $util.Long ? $util.Long.fromBits(0, 0, !1) : 0, e.prototype.allowedValues = null, e.decode = function (e, t) {\n        e instanceof $Reader || (e = $Reader.create(e));for (var a = void 0 === t ? e.len : e.pos + t, r = new $root.tensorflow.OpDef.AttrDef(); e.pos < a;) {\n          var n = e.uint32();switch (n >>> 3) {case 1:\n              r.name = e.string();break;case 2:\n              r.type = e.string();break;case 3:\n              r.defaultValue = $root.tensorflow.AttrValue.decode(e, e.uint32());break;case 4:\n              r.description = e.string();break;case 5:\n              r.hasMinimum = e.bool();break;case 6:\n              r.minimum = e.int64();break;case 7:\n              r.allowedValues = $root.tensorflow.AttrValue.decode(e, e.uint32());break;default:\n              e.skipType(7 & n);}\n        }return r;\n      }, e;\n    }(), e.OpDeprecation = function () {\n      function e(e) {\n        if (e) for (var t = Object.keys(e), a = 0; a < t.length; ++a) null != e[t[a]] && (this[t[a]] = e[t[a]]);\n      }return e.prototype.version = 0, e.prototype.explanation = \"\", e.decode = function (e, t) {\n        e instanceof $Reader || (e = $Reader.create(e));for (var a = void 0 === t ? e.len : e.pos + t, r = new $root.tensorflow.OpDef.OpDeprecation(); e.pos < a;) {\n          var n = e.uint32();switch (n >>> 3) {case 1:\n              r.version = e.int32();break;case 2:\n              r.explanation = e.string();break;default:\n              e.skipType(7 & n);}\n        }return r;\n      }, e;\n    }(), e;\n  }(), a.OpList = function () {\n    function e(e) {\n      if (this.op = [], e) for (var t = Object.keys(e), a = 0; a < t.length; ++a) null != e[t[a]] && (this[t[a]] = e[t[a]]);\n    }return e.prototype.op = $util.emptyArray, e.decode = function (e, t) {\n      e instanceof $Reader || (e = $Reader.create(e));for (var a = void 0 === t ? e.len : e.pos + t, r = new $root.tensorflow.OpList(); e.pos < a;) {\n        var n = e.uint32();switch (n >>> 3) {case 1:\n            r.op && r.op.length || (r.op = []), r.op.push($root.tensorflow.OpDef.decode(e, e.uint32()));break;default:\n            e.skipType(7 & n);}\n      }return r;\n    }, e;\n  }(), a.MetaGraphDef = function () {\n    function e(e) {\n      if (this.collectionDef = {}, this.signatureDef = {}, this.assetFileDef = [], e) for (var t = Object.keys(e), a = 0; a < t.length; ++a) null != e[t[a]] && (this[t[a]] = e[t[a]]);\n    }return e.prototype.metaInfoDef = null, e.prototype.graphDef = null, e.prototype.saverDef = null, e.prototype.collectionDef = $util.emptyObject, e.prototype.signatureDef = $util.emptyObject, e.prototype.assetFileDef = $util.emptyArray, e.decode = function (e, t) {\n      e instanceof $Reader || (e = $Reader.create(e));for (var a, r = void 0 === t ? e.len : e.pos + t, n = new $root.tensorflow.MetaGraphDef(); e.pos < r;) {\n        var o = e.uint32();switch (o >>> 3) {case 1:\n            n.metaInfoDef = $root.tensorflow.MetaGraphDef.MetaInfoDef.decode(e, e.uint32());break;case 2:\n            n.graphDef = $root.tensorflow.GraphDef.decode(e, e.uint32());break;case 3:\n            n.saverDef = $root.tensorflow.SaverDef.decode(e, e.uint32());break;case 4:\n            e.skip().pos++, n.collectionDef === $util.emptyObject && (n.collectionDef = {}), a = e.string(), e.pos++, n.collectionDef[a] = $root.tensorflow.CollectionDef.decode(e, e.uint32());break;case 5:\n            e.skip().pos++, n.signatureDef === $util.emptyObject && (n.signatureDef = {}), a = e.string(), e.pos++, n.signatureDef[a] = $root.tensorflow.SignatureDef.decode(e, e.uint32());break;case 6:\n            n.assetFileDef && n.assetFileDef.length || (n.assetFileDef = []), n.assetFileDef.push($root.tensorflow.AssetFileDef.decode(e, e.uint32()));break;default:\n            e.skipType(7 & o);}\n      }return n;\n    }, e.MetaInfoDef = function () {\n      function e(e) {\n        if (this.tags = [], e) for (var t = Object.keys(e), a = 0; a < t.length; ++a) null != e[t[a]] && (this[t[a]] = e[t[a]]);\n      }return e.prototype.metaGraphVersion = \"\", e.prototype.strippedOpList = null, e.prototype.anyInfo = null, e.prototype.tags = $util.emptyArray, e.prototype.tensorflowVersion = \"\", e.prototype.tensorflowGitVersion = \"\", e.decode = function (e, t) {\n        e instanceof $Reader || (e = $Reader.create(e));for (var a = void 0 === t ? e.len : e.pos + t, r = new $root.tensorflow.MetaGraphDef.MetaInfoDef(); e.pos < a;) {\n          var n = e.uint32();switch (n >>> 3) {case 1:\n              r.metaGraphVersion = e.string();break;case 2:\n              r.strippedOpList = $root.tensorflow.OpList.decode(e, e.uint32());break;case 3:\n              r.anyInfo = $root.tensorflow.Any.decode(e, e.uint32());break;case 4:\n              r.tags && r.tags.length || (r.tags = []), r.tags.push(e.string());break;case 5:\n              r.tensorflowVersion = e.string();break;case 6:\n              r.tensorflowGitVersion = e.string();break;default:\n              e.skipType(7 & n);}\n        }return r;\n      }, e;\n    }(), e;\n  }(), a.SavedModel = function () {\n    function e(e) {\n      if (this.metaGraphs = [], e) for (var t = Object.keys(e), a = 0; a < t.length; ++a) null != e[t[a]] && (this[t[a]] = e[t[a]]);\n    }return e.prototype.savedModelSchemaVersion = $util.Long ? $util.Long.fromBits(0, 0, !1) : 0, e.prototype.metaGraphs = $util.emptyArray, e.decode = function (e, t) {\n      e instanceof $Reader || (e = $Reader.create(e));for (var a = void 0 === t ? e.len : e.pos + t, r = new $root.tensorflow.SavedModel(); e.pos < a;) {\n        var n = e.uint32();switch (n >>> 3) {case 1:\n            r.savedModelSchemaVersion = e.int64();break;case 2:\n            r.metaGraphs && r.metaGraphs.length || (r.metaGraphs = []), r.metaGraphs.push($root.tensorflow.MetaGraphDef.decode(e, e.uint32()));break;default:\n            e.skipType(7 & n);}\n      }return r;\n    }, e;\n  }(), a.FunctionDefLibrary = function () {\n    function e(e) {\n      if (this.function = [], this.gradient = [], e) for (var t = Object.keys(e), a = 0; a < t.length; ++a) null != e[t[a]] && (this[t[a]] = e[t[a]]);\n    }return e.prototype.function = $util.emptyArray, e.prototype.gradient = $util.emptyArray, e.decode = function (e, t) {\n      e instanceof $Reader || (e = $Reader.create(e));for (var a = void 0 === t ? e.len : e.pos + t, r = new $root.tensorflow.FunctionDefLibrary(); e.pos < a;) {\n        var n = e.uint32();switch (n >>> 3) {case 1:\n            r.function && r.function.length || (r.function = []), r.function.push($root.tensorflow.FunctionDef.decode(e, e.uint32()));break;case 2:\n            r.gradient && r.gradient.length || (r.gradient = []), r.gradient.push($root.tensorflow.GradientDef.decode(e, e.uint32()));break;default:\n            e.skipType(7 & n);}\n      }return r;\n    }, e;\n  }(), a.FunctionDef = function () {\n    function e(e) {\n      if (this.attr = {}, this.nodeDef = [], this.ret = {}, e) for (var t = Object.keys(e), a = 0; a < t.length; ++a) null != e[t[a]] && (this[t[a]] = e[t[a]]);\n    }return e.prototype.signature = null, e.prototype.attr = $util.emptyObject, e.prototype.nodeDef = $util.emptyArray, e.prototype.ret = $util.emptyObject, e.decode = function (e, t) {\n      e instanceof $Reader || (e = $Reader.create(e));for (var a, r = void 0 === t ? e.len : e.pos + t, n = new $root.tensorflow.FunctionDef(); e.pos < r;) {\n        var o = e.uint32();switch (o >>> 3) {case 1:\n            n.signature = $root.tensorflow.OpDef.decode(e, e.uint32());break;case 5:\n            e.skip().pos++, n.attr === $util.emptyObject && (n.attr = {}), a = e.string(), e.pos++, n.attr[a] = $root.tensorflow.AttrValue.decode(e, e.uint32());break;case 3:\n            n.nodeDef && n.nodeDef.length || (n.nodeDef = []), n.nodeDef.push($root.tensorflow.NodeDef.decode(e, e.uint32()));break;case 4:\n            e.skip().pos++, n.ret === $util.emptyObject && (n.ret = {}), a = e.string(), e.pos++, n.ret[a] = e.string();break;default:\n            e.skipType(7 & o);}\n      }return n;\n    }, e;\n  }(), a.GradientDef = function () {\n    function e(e) {\n      if (e) for (var t = Object.keys(e), a = 0; a < t.length; ++a) null != e[t[a]] && (this[t[a]] = e[t[a]]);\n    }return e.prototype.functionName = \"\", e.prototype.gradientFunc = \"\", e.decode = function (e, t) {\n      e instanceof $Reader || (e = $Reader.create(e));for (var a = void 0 === t ? e.len : e.pos + t, r = new $root.tensorflow.GradientDef(); e.pos < a;) {\n        var n = e.uint32();switch (n >>> 3) {case 1:\n            r.functionName = e.string();break;case 2:\n            r.gradientFunc = e.string();break;default:\n            e.skipType(7 & n);}\n      }return r;\n    }, e;\n  }(), a;\n}();var compiled_api = $root,\n    compiled_api_1 = compiled_api.tensorflow;function getParamValue(e, t, a, r) {\n  var n = t.params[e];if (n && void 0 !== n.inputIndex) {\n    if (\"tensor\" === n.type) return getTensor(t.inputNames[n.inputIndex], a, r);if (\"tensors\" === n.type) return (0 === n.inputIndex ? 0 === n.inputParamLength ? t.inputNames : t.inputNames.slice(n.inputIndex, -n.inputParamLength) : t.inputNames.splice(n.inputIndex)).map(function (e) {\n      return getTensor(e, a, r);\n    });var o = Array.prototype.slice.call(getTensor(t.inputNames.slice(n.inputIndex)[0], a, r).dataSync());return \"number\" === n.type ? o[0] : o;\n  }return n && n.value;\n}function getTensor(e, t, a) {\n  var r = parseNodeName(e),\n      n = r[0],\n      o = r[1],\n      s = a.currentContextIds.find(function (e) {\n    return !!t[getNodeNameWithContextId(n, e)];\n  });return void 0 !== s ? t[getNodeNameWithContextId(n, s)][o] : void 0;\n}function getNodeNameAndIndex(e, t) {\n  var a = parseNodeName(e),\n      r = a[0],\n      n = a[1];return [getNodeNameWithContextId(r, t && t.currentContextId), n];\n}function getNodeNameWithContextId(e, t) {\n  return t ? e + \"-\" + t : e;\n}function parseNodeName(e) {\n  var t = e.lastIndexOf(\":\");return -1 === t ? [e, 0] : [e.substring(0, t), Number(e.substring(t + 1))];\n}function split$1(e, t) {\n  for (var a = [], r = 0; r < e.length; r += t) a.push(e.slice(r, r + t));return a;\n}var json = [{ tfOpName: \"Add\", dlOpName: \"add\", category: \"arithmetic\", params: [{ tfInputIndex: 0, dlParamName: \"a\", type: \"tensor\" }, { tfInputIndex: 1, dlParamName: \"b\", type: \"tensor\" }, { tfParamName: \"T\", dlParamName: \"dtype\", type: \"dtype\", notSupported: !0 }] }, { tfOpName: \"AddN\", dlOpName: \"addN\", category: \"arithmetic\", params: [{ tfInputIndex: 0, tfInputParamLength: 0, dlParamName: \"tensors\", type: \"tensors\" }] }, { tfOpName: \"BiasAdd\", dlOpName: \"add\", category: \"arithmetic\", params: [{ tfInputIndex: 0, dlParamName: \"a\", type: \"tensor\" }, { tfInputIndex: 1, dlParamName: \"b\", type: \"tensor\" }, { tfParamName: \"T\", dlParamName: \"dtype\", type: \"dtype\", notSupported: !0 }] }, { tfOpName: \"Sub\", dlOpName: \"sub\", category: \"arithmetic\", params: [{ tfInputIndex: 0, dlParamName: \"a\", type: \"tensor\" }, { tfInputIndex: 1, dlParamName: \"b\", type: \"tensor\" }, { tfParamName: \"T\", dlParamName: \"dtype\", type: \"dtype\", notSupported: !0 }] }, { tfOpName: \"RealDiv\", dlOpName: \"div\", category: \"arithmetic\", params: [{ tfInputIndex: 0, dlParamName: \"a\", type: \"tensor\" }, { tfInputIndex: 1, dlParamName: \"b\", type: \"tensor\" }, { tfParamName: \"T\", dlParamName: \"dtype\", type: \"dtype\", notSupported: !0 }] }, { tfOpName: \"Div\", dlOpName: \"div\", category: \"arithmetic\", params: [{ tfInputIndex: 0, dlParamName: \"a\", type: \"tensor\" }, { tfInputIndex: 1, dlParamName: \"b\", type: \"tensor\" }, { tfParamName: \"T\", dlParamName: \"dtype\", type: \"dtype\", notSupported: !0 }] }, { tfOpName: \"FloorDiv\", dlOpName: \"floorDiv\", category: \"arithmetic\", params: [{ tfInputIndex: 0, dlParamName: \"a\", type: \"tensor\" }, { tfInputIndex: 1, dlParamName: \"b\", type: \"tensor\" }, { tfParamName: \"T\", dlParamName: \"dtype\", type: \"dtype\", notSupported: !0 }] }, { tfOpName: \"Mul\", dlOpName: \"mul\", category: \"arithmetic\", params: [{ tfInputIndex: 0, dlParamName: \"a\", type: \"tensor\" }, { tfInputIndex: 1, dlParamName: \"b\", type: \"tensor\" }, { tfParamName: \"T\", dlParamName: \"dtype\", type: \"dtype\", notSupported: !0 }] }, { tfOpName: \"Maximum\", dlOpName: \"maximum\", category: \"arithmetic\", params: [{ tfInputIndex: 0, dlParamName: \"a\", type: \"tensor\" }, { tfInputIndex: 1, dlParamName: \"b\", type: \"tensor\" }] }, { tfOpName: \"Minimum\", dlOpName: \"minimum\", category: \"arithmetic\", params: [{ tfInputIndex: 0, dlParamName: \"a\", type: \"tensor\" }, { tfInputIndex: 1, dlParamName: \"b\", type: \"tensor\" }] }, { tfOpName: \"Pow\", dlOpName: \"pow\", category: \"arithmetic\", params: [{ tfInputIndex: 0, dlParamName: \"a\", type: \"tensor\" }, { tfInputIndex: 1, dlParamName: \"b\", type: \"tensor\" }, { tfParamName: \"T\", dlParamName: \"dtype\", type: \"dtype\", notSupported: !0 }] }, { tfOpName: \"SquaredDifference\", dlOpName: \"squaredDifference\", category: \"arithmetic\", params: [{ tfInputIndex: 0, dlParamName: \"a\", type: \"tensor\" }, { tfInputIndex: 1, dlParamName: \"b\", type: \"tensor\" }, { tfParamName: \"T\", dlParamName: \"dtype\", type: \"dtype\", notSupported: !0 }] }, { tfOpName: \"Mod\", dlOpName: \"mod\", category: \"arithmetic\", params: [{ tfInputIndex: 0, dlParamName: \"a\", type: \"tensor\" }, { tfInputIndex: 1, dlParamName: \"b\", type: \"tensor\" }, { tfParamName: \"T\", dlParamName: \"dtype\", type: \"dtype\", notSupported: !0 }] }],\n    arithmetic = Object.freeze({ json: json }),\n    json$1 = [{ tfOpName: \"Abs\", dlOpName: \"abs\", category: \"basic_math\", params: [{ tfInputIndex: 0, dlParamName: \"x\", type: \"tensor\" }, { tfParamName: \"T\", dlParamName: \"dtype\", type: \"dtype\", notSupported: !0 }] }, { tfOpName: \"Acos\", dlOpName: \"acos\", category: \"basic_math\", params: [{ tfInputIndex: 0, dlParamName: \"x\", type: \"tensor\" }, { tfParamName: \"T\", dlParamName: \"dtype\", type: \"dtype\", notSupported: !0 }] }, { tfOpName: \"Asin\", dlOpName: \"asin\", category: \"basic_math\", params: [{ tfInputIndex: 0, dlParamName: \"x\", type: \"tensor\" }, { tfParamName: \"T\", dlParamName: \"dtype\", type: \"dtype\", notSupported: !0 }] }, { tfOpName: \"atan\", dlOpName: \"atan\", category: \"basic_math\", params: [{ tfInputIndex: 0, dlParamName: \"x\", type: \"tensor\" }, { tfParamName: \"T\", dlParamName: \"dtype\", type: \"dtype\", notSupported: !0 }] }, { tfOpName: \"Ceil\", dlOpName: \"ceil\", category: \"basic_math\", params: [{ tfInputIndex: 0, dlParamName: \"x\", type: \"tensor\" }, { tfParamName: \"T\", dlParamName: \"dtype\", type: \"dtype\", notSupported: !0 }] }, { tfOpName: \"ClipByValue\", dlOpName: \"clipByValue\", category: \"basic_math\", params: [{ tfInputIndex: 0, dlParamName: \"x\", type: \"tensor\" }, { tfParamName: \"clip_value_min\", dlParamName: \"clipValueMin\", type: \"number\" }, { tfParamName: \"clip_value_max\", dlParamName: \"clipValueMax\", type: \"number\" }] }, { tfOpName: \"Cos\", dlOpName: \"cos\", category: \"basic_math\", params: [{ tfInputIndex: 0, dlParamName: \"x\", type: \"tensor\" }, { tfParamName: \"T\", dlParamName: \"dtype\", type: \"dtype\", notSupported: !0 }] }, { tfOpName: \"Cosh\", dlOpName: \"cosh\", category: \"basic_math\", params: [{ tfInputIndex: 0, dlParamName: \"x\", type: \"tensor\" }, { tfParamName: \"T\", dlParamName: \"dtype\", type: \"dtype\", notSupported: !0 }] }, { tfOpName: \"Elu\", dlOpName: \"elu\", category: \"basic_math\", params: [{ tfInputIndex: 0, dlParamName: \"x\", type: \"tensor\" }, { tfParamName: \"T\", dlParamName: \"dtype\", type: \"dtype\", notSupported: !0 }] }, { tfOpName: \"Exp\", dlOpName: \"exp\", category: \"basic_math\", params: [{ tfInputIndex: 0, dlParamName: \"x\", type: \"tensor\" }, { tfParamName: \"T\", dlParamName: \"dtype\", type: \"dtype\", notSupported: !0 }] }, { tfOpName: \"Floor\", dlOpName: \"floor\", category: \"basic_math\", params: [{ tfInputIndex: 0, dlParamName: \"x\", type: \"tensor\" }, { tfParamName: \"T\", dlParamName: \"dtype\", type: \"dtype\", notSupported: !0 }] }, { tfOpName: \"Log\", dlOpName: \"log\", category: \"basic_math\", params: [{ tfInputIndex: 0, dlParamName: \"x\", type: \"tensor\" }, { tfParamName: \"T\", dlParamName: \"dtype\", type: \"dtype\", notSupported: !0 }] }, { tfOpName: \"Neg\", dlOpName: \"neg\", category: \"basic_math\", params: [{ tfInputIndex: 0, dlParamName: \"x\", type: \"tensor\" }, { tfParamName: \"T\", dlParamName: \"dtype\", type: \"dtype\", notSupported: !0 }] }, { tfOpName: \"Relu\", dlOpName: \"relu\", category: \"basic_math\", params: [{ tfInputIndex: 0, dlParamName: \"x\", type: \"tensor\" }, { tfParamName: \"T\", dlParamName: \"dtype\", type: \"dtype\", notSupported: !0 }] }, { tfOpName: \"Relu6\", dlOpName: \"clipByValue\", category: \"basic_math\", params: [{ tfInputIndex: 0, dlParamName: \"x\", type: \"tensor\" }, { tfParamName: \"T\", dlParamName: \"dtype\", type: \"dtype\", notSupported: !0 }, { dlParamName: \"clipValueMin\", type: \"number\", defaultValue: 0 }, { dlParamName: \"clipValueMax\", type: \"number\", defaultValue: 6 }] }, { tfOpName: \"Selu\", dlOpName: \"selu\", category: \"basic_math\", params: [{ tfInputIndex: 0, dlParamName: \"x\", type: \"tensor\" }, { tfParamName: \"T\", dlParamName: \"dtype\", type: \"dtype\", notSupported: !0 }] }, { tfOpName: \"Sigmoid\", dlOpName: \"sigmoid\", category: \"basic_math\", params: [{ tfInputIndex: 0, dlParamName: \"x\", type: \"tensor\" }, { tfParamName: \"T\", dlParamName: \"dtype\", type: \"dtype\", notSupported: !0 }] }, { tfOpName: \"Sin\", dlOpName: \"sin\", category: \"basic_math\", params: [{ tfInputIndex: 0, dlParamName: \"x\", type: \"tensor\" }, { tfParamName: \"T\", dlParamName: \"dtype\", type: \"dtype\", notSupported: !0 }] }, { tfOpName: \"Sinh\", dlOpName: \"sinh\", category: \"basic_math\", params: [{ tfInputIndex: 0, dlParamName: \"x\", type: \"tensor\" }, { tfParamName: \"T\", dlParamName: \"dtype\", type: \"dtype\", notSupported: !0 }] }, { tfOpName: \"Sqrt\", dlOpName: \"sqrt\", category: \"basic_math\", params: [{ tfInputIndex: 0, dlParamName: \"x\", type: \"tensor\" }, { tfParamName: \"T\", dlParamName: \"dtype\", type: \"dtype\", notSupported: !0 }] }, { tfOpName: \"Rsqrt\", dlOpName: \"rsqrt\", category: \"basic_math\", params: [{ tfInputIndex: 0, dlParamName: \"x\", type: \"tensor\" }, { tfParamName: \"T\", dlParamName: \"dtype\", type: \"dtype\", notSupported: !0 }] }, { tfOpName: \"Square\", dlOpName: \"square\", category: \"basic_math\", params: [{ tfInputIndex: 0, dlParamName: \"x\", type: \"tensor\" }, { tfParamName: \"T\", dlParamName: \"dtype\", type: \"dtype\", notSupported: !0 }] }, { tfOpName: \"Tan\", dlOpName: \"tan\", category: \"basic_math\", params: [{ tfInputIndex: 0, dlParamName: \"x\", type: \"tensor\" }, { tfParamName: \"T\", dlParamName: \"dtype\", type: \"dtype\", notSupported: !0 }] }, { tfOpName: \"Tanh\", dlOpName: \"tanh\", category: \"basic_math\", params: [{ tfInputIndex: 0, dlParamName: \"x\", type: \"tensor\" }, { tfParamName: \"T\", dlParamName: \"dtype\", type: \"dtype\", notSupported: !0 }] }, { tfOpName: \"Sign\", dlOpName: \"sign\", category: \"basic_math\", params: [{ tfInputIndex: 0, dlParamName: \"x\", type: \"tensor\" }, { tfParamName: \"T\", dlParamName: \"dtype\", type: \"dtype\", notSupported: !0 }] }, { tfOpName: \"Round\", dlOpName: \"round\", category: \"basic_math\", params: [{ tfInputIndex: 0, dlParamName: \"x\", type: \"tensor\" }, { tfParamName: \"T\", dlParamName: \"dtype\", type: \"dtype\", notSupported: !0 }] }, { tfOpName: \"Expm1\", dlOpName: \"expm1\", category: \"basic_math\", params: [{ tfInputIndex: 0, dlParamName: \"x\", type: \"tensor\" }, { tfParamName: \"T\", dlParamName: \"dtype\", type: \"dtype\", notSupported: !0 }] }, { tfOpName: \"Log1p\", dlOpName: \"log1p\", category: \"basic_math\", params: [{ tfInputIndex: 0, dlParamName: \"x\", type: \"tensor\" }, { tfParamName: \"T\", dlParamName: \"dtype\", type: \"dtype\", notSupported: !0 }] }, { tfOpName: \"Reciprocal\", dlOpName: \"reciprocal\", category: \"basic_math\", params: [{ tfInputIndex: 0, dlParamName: \"x\", type: \"tensor\" }, { tfParamName: \"T\", dlParamName: \"dtype\", type: \"dtype\", notSupported: !0 }] }, { tfOpName: \"Reciprocal\", dlOpName: \"reciprocal\", category: \"basic_math\", params: [{ tfInputIndex: 0, dlParamName: \"x\", type: \"tensor\" }, { tfParamName: \"T\", dlParamName: \"dtype\", type: \"dtype\", notSupported: !0 }] }, { tfOpName: \"Softplus\", dlOpName: \"softplus\", category: \"basic_math\", params: [{ tfInputIndex: 0, dlParamName: \"x\", type: \"tensor\" }, { tfParamName: \"T\", dlParamName: \"dtype\", type: \"dtype\", notSupported: !0 }] }, { tfOpName: \"Asinh\", dlOpName: \"asinh\", category: \"basic_math\", params: [{ tfInputIndex: 0, dlParamName: \"x\", type: \"tensor\" }, { tfParamName: \"T\", dlParamName: \"dtype\", type: \"dtype\", notSupported: !0 }] }, { tfOpName: \"Acosh\", dlOpName: \"acosh\", category: \"basic_math\", params: [{ tfInputIndex: 0, dlParamName: \"x\", type: \"tensor\" }, { tfParamName: \"T\", dlParamName: \"dtype\", type: \"dtype\", notSupported: !0 }] }, { tfOpName: \"Atanh\", dlOpName: \"atanh\", category: \"basic_math\", params: [{ tfInputIndex: 0, dlParamName: \"x\", type: \"tensor\" }, { tfParamName: \"T\", dlParamName: \"dtype\", type: \"dtype\", notSupported: !0 }] }, { tfOpName: \"Erf\", dlOpName: \"erf\", category: \"basic_math\", params: [{ tfInputIndex: 0, dlParamName: \"x\", type: \"tensor\" }, { tfParamName: \"T\", dlParamName: \"dtype\", type: \"dtype\", notSupported: !0 }] }],\n    basicMath = Object.freeze({ json: json$1 }),\n    json$2 = [{ tfOpName: \"LoopCond\", dlOpName: \"loopCond\", category: \"control\", params: [{ tfInputIndex: 0, dlParamName: \"pred\", type: \"tensor\" }] }, { tfOpName: \"Switch\", dlOpName: \"switch\", category: \"control\", params: [{ tfInputIndex: 0, dlParamName: \"data\", type: \"tensor\" }, { tfInputIndex: 1, dlParamName: \"pred\", type: \"tensor\" }] }, { tfOpName: \"Merge\", dlOpName: \"merge\", category: \"control\", params: [{ tfInputIndex: 0, tfInputParamLength: 0, dlParamName: \"tensors\", type: \"tensors\" }] }, { tfOpName: \"Enter\", dlOpName: \"enter\", category: \"control\", params: [{ tfInputIndex: 0, dlParamName: \"tensor\", type: \"tensor\" }, { tfParamName: \"T\", dlParamName: \"dtype\", type: \"dtype\", notSupported: !0 }, { tfParamName: \"frame_name\", dlParamName: \"frameName\", type: \"string\" }, { tfParamName: \"is_constant\", dlParamName: \"isConstant\", type: \"bool\" }] }, { tfOpName: \"Exit\", dlOpName: \"exit\", category: \"control\", params: [{ tfInputIndex: 0, dlParamName: \"tensor\", type: \"tensor\" }, { tfParamName: \"T\", dlParamName: \"dtype\", type: \"dtype\", notSupported: !0 }] }, { tfOpName: \"NextIteration\", dlOpName: \"nextIteration\", category: \"control\", params: [{ tfInputIndex: 0, dlParamName: \"tensor\", type: \"tensor\" }, { tfParamName: \"T\", dlParamName: \"dtype\", type: \"dtype\", notSupported: !0 }] }, { tfOpName: \"TensorArrayV3\", dlOpName: \"tensorArray\", category: \"control\", params: [{ tfInputIndex: 0, dlParamName: \"size\", type: \"number\" }, { tfParamName: \"dtype\", dlParamName: \"dtype\", type: \"dtype\" }, { tfParamName: \"element_shape\", dlParamName: \"elementShape\", type: \"shape\" }, { tfParamName: \"dynamic_size\", dlParamName: \"dynamicSize\", type: \"bool\" }, { tfParamName: \"clear_after_read\", dlParamName: \"clearAfterRead\", type: \"bool\" }, { tfParamName: \"identical_element_shapes\", dlParamName: \"identicalElementShapes\", type: \"bool\" }, { tfParamName: \"tensor_array_name\", dlParamName: \"name\", type: \"string\" }] }, { tfOpName: \"TensorArrayWriteV3\", dlOpName: \"tensorArrayWrite\", category: \"control\", params: [{ tfInputIndex: 0, dlParamName: \"tensorArrayId\", type: \"number\" }, { tfInputIndex: 1, dlParamName: \"index\", type: \"number\" }, { tfInputIndex: 2, dlParamName: \"tensor\", type: \"tensor\" }, { tfInputIndex: 3, dlParamName: \"flowIn\", type: \"number\" }, { tfParamName: \"T\", dlParamName: \"dtype\", type: \"dtype\", notSupported: !0 }] }, { tfOpName: \"TensorArrayReadV3\", dlOpName: \"tensorArrayRead\", category: \"control\", params: [{ tfInputIndex: 0, dlParamName: \"tensorArrayId\", type: \"number\" }, { tfInputIndex: 1, dlParamName: \"index\", type: \"number\" }, { tfInputIndex: 2, dlParamName: \"flowIn\", type: \"number\" }, { tfParamName: \"dtype\", dlParamName: \"dtype\", type: \"dtype\", notSupported: !0 }] }, { tfOpName: \"TensorArrayGatherV3\", dlOpName: \"tensorArrayGather\", category: \"control\", params: [{ tfInputIndex: 0, dlParamName: \"tensorArrayId\", type: \"number\" }, { tfInputIndex: 1, dlParamName: \"indices\", type: \"number[]\" }, { tfInputIndex: 2, dlParamName: \"flowIn\", type: \"number\" }, { tfParamName: \"dtype\", dlParamName: \"dtype\", type: \"dtype\" }, { tfParamName: \"element_shape\", dlParamName: \"elementShape\", type: \"shape\" }] }, { tfOpName: \"TensorArrayScatterV3\", dlOpName: \"tensorArrayScatter\", category: \"control\", params: [{ tfInputIndex: 0, dlParamName: \"tensorArrayId\", type: \"number\" }, { tfInputIndex: 1, dlParamName: \"indices\", type: \"number[]\" }, { tfInputIndex: 2, dlParamName: \"tensor\", type: \"tensor\" }, { tfInputIndex: 3, dlParamName: \"flowIn\", type: \"number\" }, { tfParamName: \"T\", dlParamName: \"dtype\", type: \"dtype\" }] }, { tfOpName: \"TensorArrayConcatV3\", dlOpName: \"tensorArrayConcat\", category: \"control\", params: [{ tfInputIndex: 0, dlParamName: \"tensorArrayId\", type: \"number\" }, { tfInputIndex: 1, dlParamName: \"flowIn\", type: \"number\" }, { tfParamName: \"dtype\", dlParamName: \"dtype\", type: \"dtype\" }, { tfParamName: \"element_shape_except0\", dlParamName: \"elementShapeExcept0\", type: \"shape\", notSupported: !0 }] }, { tfOpName: \"TensorArraySplitV3\", dlOpName: \"tensorArraySplit\", category: \"control\", params: [{ tfInputIndex: 0, dlParamName: \"tensorArrayId\", type: \"number\" }, { tfInputIndex: 1, dlParamName: \"tensor\", type: \"tensor\" }, { tfInputIndex: 2, dlParamName: \"lengths\", type: \"number[]\" }, { tfInputIndex: 3, dlParamName: \"flowIn\", type: \"number\" }, { tfParamName: \"T\", dlParamName: \"dtype\", type: \"dtype\" }] }, { tfOpName: \"TensorArraySizeV3\", dlOpName: \"tensorArraySize\", category: \"control\", params: [{ tfInputIndex: 0, dlParamName: \"tensorArrayId\", type: \"number\" }, { tfInputIndex: 1, dlParamName: \"flowIn\", type: \"number\" }] }, { tfOpName: \"TensorArrayCloseV3\", dlOpName: \"tensorArrayClose\", category: \"control\", params: [{ tfInputIndex: 0, dlParamName: \"tensorArrayId\", type: \"number\" }] }],\n    control = Object.freeze({ json: json$2 }),\n    json$3 = [{ tfOpName: \"AvgPool\", dlOpName: \"avgPool\", category: \"convolution\", params: [{ tfInputIndex: 0, dlParamName: \"x\", type: \"tensor\" }, { tfParamName: \"strides\", dlParamName: \"strides\", type: \"number[]\" }, { tfParamName: \"padding\", dlParamName: \"pad\", type: \"string\" }, { tfParamName: \"data_format\", dlParamName: \"dataFormat\", type: \"string\", notSupported: !0 }, { tfParamName: \"ksize\", dlParamName: \"kernelSize\", type: \"number[]\" }, { tfParamName: \"T\", dlParamName: \"dtype\", type: \"dtype\", notSupported: !0 }] }, { tfOpName: \"MaxPool\", dlOpName: \"maxPool\", category: \"convolution\", params: [{ tfInputIndex: 0, dlParamName: \"x\", type: \"tensor\" }, { tfParamName: \"strides\", dlParamName: \"strides\", type: \"number[]\" }, { tfParamName: \"padding\", dlParamName: \"pad\", type: \"string\" }, { tfParamName: \"data_format\", dlParamName: \"dataFormat\", type: \"string\", notSupported: !0 }, { tfParamName: \"ksize\", dlParamName: \"kernelSize\", type: \"number[]\" }, { tfParamName: \"T\", dlParamName: \"dtype\", type: \"dtype\", notSupported: !0 }] }, { tfOpName: \"Conv1D\", dlOpName: \"conv1d\", category: \"convolution\", params: [{ tfInputIndex: 0, dlParamName: \"x\", type: \"tensor\" }, { tfInputIndex: 1, dlParamName: \"filter\", type: \"tensor\" }, { tfParamName: \"stride\", dlParamName: \"stride\", type: \"number\" }, { tfParamName: \"padding\", dlParamName: \"pad\", type: \"string\" }, { tfParamName: \"data_format\", dlParamName: \"dataFormat\", type: \"string\", defaultValue: \"NWC\" }, { tfParamName: \"T\", dlParamName: \"dtype\", type: \"dtype\", notSupported: !0 }, { tfParamName: \"dilation\", dlParamName: \"dilation\", type: \"number\", defaultValue: 1 }] }, { tfOpName: \"Conv2D\", dlOpName: \"conv2d\", category: \"convolution\", params: [{ tfInputIndex: 0, dlParamName: \"x\", type: \"tensor\" }, { tfInputIndex: 1, dlParamName: \"filter\", type: \"tensor\" }, { tfParamName: \"T\", dlParamName: \"dtype\", type: \"dtype\", notSupported: !0 }, { tfParamName: \"strides\", dlParamName: \"strides\", type: \"number[]\" }, { tfParamName: \"padding\", dlParamName: \"pad\", type: \"string\" }, { tfParamName: \"useCudnnOnGpu\", dlParamName: \"useCudnnOnGpu\", type: \"bool\" }, { tfParamName: \"data_format\", dlParamName: \"dataFormat\", type: \"string\", defaultValue: \"NHWC\" }, { tfParamName: \"dilations\", dlParamName: \"dilations\", type: \"number[]\" }] }, { tfOpName: \"Conv2DBackpropInput\", dlOpName: \"conv2dTranspose\", category: \"convolution\", params: [{ tfInputIndex: 2, dlParamName: \"x\", type: \"tensor\" }, { tfInputIndex: 1, dlParamName: \"filter\", type: \"tensor\" }, { tfInputIndex: 0, dlParamName: \"outputShape\", type: \"number[]\" }, { tfParamName: \"strides\", dlParamName: \"strides\", type: \"number[]\" }, { tfParamName: \"padding\", dlParamName: \"pad\", type: \"string\" }, { tfParamName: \"data_format\", dlParamName: \"dataFormat\", type: \"string\", notSupported: !0 }] }, { tfOpName: \"DepthwiseConv2d\", dlOpName: \"depthwiseConv2d\", category: \"convolution\", params: [{ tfInputIndex: 0, dlParamName: \"input\", type: \"tensor\" }, { tfInputIndex: 1, dlParamName: \"filter\", type: \"tensor\" }, { tfParamName: \"strides\", dlParamName: \"strides\", type: \"number[]\" }, { tfParamName: \"padding\", dlParamName: \"pad\", type: \"string\" }, { tfParamName: \"data_format\", dlParamName: \"dataFormat\", type: \"string\", defaultValue: \"NHWC\" }, { tfParamName: \"dilations\", dlParamName: \"dilations\", type: \"number[]\" }] }, { tfOpName: \"DepthwiseConv2dNative\", dlOpName: \"depthwiseConv2d\", category: \"convolution\", params: [{ tfInputIndex: 0, dlParamName: \"input\", type: \"tensor\" }, { tfInputIndex: 1, dlParamName: \"filter\", type: \"tensor\" }, { tfParamName: \"strides\", dlParamName: \"strides\", type: \"number[]\" }, { tfParamName: \"padding\", dlParamName: \"pad\", type: \"string\" }, { tfParamName: \"data_format\", dlParamName: \"dataFormat\", type: \"string\", defaultValue: \"NHWC\" }, { tfParamName: \"dilations\", dlParamName: \"dilations\", type: \"number[]\" }] }],\n    convolution = Object.freeze({ json: json$3 }),\n    json$4 = [{ tfOpName: \"Fill\", dlOpName: \"fill\", category: \"creation\", params: [{ tfInputIndex: 0, dlParamName: \"shape\", type: \"number[]\" }, { tfInputIndex: 1, dlParamName: \"value\", type: \"number\" }, { tfParamName: \"T\", dlParamName: \"dtype\", type: \"dtype\" }] }, { tfOpName: \"LinSpace\", dlOpName: \"linspace\", category: \"creation\", params: [{ tfInputIndex: 0, dlParamName: \"start\", type: \"number\" }, { tfInputIndex: 1, dlParamName: \"stop\", type: \"number\" }, { tfInputIndex: 2, dlParamName: \"num\", type: \"number\" }, { tfParamName: \"T\", dlParamName: \"dtype\", type: \"dtype\", notSupported: !0 }] }, { tfOpName: \"OneHot\", dlOpName: \"oneHot\", category: \"creation\", params: [{ tfInputIndex: 0, dlParamName: \"indices\", type: \"tensor\" }, { tfInputIndex: 1, dlParamName: \"depth\", type: \"number\" }, { tfInputIndex: 2, dlParamName: \"onValue\", type: \"number\", defaultValue: 1 }, { tfInputIndex: 3, dlParamName: \"offValue\", type: \"number\", defaultValue: 0 }, { tfParamName: \"axis\", dlParamName: \"axis\", type: \"number\", notSupported: !0 }, { tfParamName: \"T\", dlParamName: \"dtype\", type: \"dtype\", notSupported: !0 }] }, { tfOpName: \"Ones\", dlOpName: \"ones\", category: \"creation\", params: [{ tfInputIndex: 0, dlParamName: \"shape\", type: \"number[]\" }, { tfParamName: \"T\", dlParamName: \"dtype\", type: \"dtype\" }] }, { tfOpName: \"OnesLike\", dlOpName: \"onesLike\", category: \"creation\", params: [{ tfInputIndex: 0, dlParamName: \"x\", type: \"tensor\" }, { tfParamName: \"dtype\", dlParamName: \"dtype\", type: \"dtype\" }] }, { tfOpName: \"RandomUniform\", dlOpName: \"randomUniform\", category: \"creation\", params: [{ tfInputIndex: 0, dlParamName: \"shape\", type: \"number[]\" }, { tfParamName: \"minval\", dlParamName: \"minval\", type: \"number\", defaultValue: 0 }, { tfParamName: \"maxval\", dlParamName: \"maxval\", type: \"number\", defaultValue: 1 }, { tfParamName: \"dtype\", dlParamName: \"dtype\", type: \"dtype\" }, { tfParamName: \"seed\", dlParamName: \"seed\", type: \"number\", defaultValue: 0 }, { tfParamName: \"seed2\", dlParamName: \"seed2\", type: \"number\", defaultValue: 0, notSupported: !0 }, { tfParamName: \"T\", dlParamName: \"T\", type: \"number\", notSupported: !0 }] }, { tfOpName: \"Range\", dlOpName: \"range\", category: \"creation\", params: [{ tfInputIndex: 0, dlParamName: \"start\", type: \"number\" }, { tfInputIndex: 1, dlParamName: \"stop\", type: \"number\" }, { tfInputIndex: 2, dlParamName: \"step\", type: \"number\", defaultValue: 0 }, { tfParamName: \"Tidx\", dlParamName: \"dtype\", type: \"dtype\" }] }, { tfOpName: \"truncatedNormal\", dlOpName: \"truncatedNormal\", category: \"creation\", params: [{ tfInputIndex: 0, dlParamName: \"shape\", type: \"number[]\" }, { tfParamName: \"means\", dlParamName: \"mean\", type: \"number\", defaultValue: 0 }, { tfParamName: \"stddev\", dlParamName: \"stdDev\", type: \"number\", defaultValue: 1 }, { tfParamName: \"seed\", dlParamName: \"seed\", type: \"number\" }, { tfParamName: \"seed2\", dlParamName: \"seed2\", type: \"number\", defaultValue: 0, notSupported: !0 }, { tfParamName: \"dtype\", dlParamName: \"dtype\", type: \"dtype\" }, { tfParamName: \"T\", dlParamName: \"T\", type: \"number\", notSupported: !0 }] }, { tfOpName: \"Zeros\", dlOpName: \"zeros\", category: \"creation\", params: [{ tfInputIndex: 0, dlParamName: \"shape\", type: \"number[]\" }, { tfParamName: \"T\", dlParamName: \"dtype\", type: \"dtype\" }] }, { tfOpName: \"ZerosLike\", dlOpName: \"zerosLike\", category: \"creation\", params: [{ tfInputIndex: 0, dlParamName: \"x\", type: \"tensor\" }, { tfParamName: \"T\", dlParamName: \"dtype\", type: \"dtype\" }] }],\n    creation = Object.freeze({ json: json$4 }),\n    json$5 = [{ tfOpName: \"NonMaxSuppressionV2\", dlOpName: \"nonMaxSuppression\", category: \"dynamic\", params: [{ tfInputIndex: 0, dlParamName: \"boxes\", type: \"tensor\" }, { tfInputIndex: 1, dlParamName: \"scores\", type: \"tensor\" }, { tfInputIndex: 2, dlParamName: \"maxOutputSize\", type: \"number\" }, { tfInputIndex: 3, dlParamName: \"iouThreshold\", type: \"number\" }] }, { tfOpName: \"NonMaxSuppressionV3\", dlOpName: \"nonMaxSuppression\", category: \"dynamic\", params: [{ tfInputIndex: 0, dlParamName: \"boxes\", type: \"tensor\" }, { tfInputIndex: 1, dlParamName: \"scores\", type: \"tensor\" }, { tfInputIndex: 2, dlParamName: \"maxOutputSize\", type: \"number\" }, { tfInputIndex: 3, dlParamName: \"iouThreshold\", type: \"number\" }, { tfInputIndex: 4, dlParamName: \"scoreThreshold\", type: \"number\" }] }, { tfOpName: \"Where\", dlOpName: \"whereAsync\", category: \"dynamic\", params: [{ tfInputIndex: 0, dlParamName: \"condition\", type: \"tensor\" }, { tfParamName: \"T\", dlParamName: \"dtype\", type: \"dtype\", notSupported: !0 }] }],\n    dynamic = Object.freeze({ json: json$5 }),\n    json$6 = [{ tfOpName: \"TopKV2\", dlOpName: \"topK\", category: \"evaluation\", params: [{ tfInputIndex: 0, dlParamName: \"x\", type: \"tensor\" }, { tfInputIndex: 1, dlParamName: \"k\", type: \"number\" }, { tfParamName: \"sorted\", dlParamName: \"sorted\", type: \"bool\" }] }],\n    evaluation = Object.freeze({ json: json$6 }),\n    json$7 = [{ tfOpName: \"PlaceholderWithDefault\", dlOpName: \"placeholder\", category: \"graph\", params: [{ tfInputIndex: 0, dlParamName: \"default\", type: \"tensor\" }, { tfParamName: \"shape\", dlParamName: \"shape\", type: \"shape\" }, { tfParamName: \"dtype\", dlParamName: \"dtype\", type: \"dtype\" }] }, { tfOpName: \"Placeholder\", dlOpName: \"placeholder\", category: \"graph\", params: [{ tfParamName: \"shape\", dlParamName: \"shape\", type: \"shape\" }, { tfParamName: \"dtype\", dlParamName: \"dtype\", type: \"dtype\" }] }, { tfOpName: \"Const\", dlOpName: \"const\", category: \"graph\" }, { tfOpName: \"Identity\", dlOpName: \"identity\", category: \"graph\", params: [{ tfInputIndex: 0, dlParamName: \"x\", type: \"tensor\" }] }, { tfOpName: \"Snapshot\", dlOpName: \"snapshot\", category: \"graph\", params: [{ tfInputIndex: 0, dlParamName: \"x\", type: \"tensor\" }] }, { tfOpName: \"Rank\", dlOpName: \"rank\", category: \"graph\", params: [{ tfInputIndex: 0, dlParamName: \"x\", type: \"tensor\" }] }, { tfOpName: \"Size\", dlOpName: \"size\", category: \"graph\", params: [{ tfInputIndex: 0, dlParamName: \"x\", type: \"tensor\" }] }, { tfOpName: \"Shape\", dlOpName: \"shape\", category: \"graph\", params: [{ tfInputIndex: 0, dlParamName: \"x\", type: \"tensor\" }] }, { tfOpName: \"ShapeN\", dlOpName: \"shapeN\", category: \"graph\", params: [{ tfInputIndex: 0, tfInputParamLength: 0, dlParamName: \"x\", type: \"tensors\" }] }, { tfOpName: \"Print\", dlOpName: \"print\", category: \"graph\", params: [{ tfInputIndex: 0, dlParamName: \"x\", type: \"tensor\" }, { tfInputIndex: 1, tfInputParamLength: 1, dlParamName: \"data\", type: \"tensors\" }, { tfParamName: \"message\", dlParamName: \"message\", type: \"string\" }, { tfParamName: \"first_n\", dlParamName: \"firstN\", type: \"number\", notSupprted: !0 }, { tfParamName: \"summarize\", dlParamName: \"summarize\", type: \"number\", defaultValue: 3 }] }, { tfOpName: \"NoOp\", dlOpName: \"noop\", category: \"graph\", params: [] }, { tfOpName: \"StopGradient\", dlOpName: \"stopGradient\", category: \"graph\", params: [{ tfInputIndex: 0, dlParamName: \"x\", type: \"tensor\" }] }, { tfOpName: \"FakeQuantWithMinMaxVars\", dlOpName: \"fakeQuantWithMinMaxVars\", category: \"graph\", params: [{ tfInputIndex: 0, dlParamName: \"x\", type: \"tensor\" }, { tfParamName: \"min\", dlParamName: \"min\", type: \"number\" }, { tfParamName: \"max\", dlParamName: \"max\", type: \"number\" }] }],\n    graph = Object.freeze({ json: json$7 }),\n    json$8 = [{ tfOpName: \"ResizeBilinear\", dlOpName: \"resizeBilinear\", category: \"image\", params: [{ tfInputIndex: 0, dlParamName: \"images\", type: \"tensor\" }, { tfInputIndex: 1, dlParamName: \"size\", type: \"number[]\" }, { tfParamName: \"align_corners\", dlParamName: \"alignCorners\", type: \"bool\" }, { tfParamName: \"T\", dlParamName: \"dtype\", type: \"dtype\", notSupported: !0 }] }, { tfOpName: \"ResizeNearestNeighbor\", dlOpName: \"resizeNearestNeighbor\", category: \"image\", params: [{ tfInputIndex: 0, dlParamName: \"images\", type: \"tensor\" }, { tfInputIndex: 1, dlParamName: \"size\", type: \"number[]\" }, { tfParamName: \"align_corners\", dlParamName: \"alignCorners\", type: \"bool\" }, { tfParamName: \"T\", dlParamName: \"dtype\", type: \"dtype\", notSupported: !0 }] }],\n    image$1 = Object.freeze({ json: json$8 }),\n    json$9 = [{ tfOpName: \"Equal\", dlOpName: \"equal\", category: \"logical\", params: [{ tfInputIndex: 0, dlParamName: \"a\", type: \"tensor\" }, { tfInputIndex: 1, dlParamName: \"b\", type: \"tensor\" }, { tfParamName: \"T\", dlParamName: \"dtype\", type: \"dtype\", notSupported: !0 }] }, { tfOpName: \"NotEqual\", dlOpName: \"notEqual\", category: \"logical\", params: [{ tfInputIndex: 0, dlParamName: \"a\", type: \"tensor\" }, { tfInputIndex: 1, dlParamName: \"b\", type: \"tensor\" }, { tfParamName: \"T\", dlParamName: \"dtype\", type: \"dtype\", notSupported: !0 }] }, { tfOpName: \"Greater\", dlOpName: \"greater\", category: \"logical\", params: [{ tfInputIndex: 0, dlParamName: \"a\", type: \"tensor\" }, { tfInputIndex: 1, dlParamName: \"b\", type: \"tensor\" }, { tfParamName: \"T\", dlParamName: \"dtype\", type: \"dtype\", notSupported: !0 }] }, { tfOpName: \"GreaterEqual\", dlOpName: \"greaterEqual\", category: \"logical\", params: [{ tfInputIndex: 0, dlParamName: \"a\", type: \"tensor\" }, { tfInputIndex: 1, dlParamName: \"b\", type: \"tensor\" }, { tfParamName: \"T\", dlParamName: \"dtype\", type: \"dtype\", notSupported: !0 }] }, { tfOpName: \"Less\", dlOpName: \"less\", category: \"logical\", params: [{ tfInputIndex: 0, dlParamName: \"a\", type: \"tensor\" }, { tfInputIndex: 1, dlParamName: \"b\", type: \"tensor\" }, { tfParamName: \"T\", dlParamName: \"dtype\", type: \"dtype\", notSupported: !0 }] }, { tfOpName: \"LessEqual\", dlOpName: \"lessEqual\", category: \"logical\", params: [{ tfInputIndex: 0, dlParamName: \"a\", type: \"tensor\" }, { tfInputIndex: 1, dlParamName: \"b\", type: \"tensor\" }, { tfParamName: \"T\", dlParamName: \"dtype\", type: \"dtype\", notSupported: !0 }] }, { tfOpName: \"LogicalAnd\", dlOpName: \"logicalAnd\", category: \"logical\", params: [{ tfInputIndex: 0, dlParamName: \"a\", type: \"tensor\" }, { tfInputIndex: 1, dlParamName: \"b\", type: \"tensor\" }, { tfParamName: \"T\", dlParamName: \"dtype\", type: \"dtype\", notSupported: !0 }] }, { tfOpName: \"LogicalNot\", dlOpName: \"logicalNot\", category: \"logical\", params: [{ tfInputIndex: 0, dlParamName: \"a\", type: \"tensor\" }, { tfParamName: \"T\", dlParamName: \"dtype\", type: \"dtype\", notSupported: !0 }] }, { tfOpName: \"LogicalOr\", dlOpName: \"logicalOr\", category: \"logical\", params: [{ tfInputIndex: 0, dlParamName: \"a\", type: \"tensor\" }, { tfInputIndex: 1, dlParamName: \"b\", type: \"tensor\" }, { tfParamName: \"T\", dlParamName: \"dtype\", type: \"dtype\", notSupported: !0 }] }, { tfOpName: \"Select\", dlOpName: \"where\", category: \"logical\", params: [{ tfInputIndex: 0, dlParamName: \"condition\", type: \"tensor\" }, { tfInputIndex: 1, dlParamName: \"a\", type: \"tensor\" }, { tfInputIndex: 2, dlParamName: \"b\", type: \"tensor\" }, { tfParamName: \"T\", dlParamName: \"dtype\", type: \"dtype\", notSupported: !0 }] }],\n    logical = Object.freeze({ json: json$9 }),\n    json$10 = [{ tfOpName: \"MatMul\", dlOpName: \"matMul\", category: \"matrices\", params: [{ tfInputIndex: 0, dlParamName: \"a\", type: \"tensor\" }, { tfInputIndex: 1, dlParamName: \"b\", type: \"tensor\" }, { tfParamName: \"transpose_a\", dlParamName: \"transposeA\", type: \"bool\", defaultValue: !1 }, { tfParamName: \"transpose_b\", dlParamName: \"transposeB\", type: \"bool\", defaultValue: !1 }, { tfParamName: \"T\", dlParamName: \"dtype\", type: \"dtype\", notSupported: !0 }] }, { tfOpName: \"Transpose\", dlOpName: \"transpose\", category: \"matrices\", params: [{ tfInputIndex: 0, dlParamName: \"x\", type: \"tensor\" }, { tfInputIndex: 1, dlParamName: \"perm\", type: \"number[]\" }, { tfParamName: \"T\", dlParamName: \"dtype\", type: \"dtype\", notSupported: !0 }] }],\n    matrices = Object.freeze({ json: json$10 }),\n    json$11 = [{ tfOpName: \"FusedBatchNorm\", dlOpName: \"batchNormalization\", category: \"normalization\", params: [{ tfInputIndex: 0, dlParamName: \"x\", type: \"tensor\" }, { tfInputIndex: 1, dlParamName: \"scale\", type: \"tensor\" }, { tfInputIndex: 2, dlParamName: \"offset\", type: \"tensor\" }, { tfInputIndex: 3, dlParamName: \"mean\", type: \"tensor\" }, { tfInputIndex: 4, dlParamName: \"variance\", type: \"tensor\" }, { tfParamName: \"epsilon\", dlParamName: \"epsilon\", type: \"number\", defaultValue: .001 }, { tfParamName: \"data_format\", dlParamName: \"dataFormat\", type: \"string\", notSupported: !0 }] }, { tfOpName: \"FusedBatchNormV2\", dlOpName: \"batchNormalization\", category: \"normalization\", params: [{ tfInputIndex: 0, dlParamName: \"x\", type: \"tensor\" }, { tfInputIndex: 1, dlParamName: \"scale\", type: \"tensor\" }, { tfInputIndex: 2, dlParamName: \"offset\", type: \"tensor\" }, { tfInputIndex: 3, dlParamName: \"mean\", type: \"tensor\" }, { tfInputIndex: 4, dlParamName: \"variance\", type: \"tensor\" }, { tfParamName: \"epsilon\", dlParamName: \"epsilon\", type: \"number\", defaultValue: .001 }, { tfParamName: \"data_format\", dlParamName: \"dataFormat\", type: \"string\", notSupported: !0 }] }, { tfOpName: \"LRN\", dlOpName: \"localResponseNormalization\", category: \"normalization\", params: [{ tfInputIndex: 0, dlParamName: \"x\", type: \"tensor\" }, { tfParamName: \"depth_radius\", dlParamName: \"radius\", type: \"number\", defaultValue: 5 }, { tfParamName: \"bias\", dlParamName: \"bias\", type: \"number\", defaultValue: 1 }, { tfParamName: \"alpha\", dlParamName: \"alpha\", type: \"number\", defaultValue: 1 }, { tfParamName: \"beta\", dlParamName: \"beta\", type: \"number\", defaultValue: .5 }] }, { tfOpName: \"Softmax\", dlOpName: \"softmax\", category: \"normalization\", params: [{ tfInputIndex: 0, dlParamName: \"x\", type: \"tensor\" }] }],\n    normalization = Object.freeze({ json: json$11 }),\n    json$12 = [{ tfOpName: \"Max\", dlOpName: \"max\", category: \"reduction\", params: [{ tfInputIndex: 0, dlParamName: \"x\", type: \"tensor\" }, { tfInputIndex: 1, dlParamName: \"axis\", type: \"number[]\" }, { tfParamName: \"keep_dims\", dlParamName: \"keepDims\", type: \"bool\" }] }, { tfOpName: \"Mean\", dlOpName: \"mean\", category: \"reduction\", params: [{ tfInputIndex: 0, dlParamName: \"x\", type: \"tensor\" }, { tfInputIndex: 1, dlParamName: \"axis\", type: \"number[]\" }, { tfParamName: \"keep_dims\", dlParamName: \"keepDims\", type: \"bool\" }] }, { tfOpName: \"Min\", dlOpName: \"min\", category: \"reduction\", params: [{ tfInputIndex: 0, dlParamName: \"x\", type: \"tensor\" }, { tfInputIndex: 1, dlParamName: \"axis\", type: \"number[]\" }, { tfParamName: \"keep_dims\", dlParamName: \"keepDims\", type: \"bool\" }] }, { tfOpName: \"Sum\", dlOpName: \"sum\", category: \"reduction\", params: [{ tfInputIndex: 0, dlParamName: \"x\", type: \"tensor\" }, { tfInputIndex: 1, dlParamName: \"axis\", type: \"number[]\" }, { tfParamName: \"keep_dims\", dlParamName: \"keepDims\", type: \"bool\" }] }, { tfOpName: \"All\", dlOpName: \"all\", category: \"reduction\", params: [{ tfInputIndex: 0, dlParamName: \"x\", type: \"tensor\" }, { tfInputIndex: 1, dlParamName: \"axis\", type: \"number[]\" }, { tfParamName: \"keep_dims\", dlParamName: \"keepDims\", type: \"bool\" }] }, { tfOpName: \"Any\", dlOpName: \"any\", category: \"reduction\", params: [{ tfInputIndex: 0, dlParamName: \"x\", type: \"tensor\" }, { tfInputIndex: 1, dlParamName: \"axis\", type: \"number[]\" }, { tfParamName: \"keep_dims\", dlParamName: \"keepDims\", type: \"bool\" }] }, { tfOpName: \"ArgMax\", dlOpName: \"argMax\", category: \"reduction\", params: [{ tfInputIndex: 0, dlParamName: \"x\", type: \"tensor\" }, { tfInputIndex: 1, dlParamName: \"axis\", type: \"number\" }] }, { tfOpName: \"ArgMin\", dlOpName: \"argMin\", category: \"reduction\", params: [{ tfInputIndex: 0, dlParamName: \"x\", type: \"tensor\" }, { tfInputIndex: 1, dlParamName: \"axis\", type: \"number\" }] }],\n    reduction = Object.freeze({ json: json$12 }),\n    json$13 = [{ tfOpName: \"ConcatV2\", dlOpName: \"concat\", category: \"slice_join\", params: [{ tfInputIndex: 0, tfInputParamLength: 1, dlParamName: \"tensors\", type: \"tensors\" }, { tfInputIndex: -1, dlParamName: \"axis\", type: \"number\" }] }, { tfOpName: \"Concat\", dlOpName: \"concat\", category: \"slice_join\", params: [{ tfInputIndex: 1, tfInputParamLength: 1, dlParamName: \"tensors\", type: \"tensors\" }, { tfInputIndex: 0, dlParamName: \"axis\", type: \"number\" }] }, { tfOpName: \"GatherV2\", dlOpName: \"gather\", category: \"slice_join\", params: [{ tfInputIndex: 0, dlParamName: \"x\", type: \"tensor\" }, { tfInputIndex: 1, dlParamName: \"indices\", type: \"tensor\" }, { tfParamName: \"axis\", dlParamName: \"axis\", type: \"number\", defaultValue: 0 }] }, { tfOpName: \"Gather\", dlOpName: \"gather\", category: \"slice_join\", params: [{ tfInputIndex: 0, dlParamName: \"x\", type: \"tensor\" }, { tfInputIndex: 1, dlParamName: \"indices\", type: \"tensor\" }, { tfParamName: \"axis\", dlParamName: \"axis\", type: \"number\", defaultValue: 0 }, { tfParamName: \"validate_indices\", dlParamName: \"validateIndices\", type: \"bool\", notSupported: !0 }] }, { tfOpName: \"Reverse\", dlOpName: \"reverse\", category: \"slice_join\", params: [{ tfInputIndex: 0, dlParamName: \"x\", type: \"tensor\" }, { tfInputIndex: 1, dlParamName: \"axis\", type: \"number\" }] }, { tfOpName: \"ReverseV2\", dlOpName: \"reverse\", category: \"slice_join\", params: [{ tfInputIndex: 0, dlParamName: \"x\", type: \"tensor\" }, { tfInputIndex: 1, dlParamName: \"axis\", type: \"number\" }] }, { tfOpName: \"Slice\", dlOpName: \"slice\", category: \"slice_join\", params: [{ tfInputIndex: 0, dlParamName: \"x\", type: \"tensor\" }, { tfInputIndex: 1, dlParamName: \"begin\", type: \"number[]\" }, { tfInputIndex: 2, dlParamName: \"size\", type: \"number[]\" }] }, { tfOpName: \"StridedSlice\", dlOpName: \"stridedSlice\", category: \"slice_join\", params: [{ tfInputIndex: 0, dlParamName: \"x\", type: \"tensor\" }, { tfInputIndex: 1, dlParamName: \"begin\", type: \"number[]\" }, { tfInputIndex: 2, dlParamName: \"end\", type: \"number[]\" }, { tfInputIndex: 3, dlParamName: \"strides\", type: \"number[]\" }, { tfParamName: \"begin_mask\", dlParamName: \"beginMask\", type: \"number\", defaultValue: 0 }, { tfParamName: \"end_mask\", dlParamName: \"endMask\", type: \"number\", defaultValue: 0 }, { tfParamName: \"new_axis_mask\", dlParamName: \"newAxisMask\", type: \"number\", defaultValue: 0 }, { tfParamName: \"ellipsis_mask\", dlParamName: \"ellipsisMask\", type: \"number\", defaultValue: 0 }, { tfParamName: \"shrink_axis_mask\", dlParamName: \"shrinkAxisMask\", type: \"number\", defaultValue: 0 }] }, { tfOpName: \"Pack\", dlOpName: \"stack\", category: \"slice_join\", params: [{ tfInputIndex: 0, tfInputParamLength: 0, dlParamName: \"tensors\", type: \"tensors\" }, { tfParamName: \"axis\", dlParamName: \"axis\", type: \"number\", defaultValue: 0 }] }, { tfOpName: \"Unpack\", dlOpName: \"unstack\", category: \"slice_join\", params: [{ tfInputIndex: 0, tfInputParamLength: 0, dlParamName: \"tensor\", type: \"tensor\" }, { tfParamName: \"axis\", dlParamName: \"axis\", type: \"number\", defaultValue: 0 }, { tfParamName: \"num\", dlParamName: \"num\", type: \"number\", defaultValue: 0, notSupported: !0 }] }, { tfOpName: \"Tile\", dlOpName: \"tile\", category: \"slice_join\", params: [{ tfInputIndex: 0, dlParamName: \"x\", type: \"tensor\" }, { tfInputIndex: 1, dlParamName: \"reps\", type: \"number[]\" }] }, { tfOpName: \"Split\", dlOpName: \"split\", category: \"slice_join\", params: [{ tfInputIndex: 0, dlParamName: \"axis\", type: \"number\", defaultValue: 0 }, { tfInputIndex: 1, dlParamName: \"x\", type: \"tensor\" }, { tfParamName: \"num_split\", dlParamName: \"numOrSizeSplits\", type: \"number\", defaultValue: 1 }] }],\n    sliceJoin = Object.freeze({ json: json$13 }),\n    json$14 = [{ tfOpName: \"Cast\", dlOpName: \"cast\", category: \"transformation\", params: [{ tfInputIndex: 0, dlParamName: \"x\", type: \"tensor\" }, { tfParamName: \"SrcT\", dlParamName: \"sdtype\", type: \"dtype\", notSupported: !0 }, { tfParamName: \"DstT\", dlParamName: \"dtype\", type: \"dtype\" }] }, { tfOpName: \"ExpandDims\", dlOpName: \"expandDims\", category: \"transformation\", params: [{ tfInputIndex: 0, dlParamName: \"x\", type: \"tensor\" }, { tfInputIndex: 1, tfParamNameDeprecated: \"dim\", dlParamName: \"axis\", type: \"number\" }] }, { tfOpName: \"Pad\", dlOpName: \"pad\", category: \"transformation\", params: [{ tfInputIndex: 0, dlParamName: \"x\", type: \"tensor\" }, { tfInputIndex: 1, dlParamName: \"padding\", type: \"number[]\" }, { tfParamName: \"constant_value\", dlParamName: \"constantValue\", type: \"number\", defaultValue: 0 }] }, { tfOpName: \"PadV2\", dlOpName: \"pad\", category: \"transformation\", params: [{ tfInputIndex: 0, dlParamName: \"x\", type: \"tensor\" }, { tfInputIndex: 1, dlParamName: \"padding\", type: \"number[]\" }, { tfInputIndex: 2, dlParamName: \"constantValue\", type: \"number\", defaultValue: 0 }] }, { tfOpName: \"Reshape\", dlOpName: \"reshape\", category: \"transformation\", params: [{ tfInputIndex: 0, dlParamName: \"x\", type: \"tensor\" }, { tfInputIndex: 1, dlParamName: \"shape\", type: \"number[]\" }] }, { tfOpName: \"Squeeze\", dlOpName: \"squeeze\", category: \"transformation\", params: [{ tfInputIndex: 0, dlParamName: \"x\", type: \"tensor\" }, { tfParamName: \"axis\", tfParamNameDeprecated: \"squeeze_dims\", dlParamName: \"axis\", type: \"number[]\" }] }, { tfOpName: \"SpaceToBatchND\", dlOpName: \"spaceToBatchND\", category: \"transformation\", params: [{ tfInputIndex: 0, dlParamName: \"x\", type: \"tensor\" }, { tfInputIndex: 1, dlParamName: \"blockShape\", type: \"number[]\" }, { tfInputIndex: 2, dlParamName: \"paddings\", type: \"number[]\" }] }, { tfOpName: \"BatchToSpaceND\", dlOpName: \"batchToSpaceND\", category: \"transformation\", params: [{ tfInputIndex: 0, dlParamName: \"x\", type: \"tensor\" }, { tfInputIndex: 1, dlParamName: \"blockShape\", type: \"number[]\" }, { tfInputIndex: 2, dlParamName: \"crops\", type: \"number[]\" }] }],\n    transformation = Object.freeze({ json: json$14 }),\n    CONTROL_FLOW_OPS = [\"Switch\", \"Merge\", \"Enter\", \"Exit\", \"NextIteration\"],\n    DYNAMIC_SHAPE_OPS = [\"NonMaxSuppressionV2\", \"NonMaxSuppressionV3\", \"Where\"],\n    OperationMapper = function () {\n  function e() {\n    var e = [arithmetic, basicMath, control, convolution, creation, dynamic, evaluation, logical, image$1, graph, matrices, normalization, reduction, sliceJoin, transformation],\n        t = [].concat.apply([], e.map(function (e) {\n      return e.json;\n    }));this.opMappers = t.reduce(function (e, t) {\n      return e[t.tfOpName] = t, e;\n    }, {});\n  }return Object.defineProperty(e, \"Instance\", { get: function () {\n      return this._instance || (this._instance = new this());\n    }, enumerable: !0, configurable: !0 }), e.prototype.isControlFlow = function (e) {\n    return CONTROL_FLOW_OPS.some(function (t) {\n      return t === e.op;\n    });\n  }, e.prototype.isDynamicShape = function (e) {\n    return DYNAMIC_SHAPE_OPS.some(function (t) {\n      return t === e.op;\n    });\n  }, e.prototype.transformGraph = function (e) {\n    var t = this,\n        a = !1,\n        r = !1,\n        n = [],\n        o = [],\n        s = e.node.reduce(function (e, s) {\n      return e[s.name] = t.mapNode(s), t.isControlFlow(s) && (a = !0), t.isDynamicShape(s) && (r = !0), \"Placeholder\" === s.op && n.push(e[s.name]), \"Const\" === s.op && o.push(e[s.name]), e;\n    }, {}),\n        i = [],\n        p = [];return Object.keys(s).forEach(function (e) {\n      var t = s[e];t.inputNames.forEach(function (e) {\n        var a = getNodeNameAndIndex(e)[0];t.inputs.push(s[a]), s[a].children.push(t);\n      }), 0 === t.inputs.length && i.push(t);\n    }), Object.keys(s).forEach(function (e) {\n      var t = s[e];0 === t.children.length && p.push(t);\n    }), { nodes: s, inputs: i, outputs: p, weights: o, placeholders: n, withControlFlow: a, withDynamicShape: r };\n  }, e.prototype.mapNode = function (e) {\n    var t = this,\n        a = this.opMappers[e.op];if (void 0 === a) throw new Error(\"Tensorflow Op is not supported: \" + e.op);var r = { name: e.name, op: a.dlOpName, category: a.category, inputNames: (e.input || []).map(function (e) {\n        return e.startsWith(\"^\") ? e.substr(1) : e;\n      }), inputs: [], children: [], params: {} };return a.params && (r.params = a.params.reduce(function (a, r) {\n      var n = r.tfInputIndex,\n          o = r.tfInputParamLength,\n          s = r.type,\n          i = void 0;if (void 0 === n) switch (r.type) {case \"string\":\n          void 0 === (i = t.getStringParam(e.attr, r.tfParamName, r.defaultValue)) && r.tfParamNameDeprecated && (i = t.getStringParam(e.attr, r.tfParamNameDeprecated, r.defaultValue));break;case \"number\":\n          void 0 === (i = t.getNumberParam(e.attr, r.tfParamName, r.defaultValue)) && r.tfParamNameDeprecated && (i = t.getNumberParam(e.attr, r.tfParamNameDeprecated, r.defaultValue));break;case \"number[]\":\n          void 0 === (i = t.getNumericArrayParam(e.attr, r.tfParamName, r.defaultValue)) && r.tfParamNameDeprecated && (i = t.getNumericArrayParam(e.attr, r.tfParamNameDeprecated, r.defaultValue));break;case \"bool\":\n          void 0 === (i = t.getBoolParam(e.attr, r.tfParamName, r.defaultValue)) && r.tfParamNameDeprecated && (i = t.getBoolParam(e.attr, r.tfParamNameDeprecated, r.defaultValue));break;case \"shape\":\n          void 0 === (i = t.getTensorShapeParam(e.attr, r.tfParamName, r.defaultValue)) && r.tfParamNameDeprecated && (i = t.getTensorShapeParam(e.attr, r.tfParamNameDeprecated, r.defaultValue));break;case \"dtype\":\n          void 0 === (i = t.getDtypeParam(e.attr, r.tfParamName, r.defaultValue)) && r.tfParamNameDeprecated && (i = t.getDtypeParam(e.attr, r.tfParamNameDeprecated, r.defaultValue));break;case \"tensor\":case \"tensors\":\n          break;default:\n          throw new Error(\"Unsupported param type: \" + r.type + \" for op: \" + e.op);}return a[r.dlParamName] = { value: i, inputIndex: n, type: s, inputParamLength: o }, a;\n    }, {})), r;\n  }, e.prototype.getStringParam = function (e, t, a, r) {\n    void 0 === r && (r = !1);var n = e[t];if (void 0 !== n) {\n      var o = String.fromCharCode.apply(null, n.s);return r ? o : o.toLowerCase();\n    }return a;\n  }, e.prototype.getBoolParam = function (e, t, a) {\n    var r = e[t];return r ? r.b : a;\n  }, e.prototype.getNumberParam = function (e, t, a) {\n    var r = e[t],\n        n = r ? r[r.value] : a;return \"number\" == typeof n ? n : n.toInt();\n  }, e.prototype.getDtypeParam = function (e, t, a) {\n    var r = e[t];if (r && r.type) switch (r.type) {case compiled_api_1.DataType.DT_FLOAT:\n        return \"float32\";case compiled_api_1.DataType.DT_INT32:\n        return \"int32\";case compiled_api_1.DataType.DT_BOOL:\n        return \"bool\";default:\n        return a;}return a;\n  }, e.prototype.getTensorShapeParam = function (e, t, a) {\n    var r = e[t];return r && r.shape ? r.shape.dim.map(function (e) {\n      return \"number\" == typeof e.size ? e.size : e.size.toInt();\n    }) : a;\n  }, e.prototype.getNumericArrayParam = function (e, t, a) {\n    var r = e[t];return r ? (r.list.f && r.list.f.length ? r.list.f : r.list.i).map(function (e) {\n      return \"number\" == typeof e ? e : e.toInt();\n    }) : a;\n  }, e;\n}(),\n    executeOp = function (e, t, a) {\n  switch (e.op) {case \"add\":\n      return [(0, _tfjsCore.add)(getParamValue(\"a\", e, t, a), getParamValue(\"b\", e, t, a))];case \"addN\":\n      return [(0, _tfjsCore.addN)(getParamValue(\"tensors\", e, t, a))];case \"mod\":\n      return [(0, _tfjsCore.mod)(getParamValue(\"a\", e, t, a), getParamValue(\"b\", e, t, a))];case \"mul\":\n      return [(0, _tfjsCore.mul)(getParamValue(\"a\", e, t, a), getParamValue(\"b\", e, t, a))];case \"div\":\n      return [(0, _tfjsCore.div)(getParamValue(\"a\", e, t, a), getParamValue(\"b\", e, t, a))];case \"floorDiv\":\n      return [(0, _tfjsCore.floorDiv)(getParamValue(\"a\", e, t, a), getParamValue(\"b\", e, t, a))];case \"sub\":\n      return [(0, _tfjsCore.sub)(getParamValue(\"a\", e, t, a), getParamValue(\"b\", e, t, a))];case \"minimum\":\n      return [(0, _tfjsCore.minimum)(getParamValue(\"a\", e, t, a), getParamValue(\"b\", e, t, a))];case \"maximum\":\n      return [(0, _tfjsCore.maximum)(getParamValue(\"a\", e, t, a), getParamValue(\"b\", e, t, a))];case \"pow\":\n      return [(0, _tfjsCore.pow)(getParamValue(\"a\", e, t, a), getParamValue(\"b\", e, t, a))];case \"squaredDifference\":\n      return [(0, _tfjsCore.squaredDifference)(getParamValue(\"a\", e, t, a), getParamValue(\"b\", e, t, a))];default:\n      throw TypeError(\"Node type \" + e.op + \" is not implemented\");}\n},\n    executeOp$1 = function (e, t, a) {\n  switch (e.op) {case \"abs\":\n      return [(0, _tfjsCore.abs)(getParamValue(\"x\", e, t, a))];case \"acos\":\n      return [(0, _tfjsCore.acos)(getParamValue(\"x\", e, t, a))];case \"acosh\":\n      return [(0, _tfjsCore.acosh)(getParamValue(\"x\", e, t, a))];case \"asin\":\n      return [(0, _tfjsCore.asin)(getParamValue(\"x\", e, t, a))];case \"asinh\":\n      return [(0, _tfjsCore.asinh)(getParamValue(\"x\", e, t, a))];case \"atan\":\n      return [(0, _tfjsCore.atan)(getParamValue(\"x\", e, t, a))];case \"atanh\":\n      return [(0, _tfjsCore.atanh)(getParamValue(\"x\", e, t, a))];case \"ceil\":\n      return [(0, _tfjsCore.ceil)(getParamValue(\"x\", e, t, a))];case \"cos\":\n      return [(0, _tfjsCore.cos)(getParamValue(\"x\", e, t, a))];case \"cosh\":\n      return [(0, _tfjsCore.cosh)(getParamValue(\"x\", e, t, a))];case \"elu\":\n      return [(0, _tfjsCore.elu)(getParamValue(\"x\", e, t, a))];case \"erf\":\n      return [(0, _tfjsCore.erf)(getParamValue(\"x\", e, t, a))];case \"exp\":\n      return [(0, _tfjsCore.exp)(getParamValue(\"x\", e, t, a))];case \"expm1\":\n      return [(0, _tfjsCore.expm1)(getParamValue(\"x\", e, t, a))];case \"floor\":\n      return [(0, _tfjsCore.floor)(getParamValue(\"x\", e, t, a))];case \"log\":\n      return [(0, _tfjsCore.log)(getParamValue(\"x\", e, t, a))];case \"log1p\":\n      return [(0, _tfjsCore.log1p)(getParamValue(\"x\", e, t, a))];case \"neg\":\n      return [(0, _tfjsCore.neg)(getParamValue(\"x\", e, t, a))];case \"reciprocal\":\n      return [(0, _tfjsCore.reciprocal)(getParamValue(\"x\", e, t, a))];case \"relu\":\n      return [(0, _tfjsCore.relu)(getParamValue(\"x\", e, t, a))];case \"round\":\n      return [(0, _tfjsCore.round)(getParamValue(\"x\", e, t, a))];case \"selu\":\n      return [(0, _tfjsCore.selu)(getParamValue(\"x\", e, t, a))];case \"sigmoid\":\n      return [(0, _tfjsCore.sigmoid)(getParamValue(\"x\", e, t, a))];case \"sin\":\n      return [(0, _tfjsCore.sin)(getParamValue(\"x\", e, t, a))];case \"sign\":\n      return [(0, _tfjsCore.sign)(getParamValue(\"x\", e, t, a))];case \"sinh\":\n      return [(0, _tfjsCore.sinh)(getParamValue(\"x\", e, t, a))];case \"softplus\":\n      return [(0, _tfjsCore.softplus)(getParamValue(\"x\", e, t, a))];case \"sqrt\":\n      return [(0, _tfjsCore.sqrt)(getParamValue(\"x\", e, t, a))];case \"square\":\n      return [(0, _tfjsCore.square)(getParamValue(\"x\", e, t, a))];case \"tanh\":\n      return [(0, _tfjsCore.tanh)(getParamValue(\"x\", e, t, a))];case \"tan\":\n      return [(0, _tfjsCore.tan)(getParamValue(\"x\", e, t, a))];case \"clipByValue\":\n      return [(0, _tfjsCore.clipByValue)(getParamValue(\"x\", e, t, a), getParamValue(\"clipValueMin\", e, t, a), getParamValue(\"clipValueMax\", e, t, a))];case \"rsqrt\":\n      return [(0, _tfjsCore.div)((0, _tfjsCore.scalar)(1, \"float32\"), (0, _tfjsCore.sqrt)(getTensor(e.inputNames[0], t, a)))];default:\n      throw TypeError(\"Node type \" + e.op + \" is not implemented\");}\n},\n    TensorArray = function () {\n  function e(t, a, r, n, o, s, i) {\n    this.name = t, this.dtype = a, this.maxSize = r, this.elementShape = n, this.identicalElementShapes = o, this.dynamicSize = s, this.clearAfterRead = i, this.tensors = [], this.closed_ = !1, this.id = e.nextId++;\n  }return Object.defineProperty(e.prototype, \"closed\", { get: function () {\n      return this.closed_;\n    }, enumerable: !0, configurable: !0 }), e.prototype.clearAndClose = function () {\n    this.tensors.forEach(function (e) {\n      return e.tensor.dispose();\n    }), this.tensors = [], this.closed_ = !0;\n  }, e.prototype.size = function () {\n    return this.tensors.length;\n  }, e.prototype.read = function (e) {\n    if (this.closed_) throw new Error(\"TensorArray \" + this.name + \" has already been closed.\");if (e < 0 || e >= this.tensors.length) throw new Error(\"Tried to read from index \" + e + \", but array size is: \" + this.tensors.length);var t = this.tensors[e];if (t.cleared) throw new Error(\"TensorArray \" + this.name + \": Could not read index \" + e + \" twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).\");return this.clearAfterRead && (t.cleared = !0), t.read = !0, t.tensor;\n  }, e.prototype.readMany = function (e) {\n    var t = this;return e.map(function (e) {\n      return t.read(e);\n    });\n  }, e.prototype.write = function (e, t) {\n    if (this.closed_) throw new Error(\"TensorArray \" + this.name + \" has already been closed.\");if (e < 0 || !this.dynamicSize && e >= this.maxSize) throw new Error(\"Tried to write to index \" + e + \", but array is not resizeable and size is: \" + this.maxSize);var a = this.tensors[e] || {};if (t.dtype !== this.dtype) throw new Error(\"TensorArray \" + this.name + \": Could not write to TensorArray index \" + e + \",\\n          because the value dtype is \" + t.dtype + \", but TensorArray dtype is \" + this.dtype + \".\");if (0 === this.size() && 0 === this.elementShape.length && (this.elementShape = t.shape), this.assertShapesMatch(this.elementShape, t.shape, \"TensorArray \" + this.name + \": Could not write to TensorArray index \" + e + \".\"), a && a.read) throw new Error(\"TensorArray \" + this.name + \": Could not write to TensorArray index \" + e + \", because it has already been read.\");if (a && a.written) throw new Error(\"TensorArray \" + this.name + \": Could not write to TensorArray index \" + e + \", because it has already been written.\");a.tensor = t, a.written = !0, this.tensors[e] = a;\n  }, e.prototype.writeMany = function (e, t) {\n    var a = this;if (e.length !== t.length) throw new Error(\"TensorArray \" + this.name + \": could not write multiple tensors,because the index size: \" + e.length + \" is not the same as tensors size: \" + t.length + \".\");e.forEach(function (e, r) {\n      return a.write(e, t[r]);\n    });\n  }, e.prototype.gather = function (e, t) {\n    if (t && t !== this.dtype) throw new Error(\"TensorArray dtype is \" + this.dtype + \" but gather requested dtype \" + t);if (!e) {\n      e = [];for (var a = 0; a < this.size(); a++) e.push(a);\n    }if (0 === e.length) return (0, _tfjsCore.tensor)([], [0].concat(this.elementShape));var r = this.readMany(e);return this.assertShapesMatch(this.elementShape, r[0].shape, \"TensorArray shape mismatch: \"), (0, _tfjsCore.stack)(r, 0);\n  }, e.prototype.concat = function (e) {\n    if (e && e !== this.dtype) throw new Error(\"TensorArray dtype is \" + this.dtype + \" but concat requested dtype \" + e);if (0 === this.size()) return (0, _tfjsCore.tensor)([], [0].concat(this.elementShape));for (var t = [], a = 0; a < this.size(); a++) t.push(a);var r = this.readMany(t);return this.assertShapesMatch(this.elementShape, r[0].shape, \"TensorArray shape mismatch: tensor array shape (\" + this.elementShape + \") vs first tensor shape (\" + r[0].shape + \")\"), (0, _tfjsCore.concat)(r, 0);\n  }, e.prototype.scatter = function (e, t) {\n    if (t.dtype !== this.dtype) throw new Error(\"TensorArray dtype is \" + this.dtype + \" but tensor has dtype \" + t.dtype);if (e.length !== t.shape[0]) throw new Error(\"Expected len(indices) == tensor.shape[0], but saw: \" + e.length + \" vs. \" + t.shape[0]);var a = Math.max.apply(Math, e);if (!this.dynamicSize && a >= this.maxSize) throw new Error(\"Max index must be < array size (\" + a + \"  vs. \" + this.maxSize + \")\");this.writeMany(e, (0, _tfjsCore.unstack)(t, 0));\n  }, e.prototype.split = function (e, t) {\n    var a = this;if (t.dtype !== this.dtype) throw new Error(\"TensorArray dtype is \" + this.dtype + \" but tensor has dtype \" + t.dtype);var r = 0,\n        n = e.map(function (e) {\n      return r += e;\n    });if (r !== t.shape[0]) throw new Error(\"Expected sum of lengths to be equal to\\n          tensor.shape[0], but sum of lengths is\\n        \" + r + \", and tensor's shape is: \" + t.shape);if (!this.dynamicSize && e.length !== this.maxSize) throw new Error(\"TensorArray's size is not equal to the size of lengths (\" + this.maxSize + \" vs. \" + e.length + \"), and the TensorArray is not marked as dynamically resizeable\");var o = 0 === r ? 0 : t.size / r,\n        s = [];(0, _tfjsCore.tidy)(function () {\n      t = t.reshape([1, r, o]);for (var i = 0; i < e.length; ++i) {\n        var p = [0, 0 === i ? 0 : n[i - 1], 0],\n            u = [1, e[i], o];s[i] = (0, _tfjsCore.slice)(t, p, u).reshape(a.elementShape);\n      }return s;\n    });for (var i = [], p = 0; p < e.length; p++) i[p] = p;this.writeMany(i, s);\n  }, e.prototype.assertShapesMatch = function (e, t, a) {\n    void 0 === a && (a = \"\"), _tfjsCore.util.assert(this.arraysEqual(e, t), a + \" Shapes \" + e + \" and \" + t + \" must match\");\n  }, e.prototype.arraysEqual = function (e, t) {\n    if (e.length !== t.length) return !1;for (var a = 0; a < e.length; a++) if (-1 !== e[a] && -1 !== t[a] && e[a] !== t[a]) return !1;return !0;\n  }, e.nextId = 0, e;\n}();function executeOp$2(e, t, a) {\n  return __awaiter(this, void 0, void 0, function () {\n    var r, n, o, s, i, p, u, m, l, d, c, f, y, h, g, N, P, b, x, I, v, O, w, V, k, T, $, _, S, A, D, E, j, C, L;return __generator(this, function (R) {\n      switch (R.label) {case 0:\n          switch (e.op) {case \"loopCond\":\n              return [3, 1];case \"switch\":\n              return [3, 2];case \"merge\":\n              return [3, 4];case \"enter\":\n              return [3, 5];case \"exit\":\n              return [3, 6];case \"nextIteration\":\n              return [3, 7];case \"tensorArray\":\n              return [3, 8];case \"tensorArrayWrite\":\n              return [3, 9];case \"tensorArrayRead\":\n              return [3, 10];case \"tensorArrayGather\":\n              return [3, 11];case \"tensorArrayScatter\":\n              return [3, 12];case \"tensorArrayConcat\":\n              return [3, 13];case \"tensorArraySplit\":\n              return [3, 14];case \"tensorArraySize\":\n              return [3, 15];case \"tensorArrayClose\":\n              return [3, 16];}return [3, 17];case 1:\n          return [2, [getParamValue(\"pred\", e, t, a)]];case 2:\n          return r = getParamValue(\"pred\", e, t, a), n = getParamValue(\"data\", e, t, a), [4, r.data()];case 3:\n          return [2, R.sent()[0] ? [void 0, n] : [n, void 0]];case 4:\n          return [2, (o = e.inputNames.find(function (e) {\n            return void 0 !== getTensor(e, t, a);\n          })) ? [getTensor(o, t, a)] : void 0];case 5:\n          return s = getParamValue(\"frameName\", e, t, a), i = getParamValue(\"tensor\", e, t, a), a.enterFrame(s), [2, [i]];case 6:\n          return p = getParamValue(\"tensor\", e, t, a), a.exitFrame(), [2, [p]];case 7:\n          return u = getParamValue(\"tensor\", e, t, a), a.nextIteration(), [2, [u]];case 8:\n          return m = getParamValue(\"size\", e, t, a), l = getParamValue(\"dtype\", e, t, a), d = getParamValue(\"elementShape\", e, t, a), c = getParamValue(\"dynamicSize\", e, t, a), f = getParamValue(\"clearAfterRead\", e, t, a), y = getParamValue(\"identicalElementShapes\", e, t, a), h = getParamValue(\"name\", e, t, a), g = new TensorArray(h, l, m, d, y, c, f), a.addTensorArray(g), [2, [(0, _tfjsCore.scalar)(g.id), (0, _tfjsCore.scalar)(1)]];case 9:\n          return N = getParamValue(\"tensorArrayId\", e, t, a), P = getParamValue(\"index\", e, t, a), b = getParamValue(\"tensor\", e, t, a), a.getTensorArray(N).write(P, b), [2, [(0, _tfjsCore.scalar)(1)]];case 10:\n          return x = getParamValue(\"tensorArrayId\", e, t, a), I = getParamValue(\"index\", e, t, a), [2, [a.getTensorArray(x).read(I)]];case 11:\n          return v = getParamValue(\"tensorArrayId\", e, t, a), O = getParamValue(\"indices\", e, t, a), w = getParamValue(\"dtype\", e, t, a), [2, [a.getTensorArray(v).gather(O, w)]];case 12:\n          return V = getParamValue(\"tensorArrayId\", e, t, a), k = getParamValue(\"indices\", e, t, a), T = getParamValue(\"tensor\", e, t, a), a.getTensorArray(V).scatter(k, T), [2, [(0, _tfjsCore.scalar)(1)]];case 13:\n          return $ = getParamValue(\"tensorArrayId\", e, t, a), _ = a.getTensorArray($), S = getParamValue(\"dtype\", e, t, a), [2, [_.concat(S)]];case 14:\n          return A = getParamValue(\"tensorArrayId\", e, t, a), D = getParamValue(\"tensor\", e, t, a), E = getParamValue(\"lengths\", e, t, a), a.getTensorArray(A).split(E, D), [2, [(0, _tfjsCore.scalar)(1)]];case 15:\n          return j = getParamValue(\"tensorArrayId\", e, t, a), C = a.getTensorArray(j), [2, [(0, _tfjsCore.scalar)(C.size(), \"int32\")]];case 16:\n          return L = getParamValue(\"tensorArrayId\", e, t, a), a.getTensorArray(L).clearAndClose(), [2, []];case 17:\n          throw TypeError(\"Node type \" + e.op + \" is not implemented\");}\n    });\n  });\n}var executeOp$3 = function (e, t, a) {\n  switch (e.op) {case \"conv1d\":\n      var r = getParamValue(\"stride\", e, t, a),\n          n = getParamValue(\"pad\", e, t, a),\n          o = getParamValue(\"dataFormat\", e, t, a).toUpperCase(),\n          s = getParamValue(\"dilation\", e, t, a);return [(0, _tfjsCore.conv1d)(getParamValue(\"x\", e, t, a), getParamValue(\"filter\", e, t, a), r, n, o, s)];case \"conv2d\":\n      r = getParamValue(\"strides\", e, t, a), n = getParamValue(\"pad\", e, t, a), o = getParamValue(\"dataFormat\", e, t, a).toUpperCase();var i = getParamValue(\"dilations\", e, t, a);return [(0, _tfjsCore.conv2d)(getParamValue(\"x\", e, t, a), getParamValue(\"filter\", e, t, a), [r[1], r[2]], n, o, [i[0], i[1]])];case \"conv2dTranspose\":\n      var p = getParamValue(\"outputShape\", e, t, a);r = getParamValue(\"strides\", e, t, a), n = getParamValue(\"pad\", e, t, a);return [(0, _tfjsCore.conv2dTranspose)(getParamValue(\"x\", e, t, a), getParamValue(\"filter\", e, t, a), p, [r[1], r[2]], n)];case \"depthwiseConv2d\":\n      r = getParamValue(\"strides\", e, t, a), n = getParamValue(\"pad\", e, t, a), i = getParamValue(\"dilations\", e, t, a), o = getParamValue(\"dataFormat\", e, t, a).toUpperCase();return [(0, _tfjsCore.depthwiseConv2d)(getParamValue(\"input\", e, t, a), getParamValue(\"filter\", e, t, a), [r[1], r[2]], n, o, [i[0], i[1]])];case \"avgPool\":\n      r = getParamValue(\"strides\", e, t, a), n = getParamValue(\"pad\", e, t, a);var u = getParamValue(\"kernelSize\", e, t, a);return [(0, _tfjsCore.avgPool)(getParamValue(\"x\", e, t, a), [u[1], u[2]], [r[1], r[2]], n)];case \"maxPool\":\n      r = getParamValue(\"strides\", e, t, a), n = getParamValue(\"pad\", e, t, a), u = getParamValue(\"kernelSize\", e, t, a);return [(0, _tfjsCore.maxPool)(getParamValue(\"x\", e, t, a), [u[1], u[2]], [r[1], r[2]], n)];default:\n      throw TypeError(\"Node type \" + e.op + \" is not implemented\");}\n},\n    executeOp$4 = function (e, t, a) {\n  switch (e.op) {case \"fill\":\n      var r = getParamValue(\"shape\", e, t, a),\n          n = getParamValue(\"dtype\", e, t, a),\n          o = getParamValue(\"value\", e, t, a);return [(0, _tfjsCore.fill)(r, o, n)];case \"linspace\":\n      var s = getParamValue(\"start\", e, t, a),\n          i = getParamValue(\"stop\", e, t, a),\n          p = getParamValue(\"num\", e, t, a);return [(0, _tfjsCore.linspace)(s, i, p)];case \"oneHot\":\n      var u = getParamValue(\"indices\", e, t, a),\n          m = getParamValue(\"depth\", e, t, a),\n          l = getParamValue(\"onValue\", e, t, a),\n          d = getParamValue(\"offValue\", e, t, a);return [(0, _tfjsCore.oneHot)(u, m, l, d)];case \"ones\":\n      return [(0, _tfjsCore.ones)(getParamValue(\"shape\", e, t, a), getParamValue(\"dtype\", e, t, a))];case \"onesLike\":\n      return [(0, _tfjsCore.onesLike)(getParamValue(\"x\", e, t, a))];case \"randomUniform\":\n      return [(0, _tfjsCore.randomUniform)(getParamValue(\"shape\", e, t, a), getParamValue(\"minval\", e, t, a), getParamValue(\"maxval\", e, t, a), getParamValue(\"dtype\", e, t, a))];case \"range\":\n      s = getParamValue(\"start\", e, t, a);var c = getParamValue(\"stop\", e, t, a),\n          f = getParamValue(\"step\", e, t, a);return [(0, _tfjsCore.range)(s, c, f, getParamValue(\"dtype\", e, t, a))];case \"truncatedNormal\":\n      r = getParamValue(\"shape\", e, t, a);var y = getParamValue(\"mean\", e, t, a),\n          h = getParamValue(\"stdDev\", e, t, a),\n          g = getParamValue(\"seed\", e, t, a);return [(0, _tfjsCore.truncatedNormal)(r, y, h, getParamValue(\"dtype\", e, t, a), g)];case \"zeros\":\n      return [(0, _tfjsCore.zeros)(getParamValue(\"shape\", e, t, a), getParamValue(\"dtype\", e, t, a))];case \"zerosLike\":\n      return [(0, _tfjsCore.zerosLike)(getParamValue(\"x\", e, t, a))];default:\n      throw TypeError(\"Node type \" + e.op + \" is not implemented\");}\n};function executeOp$5(e, t, a) {\n  return __awaiter(this, void 0, void 0, function () {\n    var r, n, o, s, i;return __generator(this, function (p) {\n      switch (p.label) {case 0:\n          switch (e.op) {case \"nonMaxSuppression\":\n              return [3, 1];case \"whereAsync\":\n              return [3, 3];}return [3, 5];case 1:\n          return r = getParamValue(\"boxes\", e, t, a), n = getParamValue(\"scores\", e, t, a), o = getParamValue(\"maxOutputSize\", e, t, a), s = getParamValue(\"iouThreshold\", e, t, a), i = getParamValue(\"scoreThreshold\", e, t, a), [4, _tfjsCore.image.nonMaxSuppressionAsync(r, n, o, s, i)];case 2:\n          return [2, [p.sent()]];case 3:\n          return [4, (0, _tfjsCore.whereAsync)(getParamValue(\"condition\", e, t, a))];case 4:\n          return [2, [p.sent()]];case 5:\n          throw TypeError(\"Node type \" + e.op + \" is not implemented\");}\n    });\n  });\n}var executeOp$6 = function (e, t, a) {\n  switch (e.op) {case \"topK\":\n      var r = getParamValue(\"x\", e, t, a),\n          n = getParamValue(\"k\", e, t, a),\n          o = getParamValue(\"sorted\", e, t, a),\n          s = (0, _tfjsCore.topk)(r, n, o);return [s.values, s.indices];default:\n      throw TypeError(\"Node type \" + e.op + \" is not implemented\");}\n},\n    executeOp$7 = function (e, t, a) {\n  switch (e.op) {case \"const\":\n      return t[e.name];case \"placeholder\":\n      var r = getParamValue(\"default\", e, t, a);return [getTensor(e.name, t, a) || r];case \"identity\":case \"stopGradient\":case \"fakeQuantWithMinMaxVars\":\n      return [getParamValue(\"x\", e, t, a)];case \"snapshot\":\n      return [getParamValue(\"x\", e, t, a).clone()];case \"shape\":\n      return [(0, _tfjsCore.tensor1d)(getParamValue(\"x\", e, t, a).shape, \"int32\")];case \"shapeN\":\n      return getParamValue(\"x\", e, t, a).map(function (e) {\n        return (0, _tfjsCore.tensor1d)(e.shape);\n      });case \"size\":\n      return [(0, _tfjsCore.scalar)(getParamValue(\"x\", e, t, a).size, \"int32\")];case \"rank\":\n      return [(0, _tfjsCore.scalar)(getParamValue(\"x\", e, t, a).rank, \"int32\")];case \"noop\":\n      return [];case \"print\":\n      var n = getParamValue(\"x\", e, t, a),\n          o = getParamValue(\"data\", e, t, a),\n          s = getParamValue(\"message\", e, t, a),\n          i = getParamValue(\"summarize\", e, t, a);console.warn(\"The graph has a tf.print() operation,usually used for debugging, which slows down performance.\"), console.log(s);for (var p = 0; p < o.length; p++) console.log(Array.prototype.slice.call(o[0].dataSync()).slice(0, i));return [n];default:\n      throw TypeError(\"Node type \" + e.op + \" is not implemented\");}\n},\n    executeOp$8 = function (e, t, a) {\n  switch (e.op) {case \"resizeBilinear\":\n      var r = getParamValue(\"images\", e, t, a),\n          n = getParamValue(\"size\", e, t, a),\n          o = getParamValue(\"alignCorners\", e, t, a);return [_tfjsCore.image.resizeBilinear(r, [n[0], n[1]], o)];case \"resizeNearestNeighbor\":\n      r = getParamValue(\"images\", e, t, a), n = getParamValue(\"size\", e, t, a), o = getParamValue(\"alignCorners\", e, t, a);return [_tfjsCore.image.resizeNearestNeighbor(r, [n[0], n[1]], o)];default:\n      throw TypeError(\"Node type \" + e.op + \" is not implemented\");}\n},\n    executeOp$9 = function (e, t, a) {\n  switch (e.op) {case \"equal\":\n      return [(0, _tfjsCore.equal)(getParamValue(\"a\", e, t, a), getParamValue(\"b\", e, t, a))];case \"notEqual\":\n      return [(0, _tfjsCore.notEqual)(getParamValue(\"a\", e, t, a), getParamValue(\"b\", e, t, a))];case \"greater\":\n      return [(0, _tfjsCore.greater)(getParamValue(\"a\", e, t, a), getParamValue(\"b\", e, t, a))];case \"greaterEqual\":\n      return [(0, _tfjsCore.greaterEqual)(getParamValue(\"a\", e, t, a), getParamValue(\"b\", e, t, a))];case \"less\":\n      return [(0, _tfjsCore.less)(getParamValue(\"a\", e, t, a), getParamValue(\"b\", e, t, a))];case \"lessEqual\":\n      return [(0, _tfjsCore.lessEqual)(getParamValue(\"a\", e, t, a), getParamValue(\"b\", e, t, a))];case \"logicalAnd\":\n      return [(0, _tfjsCore.logicalAnd)(getParamValue(\"a\", e, t, a), getParamValue(\"b\", e, t, a))];case \"logicalNot\":\n      return [(0, _tfjsCore.logicalNot)(getParamValue(\"a\", e, t, a))];case \"logicalOr\":\n      return [(0, _tfjsCore.logicalOr)(getParamValue(\"a\", e, t, a), getParamValue(\"b\", e, t, a))];case \"where\":\n      return [(0, _tfjsCore.where)(getParamValue(\"condition\", e, t, a), getParamValue(\"a\", e, t, a), getParamValue(\"b\", e, t, a))];default:\n      throw TypeError(\"Node type \" + e.op + \" is not implemented\");}\n},\n    executeOp$10 = function (e, t, a) {\n  switch (e.op) {case \"matMul\":\n      return [(0, _tfjsCore.matMul)(getParamValue(\"a\", e, t, a), getParamValue(\"b\", e, t, a), getParamValue(\"transposeA\", e, t, a), getParamValue(\"transposeB\", e, t, a))];case \"transpose\":\n      return [(0, _tfjsCore.transpose)(getParamValue(\"x\", e, t, a), getParamValue(\"perm\", e, t, a))];default:\n      throw TypeError(\"Node type \" + e.op + \" is not implemented\");}\n},\n    executeOp$11 = function (e, t, a) {\n  switch (e.op) {case \"batchNormalization\":\n      return [(0, _tfjsCore.batchNormalization)(getParamValue(\"x\", e, t, a), getParamValue(\"mean\", e, t, a), getParamValue(\"variance\", e, t, a), getParamValue(\"epsilon\", e, t, a), getParamValue(\"scale\", e, t, a), getParamValue(\"offset\", e, t, a))];case \"localResponseNormalization\":\n      return [(0, _tfjsCore.localResponseNormalization)(getParamValue(\"x\", e, t, a), getParamValue(\"radius\", e, t, a), getParamValue(\"bias\", e, t, a), getParamValue(\"alpha\", e, t, a), getParamValue(\"beta\", e, t, a))];case \"softmax\":\n      return [(0, _tfjsCore.softmax)(getParamValue(\"x\", e, t, a))];default:\n      throw TypeError(\"Node type \" + e.op + \" is not implemented\");}\n},\n    executeOp$12 = function (e, t, a) {\n  switch (e.op) {case \"max\":\n      var r = getParamValue(\"axis\", e, t, a),\n          n = getParamValue(\"keepDims\", e, t, a);return [(0, _tfjsCore.max)(getParamValue(\"x\", e, t, a), r, n)];case \"mean\":\n      r = getParamValue(\"axis\", e, t, a), n = getParamValue(\"keepDims\", e, t, a);return [(0, _tfjsCore.mean)(getParamValue(\"x\", e, t, a), r, n)];case \"min\":\n      r = getParamValue(\"axis\", e, t, a), n = getParamValue(\"keepDims\", e, t, a);return [(0, _tfjsCore.min)(getParamValue(\"x\", e, t, a), r, n)];case \"sum\":\n      r = getParamValue(\"axis\", e, t, a), n = getParamValue(\"keepDims\", e, t, a);return [(0, _tfjsCore.sum)(getParamValue(\"x\", e, t, a), r, n)];case \"all\":\n      r = getParamValue(\"axis\", e, t, a), n = getParamValue(\"keepDims\", e, t, a);return [(0, _tfjsCore.all)(getParamValue(\"x\", e, t, a), r, n)];case \"any\":\n      r = getParamValue(\"axis\", e, t, a), n = getParamValue(\"keepDims\", e, t, a);return [(0, _tfjsCore.any)(getParamValue(\"x\", e, t, a), r, n)];case \"argMax\":\n      r = getParamValue(\"axis\", e, t, a);return [(0, _tfjsCore.argMax)(getParamValue(\"x\", e, t, a), r)];case \"argMin\":\n      r = getParamValue(\"axis\", e, t, a);return [(0, _tfjsCore.argMin)(getParamValue(\"x\", e, t, a), r)];default:\n      throw TypeError(\"Node type \" + e.op + \" is not implemented\");}\n},\n    executeOp$13 = function (e, t, a) {\n  switch (e.op) {case \"concat\":\n      var r = getParamValue(\"axis\", e, t, a),\n          n = getParamValue(\"tensors\", e, t, a);return [(0, _tfjsCore.concat)(n, r)];case \"gather\":\n      r = getParamValue(\"axis\", e, t, a);var o = getParamValue(\"x\", e, t, a),\n          s = getParamValue(\"indices\", e, t, a);return [(0, _tfjsCore.gather)(o, s, r)];case \"reverse\":\n      r = getParamValue(\"axis\", e, t, a), o = getParamValue(\"x\", e, t, a);return [(0, _tfjsCore.reverse)(o, r)];case \"slice\":\n      var i = getParamValue(\"begin\", e, t, a),\n          p = getParamValue(\"size\", e, t, a);return [(0, _tfjsCore.slice)(getParamValue(\"x\", e, t, a), i, p)];case \"stridedSlice\":\n      i = getParamValue(\"begin\", e, t, a);var u = getParamValue(\"end\", e, t, a),\n          m = getParamValue(\"strides\", e, t, a),\n          l = getParamValue(\"beginMask\", e, t, a),\n          d = getParamValue(\"endMask\", e, t, a),\n          c = getParamValue(\"ellipsisMask\", e, t, a),\n          f = getParamValue(\"newAxisMask\", e, t, a),\n          y = getParamValue(\"shrinkAxisMask\", e, t, a),\n          h = getParamValue(\"x\", e, t, a);if (1 === i.length && h.shape.length > 1) for (var g = 1; g < h.shape.length; g++) i.push(0), u.push(h.shape[g]), m.push(m[0]);return [(0, _tfjsCore.stridedSlice)(h, i, u, m, l, d, c, f, y)];case \"stack\":\n      return (0, _tfjsCore.tidy)(function () {\n        var r = getParamValue(\"axis\", e, t, a),\n            n = getParamValue(\"tensors\", e, t, a),\n            o = n[0].shape,\n            s = n[0].squeeze().shape,\n            i = n.map(function (e) {\n          var t = _tfjsCore.util.arraysEqual(e.shape, o);if (!t && !_tfjsCore.util.arraysEqual(e.squeeze().shape, s)) throw new Error(\"the input tensors shape does not match\");return t ? e : e.reshape(o);\n        });return [(0, _tfjsCore.stack)(i, r)];\n      });case \"unstack\":\n      return (0, _tfjsCore.tidy)(function () {\n        var r = getParamValue(\"axis\", e, t, a),\n            n = getParamValue(\"tensor\", e, t, a);return (0, _tfjsCore.unstack)(n, r);\n      });case \"tile\":\n      var N = getParamValue(\"reps\", e, t, a);return [(0, _tfjsCore.tile)(getParamValue(\"x\", e, t, a), N)];case \"split\":\n      r = getParamValue(\"axis\", e, t, a);var P = getParamValue(\"numOrSizeSplits\", e, t, a);return (0, _tfjsCore.split)(getParamValue(\"x\", e, t, a), P, r);default:\n      throw TypeError(\"Node type \" + e.op + \" is not implemented\");}\n},\n    executeOp$14 = function (e, t, a) {\n  switch (e.op) {case \"cast\":\n      return [(0, _tfjsCore.cast)(getParamValue(\"x\", e, t, a), getParamValue(\"dtype\", e, t, a))];case \"expandDims\":\n      var r = getParamValue(\"axis\", e, t, a);return [(0, _tfjsCore.expandDims)(getParamValue(\"x\", e, t, a), r)];case \"squeeze\":\n      r = getParamValue(\"axis\", e, t, a);return [(0, _tfjsCore.squeeze)(getParamValue(\"x\", e, t, a), r)];case \"reshape\":\n      return [(0, _tfjsCore.reshape)(getParamValue(\"x\", e, t, a), getParamValue(\"shape\", e, t, a))];case \"pad\":\n      return [(0, _tfjsCore.pad)(getParamValue(\"x\", e, t, a), split$1(getParamValue(\"padding\", e, t, a), 2), getParamValue(\"constantValue\", e, t, a))];case \"spaceToBatchND\":\n      var n = getParamValue(\"blockShape\", e, t, a),\n          o = split$1(getParamValue(\"paddings\", e, t, a), 2);return [(0, _tfjsCore.spaceToBatchND)(getParamValue(\"x\", e, t, a), n, o)];case \"batchToSpaceND\":\n      n = getParamValue(\"blockShape\", e, t, a);var s = split$1(getParamValue(\"crops\", e, t, a), 2);return [(0, _tfjsCore.batchToSpaceND)(getParamValue(\"x\", e, t, a), n, s)];default:\n      throw TypeError(\"Node type \" + e.op + \" is not implemented\");}\n};function executeOp$15(e, t, a) {\n  switch (e.category) {case \"arithmetic\":\n      return executeOp(e, t, a);case \"basic_math\":\n      return executeOp$1(e, t, a);case \"control\":\n      return executeOp$2(e, t, a);case \"convolution\":\n      return executeOp$3(e, t, a);case \"creation\":\n      return executeOp$4(e, t, a);case \"dynamic\":\n      return executeOp$5(e, t, a);case \"evaluation\":\n      return executeOp$6(e, t, a);case \"image\":\n      return executeOp$8(e, t, a);case \"graph\":\n      return executeOp$7(e, t, a);case \"logical\":\n      return executeOp$9(e, t, a);case \"matrices\":\n      return executeOp$10(e, t, a);case \"normalization\":\n      return executeOp$11(e, t, a);case \"reduction\":\n      return executeOp$12(e, t, a);case \"slice_join\":\n      return executeOp$13(e, t, a);case \"transformation\":\n      return executeOp$14(e, t, a);default:\n      throw TypeError(\"Node type \" + e.op + \" is not implemented\");}\n}var ExecutionContext = function () {\n  function e(e, t) {\n    this.weightMap = e, this.tensorArrayMap = t, this.rootContext = { id: 0, frameName: \"\", iterationId: 0 }, this.contexts = [this.rootContext], this.lastId = 0, this.generateCurrentContextIds();\n  }return e.prototype.newFrame = function (e, t) {\n    return { id: e, frameName: t, iterationId: 0 };\n  }, Object.defineProperty(e.prototype, \"currentContext\", { get: function () {\n      return this.contexts;\n    }, set: function (e) {\n      this.contexts !== e && (this.contexts = e, this.generateCurrentContextIds());\n    }, enumerable: !0, configurable: !0 }), Object.defineProperty(e.prototype, \"currentContextId\", { get: function () {\n      return this._currentContextIds[0];\n    }, enumerable: !0, configurable: !0 }), Object.defineProperty(e.prototype, \"currentContextIds\", { get: function () {\n      return this._currentContextIds;\n    }, enumerable: !0, configurable: !0 }), e.prototype.generateCurrentContextIds = function () {\n    for (var e = [], t = 0; t < this.contexts.length - 1; t++) {\n      var a = this.contexts.slice(0, this.contexts.length - t);e.push(this.contextIdforContexts(a));\n    }e.push(\"\"), this._currentContextIds = e;\n  }, e.prototype.contextIdforContexts = function (e) {\n    return e ? e.map(function (e) {\n      return 0 === e.id && 0 === e.iterationId ? \"\" : e.frameName + \"-\" + e.iterationId;\n    }).join(\"/\") : \"\";\n  }, e.prototype.enterFrame = function (e) {\n    this.contexts && (this.lastId++, this.contexts = this.contexts.slice(), this.contexts.push(this.newFrame(this.lastId, e)), this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)));\n  }, e.prototype.exitFrame = function () {\n    if (!(this.contexts && this.contexts.length > 1)) throw new Error(\"Cannot exit frame, the context is empty\");this.contexts = this.contexts.slice(), this.contexts.splice(-1), this.currentContextIds.shift();\n  }, e.prototype.nextIteration = function () {\n    if (!(this.contexts && this.contexts.length > 0)) throw new Error(\"Cannot increase frame iteration, the context is empty\");this.contexts = this.contexts.slice(), this.lastId++;var e = Object.assign({}, this.contexts[this.contexts.length - 1]);e.iterationId += 1, e.id = this.lastId, this.contexts.splice(-1, 1, e), this._currentContextIds.splice(0, 1, this.contextIdforContexts(this.contexts));\n  }, e.prototype.getWeight = function (e) {\n    return this.weightMap[e];\n  }, e.prototype.addTensorArray = function (e) {\n    this.tensorArrayMap[e.id] = e;\n  }, e.prototype.getTensorArray = function (e) {\n    return this.tensorArrayMap[e];\n  }, e;\n}(),\n    GraphExecutor = function () {\n  function e(e) {\n    this.graph = e, this.compiledMap = new Map(), this._weightMap = {}, this.SEPERATOR = \",\", this.placeholders = e.placeholders, this._outputs = e.outputs, this.compile();\n  }return Object.defineProperty(e.prototype, \"weightMap\", { get: function () {\n      return this._weightMap;\n    }, set: function (e) {\n      var t = Object.keys(e).map(function (t) {\n        return e[t].map(function (e) {\n          return e.id;\n        });\n      });this.weightIds = [].concat.apply([], t), this._weightMap = e;\n    }, enumerable: !0, configurable: !0 }), Object.defineProperty(e.prototype, \"inputs\", { get: function () {\n      return this.placeholders.map(function (e) {\n        return { name: e.name, shape: e.params.shape ? e.params.shape.value : void 0, dtype: e.params.dtype ? e.params.dtype.value : void 0 };\n      });\n    }, enumerable: !0, configurable: !0 }), Object.defineProperty(e.prototype, \"outputs\", { get: function () {\n      return this._outputs.map(function (e) {\n        return { name: e.name, shape: e.params.shape ? e.params.shape.value : void 0, dtype: e.params.dtype ? e.params.dtype.value : void 0 };\n      });\n    }, enumerable: !0, configurable: !0 }), Object.defineProperty(e.prototype, \"inputNodes\", { get: function () {\n      return this.placeholders.map(function (e) {\n        return e.name;\n      });\n    }, enumerable: !0, configurable: !0 }), Object.defineProperty(e.prototype, \"outputNodes\", { get: function () {\n      return this.outputs.map(function (e) {\n        return e.name;\n      });\n    }, enumerable: !0, configurable: !0 }), Object.defineProperty(e.prototype, \"isControlFlowModel\", { get: function () {\n      return this.graph.withControlFlow;\n    }, enumerable: !0, configurable: !0 }), Object.defineProperty(e.prototype, \"isDynamicShapeModel\", { get: function () {\n      return this.graph.withDynamicShape;\n    }, enumerable: !0, configurable: !0 }), e.prototype.compile = function (e) {\n    if (!this.graph.withControlFlow && !this.graph.withDynamicShape) {\n      var t = [],\n          a = e || this.graph.placeholders,\n          r = a.map(function (e) {\n        return e.name;\n      }).sort().join(this.SEPERATOR);if (!this.compiledMap.get(r)) {\n        for (var n = a.concat(this.graph.weights), o = {}; n.length > 0;) {\n          var s = n.pop();o[s.name] = !0, t.push(s), s.children.forEach(function (e) {\n            !o[e.name] && e.inputNames.every(function (e) {\n              var t = getNodeNameAndIndex(e)[0];return o[t];\n            }) && n.push(e);\n          });\n        }this.compiledMap.set(r, t);\n      }\n    }\n  }, e.prototype.execute = function (e, t, a) {\n    var r = this;void 0 === t && (t = !0);var n = Object.keys(e).sort();this.checkInput(e, t), this.checkInputShapeAndType(e, t), this.compile(n.map(function (e) {\n      return r.graph.nodes[e];\n    }));var o = this.calculateOutputs(a);this.checkOutput(this.compiledMap.get(n.join(this.SEPERATOR)), o);var s = {};return (0, _tfjsCore.tidy)(function () {\n      for (var t = new ExecutionContext(r._weightMap, s), a = __assign({}, r.weightMap, e), i = r.compiledMap.get(n.join(r.SEPERATOR)), p = 0; p < i.length; p++) {\n        var u = i[p];if (a[u.name] || (a[u.name] = executeOp$15(u, a, t)), o.every(function (e) {\n          return !!a[e];\n        })) break;\n      }return r.findOutputs(a, t, o);\n    });\n  }, e.prototype.executeAsync = function (e, t) {\n    return __awaiter(this, void 0, void 0, function () {\n      var a,\n          r,\n          n,\n          o,\n          s,\n          i,\n          p,\n          u = this;return __generator(this, function (m) {\n        switch (m.label) {case 0:\n            return this.checkInput(e, !1), this.checkInputShapeAndType(e, !1), a = {}, r = new ExecutionContext(this._weightMap, a), [4, this.executeWithControlFlow(e, r)];case 1:\n            return n = m.sent(), o = this.findOutputs(n, r, t), s = Object.keys(o).map(function (e) {\n              return o[e].id;\n            }), i = Object.keys(e).map(function (t) {\n              return e[t].map(function (e) {\n                return e.id;\n              });\n            }), p = [].concat.apply([], i), Object.keys(n).forEach(function (e) {\n              n[e].forEach(function (e) {\n                e && -1 === s.indexOf(e.id) && -1 === p.indexOf(e.id) && -1 === u.weightIds.indexOf(e.id) && e.dispose();\n              });\n            }), [2, o];}\n      });\n    });\n  }, e.prototype.executeWithControlFlow = function (e, t) {\n    return __awaiter(this, void 0, void 0, function () {\n      var a,\n          r,\n          n,\n          o,\n          s,\n          i,\n          p = this;return __generator(this, function (u) {\n        switch (u.label) {case 0:\n            a = Object.keys(e), r = a.map(function (e) {\n              return p.graph.nodes[e];\n            }), n = r.concat(this.graph.weights).map(function (e) {\n              return { node: e, contexts: t.currentContext };\n            }), o = __assign({}, this.weightMap, e), s = {}, u.label = 1;case 1:\n            return n.length > 0 ? (i = this.processStack(r, n, t, o, s), [4, Promise.all(i)]) : [3, 3];case 2:\n            return u.sent(), [3, 1];case 3:\n            return [2, o];}\n      });\n    });\n  }, e.prototype.processStack = function (e, t, a, r, n) {\n    for (var o = this, s = [], i = function () {\n      var i = t.pop();a.currentContext = i.contexts;var u = \"\";if (\"enter\" === i.node.op && getParamValue(\"isConstant\", i.node, r, a) && (u = getNodeNameAndIndex(i.node.name, a)[0]), -1 === e.indexOf(i.node)) {\n        var m = executeOp$15(i.node, r, a);u || (u = getNodeNameAndIndex(i.node.name, a)[0]);var l = a.currentContext;m instanceof Promise ? s.push(m.then(function (e) {\n          return r[u] = e, a.currentContext = l, o.processChildNodes(i.node, t, a, r, n), e;\n        })) : (r[u] = m, p.processChildNodes(i.node, t, a, r, n));\n      } else p.processChildNodes(i.node, t, a, r, n);\n    }, p = this; t.length > 0;) i();return s;\n  }, e.prototype.processChildNodes = function (e, t, a, r, n) {\n    e.children.forEach(function (e) {\n      var o = getNodeNameAndIndex(e.name, a)[0];n[o] || (\"merge\" === e.op ? e.inputNames.some(function (e) {\n        return !!getTensor(e, r, a);\n      }) && (n[o] = !0, t.push({ contexts: a.currentContext, node: e })) : e.inputNames.every(function (e) {\n        return !!getTensor(e, r, a);\n      }) && (n[o] = !0, t.push({ contexts: a.currentContext, node: e })));\n    });\n  }, e.prototype.calculateOutputs = function (e) {\n    return !e || e instanceof Array || (e = [e]), e || this.graph.outputs.map(function (e) {\n      return e.name;\n    });\n  }, e.prototype.findOutputs = function (e, t, a) {\n    return this.calculateOutputs(a).reduce(function (a, r) {\n      return a[r] = getTensor(r, e, t), a;\n    }, {});\n  }, e.prototype.dispose = function () {\n    var e = this;Object.keys(this.weightMap).forEach(function (t) {\n      return e.weightMap[t].forEach(function (e) {\n        return e.dispose();\n      });\n    });\n  }, e.prototype.checkInputShapeAndType = function (e, t) {\n    void 0 === t && (t = !0), this.placeholders.forEach(function (a) {\n      var r = e[a.name];if (t || r) {\n        var n = r[0];if (a.params.shape && a.params.shape.value) {\n          var o = a.params.shape.value,\n              s = o.length === n.shape.length && n.shape.every(function (e, t) {\n            return -1 === o[t] || o[t] === e;\n          });_tfjsCore.util.assert(s, \"The shape of dict['\" + a.name + \"'] provided in model.execute(dict) must be [\" + o + \"], but was [\" + n.shape + \"]\");\n        }a.params.dtype && a.params.dtype.value && _tfjsCore.util.assert(n.dtype === a.params.dtype.value, \"The dtype of dict['\" + a.name + \"'] provided in model.execute(dict) must be \" + a.params.dtype.value + \", but was \" + n.dtype);\n      }\n    });\n  }, e.prototype.checkInput = function (e, t) {\n    var a = this;void 0 === t && (t = !0);var r = Object.keys(e),\n        n = [],\n        o = [];this.inputNodes.forEach(function (e) {\n      -1 === r.indexOf(e) && n.push(e);\n    }), r.forEach(function (e) {\n      -1 === a.inputNodes.indexOf(e) && o.push(e);\n    });var s = o.filter(function (e) {\n      return !a.graph.nodes[e];\n    });if (n.length > 0 && t) throw new Error(\"The dict provided in model.execute(dict) has the keys [\" + r + \"], but is missing the required keys: [\" + n + \"].\");if (o.length > 0 && t) throw new Error(\"The dict provided in model.execute(dict) has unused keys: [\" + o + \"]. Please provide only the following keys: [\" + this.inputNodes + \"].\");if (s.length > 0) throw new Error(\"The dict provided in model.execute(dict) has keys: [\" + s + \"] not part of model graph.\");\n  }, e.prototype.checkOutput = function (e, t) {\n    var a = e.map(function (e) {\n      return e.name;\n    }),\n        r = [];if (t.forEach(function (e) {\n      -1 === a.indexOf(e) && r.push(e);\n    }), r.length > 0) throw new Error(\"The following outputs are not be generated by the execution: [\" + r + \"].\");\n  }, e;\n}(),\n    FrozenModel = function () {\n  function e(e, t, a) {\n    this.modelUrl = e, this.weightManifestUrl = t, this.requestOption = a, this.version = \"n/a\";\n  }return Object.defineProperty(e.prototype, \"modelVersion\", { get: function () {\n      return this.version;\n    }, enumerable: !0, configurable: !0 }), Object.defineProperty(e.prototype, \"inputNodes\", { get: function () {\n      return this.executor.inputNodes;\n    }, enumerable: !0, configurable: !0 }), Object.defineProperty(e.prototype, \"outputNodes\", { get: function () {\n      return this.executor.outputNodes;\n    }, enumerable: !0, configurable: !0 }), Object.defineProperty(e.prototype, \"inputs\", { get: function () {\n      return this.executor.inputs;\n    }, enumerable: !0, configurable: !0 }), Object.defineProperty(e.prototype, \"outputs\", { get: function () {\n      return this.executor.outputs;\n    }, enumerable: !0, configurable: !0 }), Object.defineProperty(e.prototype, \"weights\", { get: function () {\n      return this.executor.weightMap;\n    }, enumerable: !0, configurable: !0 }), e.prototype.findIOHandler = function () {\n    var e = [this.modelUrl, this.weightManifestUrl];if (this.requestOption) this.handler = _tfjsCore.io.browserHTTPRequest(e, this.requestOption);else {\n      var t = _tfjsCore.io.getLoadHandlers(e);if (0 === t.length) t.push(_tfjsCore.io.browserHTTPRequest(e, this.requestOption));else if (t.length > 1) throw new Error(\"Found more than one (\" + t.length + \") load handlers for URL '\" + [e] + \"'\");this.handler = t[0];\n    }\n  }, e.prototype.load = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var e, t, a;return __generator(this, function (r) {\n        switch (r.label) {case 0:\n            if (this.findIOHandler(), null == this.handler.load) throw new Error(\"Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.\");return [4, this.handler.load()];case 1:\n            return e = r.sent(), t = compiled_api_1.GraphDef.decode(new Uint8Array(e.modelTopology)), this.version = t.versions.producer + \".\" + t.versions.minConsumer, a = _tfjsCore.io.decodeWeights(e.weightData, e.weightSpecs), this.executor = new GraphExecutor(OperationMapper.Instance.transformGraph(t)), this.executor.weightMap = this.convertTensorMapToTensorsMap(a), [2, !0];}\n      });\n    });\n  }, e.prototype.predict = function (e, t) {\n    return this.execute_(e, !0, this.outputNodes);\n  }, e.prototype.constructTensorMap = function (e) {\n    var t = e instanceof _tfjsCore.Tensor ? [e] : e;if (t.length !== this.inputNodes.length) throw new Error(\"Input tensor count mismatch,the frozen model has \" + this.inputNodes.length + \" placeholders, while there are \" + t.length + \" input tensors.\");return this.inputNodes.reduce(function (e, a, r) {\n      return e[a] = t[r], e;\n    }, {});\n  }, e.prototype.execute = function (e, t) {\n    return this.execute_(e, !1, t);\n  }, e.prototype.execute_ = function (e, t, a) {\n    if (void 0 === t && (t = !0), a = a || this.outputNodes, (e instanceof _tfjsCore.Tensor || Array.isArray(e)) && (e = this.constructTensorMap(e)), this.executor.isControlFlowModel || this.executor.isDynamicShapeModel) throw new Error(\"The model contains control flow or dynamic shape ops, please use executeAsync method\");var r = this.executor.execute(this.convertTensorMapToTensorsMap(e), t, a),\n        n = Object.keys(r);return Array.isArray(a) && a.length > 1 ? a.map(function (e) {\n      return r[e];\n    }) : r[n[0]];\n  }, e.prototype.executeAsync = function (e, t) {\n    return __awaiter(this, void 0, void 0, function () {\n      var a, r;return __generator(this, function (n) {\n        switch (n.label) {case 0:\n            if (!this.executor.isControlFlowModel && !this.executor.isDynamicShapeModel) throw new Error(\"The model does not contain control flow or dynamic shape ops, please use execute method for better performance.\");return t = t || this.outputNodes, (e instanceof _tfjsCore.Tensor || Array.isArray(e)) && (e = this.constructTensorMap(e)), [4, this.executor.executeAsync(this.convertTensorMapToTensorsMap(e), t)];case 1:\n            return a = n.sent(), r = Object.keys(a), [2, Array.isArray(t) && t.length > 1 ? t.map(function (e) {\n              return a[e];\n            }) : a[r[0]]];}\n      });\n    });\n  }, e.prototype.convertTensorMapToTensorsMap = function (e) {\n    return Object.keys(e).reduce(function (t, a) {\n      return t[a] = [e[a]], t;\n    }, {});\n  }, e.prototype.dispose = function () {\n    this.executor.dispose();\n  }, e;\n}();function loadFrozenModel(e, t, a) {\n  return __awaiter(this, void 0, void 0, function () {\n    var r;return __generator(this, function (n) {\n      switch (n.label) {case 0:\n          return [4, (r = new FrozenModel(e, t, a)).load()];case 1:\n          return n.sent(), [2, r];}\n    });\n  });\n}var version = \"0.6.0\";exports.FrozenModel = FrozenModel;\nexports.loadFrozenModel = loadFrozenModel;\nexports.version_converter = version;\n//# sourceMappingURL=tf-converter.esm.js.map"},"hash":"80224afc68d67bbe2430a9acde5e154f","cacheData":{"env":{}}}