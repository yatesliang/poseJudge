{"dependencies":[{"name":"/Users/chris/Desktop/因特尔杯/tfjs-models/posenet/demos/package.json","includedInParent":true,"mtime":1539397829000},{"name":"/Users/chris/Desktop/因特尔杯/tfjs-models/posenet/demos/.babelrc","includedInParent":true,"mtime":1539397829000},{"name":"/Users/chris/Desktop/因特尔杯/tfjs-models/posenet/demos/node_modules/@tensorflow/tfjs-core/package.json","includedInParent":true,"mtime":1541754030180},{"name":"crypto","optional":true,"loc":{"line":17,"column":197865}},{"name":"process"},{"name":"buffer"}],"generated":{"js":"var process = require(\"process\");\nvar global = (1,eval)(\"this\");\nvar Buffer = require(\"buffer\").Buffer;\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (e, t) {\n  e.__proto__ = t;\n} || function (e, t) {\n  for (var n in t) t.hasOwnProperty(n) && (e[n] = t[n]);\n};function __extends(e, t) {\n  function n() {\n    this.constructor = e;\n  }extendStatics(e, t), e.prototype = null === t ? Object.create(t) : (n.prototype = t.prototype, new n());\n}var __assign = Object.assign || function (e) {\n  for (var t, n = 1, r = arguments.length; n < r; n++) for (var o in t = arguments[n]) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);return e;\n};function __awaiter(e, t, n, r) {\n  return new (n || (n = Promise))(function (o, a) {\n    function i(e) {\n      try {\n        u(r.next(e));\n      } catch (e) {\n        a(e);\n      }\n    }function s(e) {\n      try {\n        u(r.throw(e));\n      } catch (e) {\n        a(e);\n      }\n    }function u(e) {\n      e.done ? o(e.value) : new n(function (t) {\n        t(e.value);\n      }).then(i, s);\n    }u((r = r.apply(e, t || [])).next());\n  });\n}function __generator(e, t) {\n  var n,\n      r,\n      o,\n      a,\n      i = { label: 0, sent: function () {\n      if (1 & o[0]) throw o[1];return o[1];\n    }, trys: [], ops: [] };return a = { next: s(0), throw: s(1), return: s(2) }, \"function\" == typeof Symbol && (a[Symbol.iterator] = function () {\n    return this;\n  }), a;function s(a) {\n    return function (s) {\n      return function (a) {\n        if (n) throw new TypeError(\"Generator is already executing.\");for (; i;) try {\n          if (n = 1, r && (o = 2 & a[0] ? r.return : a[0] ? r.throw || ((o = r.return) && o.call(r), 0) : r.next) && !(o = o.call(r, a[1])).done) return o;switch (r = 0, o && (a = [2 & a[0], o.value]), a[0]) {case 0:case 1:\n              o = a;break;case 4:\n              return i.label++, { value: a[1], done: !1 };case 5:\n              i.label++, r = a[1], a = [0];continue;case 7:\n              a = i.ops.pop(), i.trys.pop();continue;default:\n              if (!(o = (o = i.trys).length > 0 && o[o.length - 1]) && (6 === a[0] || 2 === a[0])) {\n                i = 0;continue;\n              }if (3 === a[0] && (!o || a[1] > o[0] && a[1] < o[3])) {\n                i.label = a[1];break;\n              }if (6 === a[0] && i.label < o[1]) {\n                i.label = o[1], o = a;break;\n              }if (o && i.label < o[2]) {\n                i.label = o[2], i.ops.push(a);break;\n              }o[2] && i.ops.pop(), i.trys.pop();continue;}a = t.call(e, i);\n        } catch (e) {\n          a = [6, e], r = 0;\n        } finally {\n          n = o = 0;\n        }if (5 & a[0]) throw a[1];return { value: a[0] ? a[1] : void 0, done: !0 };\n      }([a, s]);\n    };\n  }\n}function isMobile() {\n  var e = navigator.userAgent || navigator.vendor || window.opera;return (/(android|bb\\d+|meego).+mobile|avantgo|bada\\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(e) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\\-(n|u)|c55\\/|capi|ccwa|cdm\\-|cell|chtm|cldc|cmd\\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\\-s|devi|dica|dmob|do(c|p)o|ds(12|\\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\\-|_)|g1 u|g560|gene|gf\\-5|g\\-mo|go(\\.w|od)|gr(ad|un)|haie|hcit|hd\\-(m|p|t)|hei\\-|hi(pt|ta)|hp( i|ip)|hs\\-c|ht(c(\\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\\-(20|go|ma)|i230|iac( |\\-|\\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\\/)|klon|kpt |kwc\\-|kyo(c|k)|le(no|xi)|lg( g|\\/(k|l|u)|50|54|\\-[a-w])|libw|lynx|m1\\-w|m3ga|m50\\/|ma(te|ui|xo)|mc(01|21|ca)|m\\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\\-2|po(ck|rt|se)|prox|psio|pt\\-g|qa\\-a|qc(07|12|21|32|60|\\-[2-7]|i\\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\\-|oo|p\\-)|sdk\\/|se(c(\\-|0|1)|47|mc|nd|ri)|sgh\\-|shar|sie(\\-|m)|sk\\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\\-|v\\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\\-|tdg\\-|tel(i|m)|tim\\-|t\\-mo|to(pl|sh)|ts(70|m\\-|m3|m5)|tx\\-9|up(\\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\\-|your|zeto|zte\\-/i.test(e.substr(0, 4))\n  );\n}function shuffle(e) {\n  for (var t = e.length, n = 0, r = 0; t > 0;) r = Math.random() * t | 0, n = e[--t], e[t] = e[r], e[r] = n;\n}function clamp(e, t, n) {\n  return Math.max(e, Math.min(t, n));\n}function randUniform(e, t) {\n  var n = Math.random();return t * n + (1 - n) * e;\n}function distSquared(e, t) {\n  for (var n = 0, r = 0; r < e.length; r++) {\n    var o = Number(e[r]) - Number(t[r]);n += o * o;\n  }return n;\n}function assert(e, t) {\n  if (!e) throw new Error(\"string\" == typeof t ? t : t());\n}function assertShapesMatch(e, t, n) {\n  void 0 === n && (n = \"\"), assert(arraysEqual(e, t), n + \" Shapes \" + e + \" and \" + t + \" must match\");\n}function assertNonNull(e) {\n  assert(null != e, \"The input to the tensor constructor must be a non-null value.\");\n}function flatten(e, t) {\n  if (void 0 === t && (t = []), Array.isArray(e)) for (var n = 0; n < e.length; ++n) flatten(e[n], t);else t.push(e);return t;\n}function inferShape(e) {\n  var t = e;if (isTypedArray(e)) return [e.length];if (!Array.isArray(e)) return [];for (var n = []; t instanceof Array;) n.push(t.length), t = t[0];return e instanceof Array && deepAssertShapeConsistency(e, n, []), n;\n}function deepAssertShapeConsistency(e, t, n) {\n  if (n = n || [], e instanceof Array) {\n    assert(t.length > 0, function () {\n      return \"Element arr[\" + n.join(\"][\") + \"] should be a primitive, but is an array of \" + e.length + \" elements\";\n    }), assert(e.length === t[0], function () {\n      return \"Element arr[\" + n.join(\"][\") + \"] should have \" + t[0] + \" elements, but has \" + e.length + \" elements\";\n    });for (var r = t.slice(1), o = 0; o < e.length; ++o) deepAssertShapeConsistency(e[o], r, n.concat(o));\n  } else assert(0 === t.length, function () {\n    return \"Element arr[\" + n.join(\"][\") + \"] is a primitive, but should be an array of \" + t[0] + \" elements\";\n  });\n}function sizeFromShape(e) {\n  if (0 === e.length) return 1;for (var t = e[0], n = 1; n < e.length; n++) t *= e[n];return t;\n}function isScalarShape(e) {\n  return 0 === e.length;\n}function arraysEqual(e, t) {\n  if (e.length !== t.length) return !1;for (var n = 0; n < e.length; n++) if (e[n] !== t[n]) return !1;return !0;\n}function isInt(e) {\n  return e % 1 == 0;\n}function tanh(e) {\n  if (null != Math.tanh) return Math.tanh(e);if (e === 1 / 0) return 1;if (e === -1 / 0) return -1;var t = Math.exp(2 * e);return (t - 1) / (t + 1);\n}function sizeToSquarishShape(e) {\n  for (var t = Math.floor(Math.sqrt(e)); t > 1; --t) if (e % t == 0) return [t, e / t];return [1, e];\n}function createShuffledIndices(e) {\n  for (var t = new Uint32Array(e), n = 0; n < e; ++n) t[n] = n;return shuffle(t), t;\n}function rightPad(e, t) {\n  return t <= e.length ? e : e + \" \".repeat(t - e.length);\n}function repeatedTry(e, t, n) {\n  return void 0 === t && (t = function (e) {\n    return 0;\n  }), new Promise(function (r, o) {\n    var a = 0,\n        i = function () {\n      if (e()) r();else {\n        var s = t(++a);null != n && a >= n ? o() : setTimeout(i, s);\n      }\n    };i();\n  });\n}function inferFromImplicitShape(e, t) {\n  for (var n = 1, r = -1, o = 0; o < e.length; ++o) if (e[o] >= 0) n *= e[o];else if (-1 === e[o]) {\n    if (-1 !== r) throw Error(\"Shapes can only have 1 implicit size. Found -1 at dim \" + r + \" and dim \" + o);r = o;\n  } else if (e[o] < 0) throw Error(\"Shapes can not be < 0. Found \" + e[o] + \" at dim \" + o);if (-1 === r) {\n    if (t > 0 && t !== n) throw Error(\"Size(\" + t + \") must match the product of shape \" + e);return e;\n  }if (0 === n) throw Error(\"Cannot infer the missing size in [\" + e + \"] when there are 0 elements\");if (t % n != 0) throw Error(\"The implicit shape can't be a fractional number. Got \" + t + \" / \" + n);var a = e.slice();return a[r] = t / n, a;\n}function squeezeShape(e, t) {\n  for (var n = [], r = [], o = 0, a = 0; a < e.length; ++a) {\n    if (null != t) {\n      if (t[o] === a && 1 !== e[a]) throw new Error(\"Can't squeeze axis \" + a + \" since its dim '\" + e[a] + \"' is not 1\");(null == t[o] || t[o] > a) && 1 === e[a] && (n.push(e[a]), r.push(a)), t[o] <= a && o++;\n    }1 !== e[a] && (n.push(e[a]), r.push(a));\n  }return { newShape: n, keptDims: r };\n}function getTypedArrayFromDType(e, t) {\n  var n = null;if (null == e || \"float32\" === e) n = new Float32Array(t);else if (\"int32\" === e) n = new Int32Array(t);else {\n    if (\"bool\" !== e) throw new Error(\"Unknown data type \" + e);n = new Uint8Array(t);\n  }return n;\n}function checkComputationForNaN(e, t, n) {\n  if (\"float32\" === t) for (var r = 0; r < e.length; r++) if (isNaN(e[r])) throw Error(\"The result of the '\" + n + \"' has NaNs.\");\n}function checkConversionForNaN(e, t) {\n  if (\"float32\" !== t) for (var n = 0; n < e.length; n++) if (isNaN(e[n])) throw Error(\"NaN is not a valid value for dtype: '\" + t + \"'.\");\n}function hasEncodingLoss(e, t) {\n  return \"complex64\" !== t && (\"float32\" !== t || \"complex64\" === e) && (\"int32\" !== t || \"float32\" === e || \"complex64\" === e) && (\"bool\" !== t || \"bool\" !== e);\n}function copyTypedArray(e, t, n) {\n  if (null == t || \"float32\" === t || \"complex64\" === t) return new Float32Array(e);if (\"int32\" === t) return n && checkConversionForNaN(e, t), new Int32Array(e);if (\"bool\" === t) {\n    for (var r = new Uint8Array(e.length), o = 0; o < r.length; ++o) 0 !== Math.round(e[o]) && (r[o] = 1);return r;\n  }throw new Error(\"Unknown data type \" + t);\n}function isTypedArray(e) {\n  return e instanceof Float32Array || e instanceof Int32Array || e instanceof Uint8Array;\n}function bytesPerElement(e) {\n  if (\"float32\" === e || \"int32\" === e) return 4;if (\"complex64\" === e) return 8;if (\"bool\" === e) return 1;throw new Error(\"Unknown dtype \" + e);\n}function isFunction(e) {\n  return !!(e && e.constructor && e.call && e.apply);\n}function nearestDivisor(e, t) {\n  for (var n = t; n < e; ++n) if (e % n == 0) return n;return e;\n}function computeStrides(e) {\n  var t = e.length;if (t < 2) return [];var n = new Array(t - 1);n[t - 2] = e[t - 1];for (var r = t - 3; r >= 0; --r) n[r] = n[r + 1] * e[r + 1];return n;\n}function toTypedArray(e, t, n) {\n  return noConversionNeeded(e, t) ? e : (Array.isArray(e) && (e = flatten(e)), copyTypedArray(e, t, n));\n}function noConversionNeeded(e, t) {\n  return e instanceof Float32Array && \"float32\" === t || e instanceof Int32Array && \"int32\" === t || e instanceof Uint8Array && \"bool\" === t;\n}function makeOnesTypedArray(e, t) {\n  for (var n = makeZerosTypedArray(e, t), r = 0; r < n.length; r++) n[r] = 1;return n;\n}function makeZerosTypedArray(e, t) {\n  if (null == t || \"float32\" === t || \"complex64\" === t) return new Float32Array(e);if (\"int32\" === t) return new Int32Array(e);if (\"bool\" === t) return new Uint8Array(e);throw new Error(\"Unknown data type \" + t);\n}function now() {\n  if (\"undefined\" != typeof performance) return performance.now();if (\"undefined\" != typeof process) {\n    var e = process.hrtime();return 1e3 * e[0] + e[1] / 1e6;\n  }throw new Error(\"Cannot measure time in this environment. You should run tf.js in the browser or in Node.js\");\n}var util = Object.freeze({ shuffle: shuffle, clamp: clamp, randUniform: randUniform, distSquared: distSquared, assert: assert, assertShapesMatch: assertShapesMatch, assertNonNull: assertNonNull, flatten: flatten, inferShape: inferShape, sizeFromShape: sizeFromShape, isScalarShape: isScalarShape, arraysEqual: arraysEqual, isInt: isInt, tanh: tanh, sizeToSquarishShape: sizeToSquarishShape, createShuffledIndices: createShuffledIndices, rightPad: rightPad, repeatedTry: repeatedTry, inferFromImplicitShape: inferFromImplicitShape, squeezeShape: squeezeShape, getTypedArrayFromDType: getTypedArrayFromDType, checkComputationForNaN: checkComputationForNaN, checkConversionForNaN: checkConversionForNaN, hasEncodingLoss: hasEncodingLoss, isTypedArray: isTypedArray, bytesPerElement: bytesPerElement, isFunction: isFunction, nearestDivisor: nearestDivisor, computeStrides: computeStrides, toTypedArray: toTypedArray, makeOnesTypedArray: makeOnesTypedArray, makeZerosTypedArray: makeZerosTypedArray, now: now }),\n    Profiler = function () {\n  function e(e, t) {\n    this.backendTimer = e, this.logger = t, null == t && (this.logger = new Logger());\n  }return e.prototype.profileKernel = function (e, t) {\n    var n,\n        r = this,\n        o = this.backendTimer.time(function () {\n      n = t();\n    });return (Array.isArray(n) ? n : [n]).forEach(function (t) {\n      var n = t.dataSync();checkComputationForNaN(n, t.dtype, e), o.then(function (o) {\n        r.logger.logKernelProfile(e, t, n, o.kernelMs);\n      });\n    }), n;\n  }, e;\n}(),\n    Logger = function () {\n  function e() {}return e.prototype.logKernelProfile = function (e, t, n, r) {\n    var o = rightPad(r + \"ms\", 9),\n        a = rightPad(e, 25),\n        i = t.rank,\n        s = t.size,\n        u = rightPad(t.shape.toString(), 14);console.log(\"%c\" + a + \"\\t%c\" + o + \"\\t%c\" + i + \"D \" + u + \"\\t%c\" + s, \"font-weight:bold\", \"color:red\", \"color:blue\", \"color: orange\");\n  }, e;\n}(),\n    FORMAT_LIMIT_NUM_VALS = 20,\n    FORMAT_NUM_FIRST_LAST_VALS = 3,\n    FORMAT_NUM_SIG_DIGITS = 7;function tensorToString(e, t, n, r) {\n  var o = computeStrides(t),\n      a = computeMaxSizePerColumn(e, t, n, o),\n      i = t.length,\n      s = subTensorToString(e, t, n, o, a),\n      u = [\"Tensor\"];return r && (u.push(\"  dtype: \" + n), u.push(\"  rank: \" + i), u.push(\"  shape: [\" + t + \"]\"), u.push(\"  values:\")), u.push(s.map(function (e) {\n    return \"    \" + e;\n  }).join(\"\\n\")), u.join(\"\\n\");\n}function computeMaxSizePerColumn(e, t, n, r) {\n  var o = sizeFromShape(t),\n      a = r[r.length - 1],\n      i = new Array(a).fill(0),\n      s = t.length,\n      u = \"complex64\" === n ? createComplexTuples(e) : e;if (s > 1) for (var l = 0; l < o / a; l++) for (var c = l * a, p = 0; p < a; p++) i[p] = Math.max(i[p], valToString(u[c + p], 0).length);return i;\n}function valToString(e, t) {\n  return rightPad(Array.isArray(e) ? parseFloat(e[0].toFixed(FORMAT_NUM_SIG_DIGITS)) + \" + \" + parseFloat(e[1].toFixed(FORMAT_NUM_SIG_DIGITS)) + \"j\" : parseFloat(e.toFixed(FORMAT_NUM_SIG_DIGITS)).toString(), t);\n}function subTensorToString(e, t, n, r, o, a) {\n  void 0 === a && (a = !0);var i = \"complex64\" === n ? 2 : 1,\n      s = t[0],\n      u = t.length;if (0 === u) return \"complex64\" === n ? [valToString(createComplexTuples(e)[0], 0)] : [e[0].toString()];if (1 === u) {\n    if (s > FORMAT_LIMIT_NUM_VALS) {\n      var l = FORMAT_NUM_FIRST_LAST_VALS * i,\n          c = Array.from(e.subarray(0, l)),\n          p = Array.from(e.subarray(s - FORMAT_NUM_FIRST_LAST_VALS * i, s));return \"complex64\" === n && (c = createComplexTuples(c), p = createComplexTuples(p)), [\"[\" + c.map(function (e, t) {\n        return valToString(e, o[t]);\n      }).join(\", \") + \", ..., \" + p.map(function (e, t) {\n        return valToString(e, o[s - FORMAT_NUM_FIRST_LAST_VALS + t]);\n      }).join(\", \") + \"]\"];\n    }return [\"[\" + (\"complex64\" === n ? createComplexTuples(e) : Array.from(e)).map(function (e, t) {\n      return valToString(e, o[t]);\n    }).join(\", \") + \"]\"];\n  }var d = t.slice(1),\n      h = r.slice(1),\n      f = r[0] * i,\n      m = [];if (s > FORMAT_LIMIT_NUM_VALS) {\n    for (var g = 0; g < FORMAT_NUM_FIRST_LAST_VALS; g++) {\n      var v = (x = g * f) + f;m.push.apply(m, subTensorToString(e.subarray(x, v), d, n, h, o, !1));\n    }m.push(\"...\");for (g = s - FORMAT_NUM_FIRST_LAST_VALS; g < s; g++) {\n      v = (x = g * f) + f;m.push.apply(m, subTensorToString(e.subarray(x, v), d, n, h, o, g === s - 1));\n    }\n  } else for (g = 0; g < s; g++) {\n    var x;v = (x = g * f) + f;m.push.apply(m, subTensorToString(e.subarray(x, v), d, n, h, o, g === s - 1));\n  }var y = 2 === u ? \",\" : \"\";m[0] = \"[\" + m[0] + y;for (g = 1; g < m.length - 1; g++) m[g] = \" \" + m[g] + y;var T = \",\\n\";for (g = 2; g < u; g++) T += \"\\n\";return m[m.length - 1] = \" \" + m[m.length - 1] + \"]\" + (a ? \"\" : T), m;\n}function createComplexTuples(e) {\n  for (var t = [], n = 0; n < e.length; n += 2) t.push([e[n], e[n + 1]]);return t;\n}var TensorBuffer = function () {\n  function e(e, t, n) {\n    if (this.dtype = t, this.shape = e.slice(), this.size = sizeFromShape(e), null != n) {\n      var r = n.length;assert(r === this.size, \"Length of values '\" + r + \"' does not match the size inferred by the shape '\" + this.size + \"'.\");\n    }if (\"complex64\" === t) throw new Error(\"complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).\");this.values = n || getTypedArrayFromDType(t, sizeFromShape(this.shape)), this.strides = computeStrides(e);\n  }return e.prototype.set = function (e) {\n    for (var t = [], n = 1; n < arguments.length; n++) t[n - 1] = arguments[n];0 === t.length && (t = [0]), assert(t.length === this.rank, \"The number of provided coordinates (\" + t.length + \") must match the rank (\" + this.rank + \")\");var r = this.locToIndex(t);this.values[r] = e;\n  }, e.prototype.get = function () {\n    for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];0 === e.length && (e = [0]);for (var n = e[e.length - 1], r = 0; r < e.length - 1; ++r) n += this.strides[r] * e[r];return this.values[n];\n  }, e.prototype.locToIndex = function (e) {\n    if (0 === this.rank) return 0;if (1 === this.rank) return e[0];for (var t = e[e.length - 1], n = 0; n < e.length - 1; ++n) t += this.strides[n] * e[n];return t;\n  }, e.prototype.indexToLoc = function (e) {\n    if (0 === this.rank) return [];if (1 === this.rank) return [e];for (var t = new Array(this.shape.length), n = 0; n < t.length - 1; ++n) t[n] = Math.floor(e / this.strides[n]), e -= t[n] * this.strides[n];return t[t.length - 1] = e, t;\n  }, Object.defineProperty(e.prototype, \"rank\", { get: function () {\n      return this.shape.length;\n    }, enumerable: !0, configurable: !0 }), e.prototype.toTensor = function () {\n    return Tensor.make(this.shape, { values: this.values }, this.dtype);\n  }, e;\n}(),\n    trackerFn = null,\n    opHandler = null;function setTensorTracker(e) {\n  trackerFn = e;\n}function setOpHandler(e) {\n  opHandler = e;\n}var Tensor = function () {\n  function e(t, n, r, o) {\n    this.isDisposedInternal = !1, this.shape = t.slice(), this.dtype = n || \"float32\", this.size = sizeFromShape(t), null != r && assert(this.size === r.length, \"Based on the provided shape, [\" + t + \"], and dtype \" + this.dtype + \", the tensor should have \" + this.size + \" values but has \" + r.length), this.strides = computeStrides(t), this.dataId = null != o ? o : {}, this.id = e.nextId++, this.rankType = this.rank < 5 ? this.rank.toString() : \"higher\", trackerFn().registerTensor(this), null != r && trackerFn().write(this.dataId, r);\n  }return e.make = function (t, n, r) {\n    return new e(t, r, n.values, n.dataId);\n  }, e.prototype.flatten = function () {\n    return this.throwIfDisposed(), this.as1D();\n  }, e.prototype.asScalar = function () {\n    return this.throwIfDisposed(), assert(1 === this.size, \"The array must have only 1 element.\"), this.reshape([]);\n  }, e.prototype.as1D = function () {\n    return this.throwIfDisposed(), this.reshape([this.size]);\n  }, e.prototype.as2D = function (e, t) {\n    return this.throwIfDisposed(), this.reshape([e, t]);\n  }, e.prototype.as3D = function (e, t, n) {\n    return this.throwIfDisposed(), this.reshape([e, t, n]);\n  }, e.prototype.as4D = function (e, t, n, r) {\n    return this.throwIfDisposed(), this.reshape([e, t, n, r]);\n  }, e.prototype.asType = function (e) {\n    return this.throwIfDisposed(), opHandler.cast(this, e);\n  }, Object.defineProperty(e.prototype, \"rank\", { get: function () {\n      return this.shape.length;\n    }, enumerable: !0, configurable: !0 }), e.prototype.get = function () {\n    for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];assert(e.length === this.rank, \"Number of coordinates in get() must match the rank of the tensor\"), assert(\"complex64\" !== this.dtype, \"Tensor.get() is not supported for complex64 tensors yet.\"), this.throwIfDisposed(), 0 === e.length && (e = [0]);for (var n = e[e.length - 1], r = 0; r < e.length - 1; ++r) n += this.strides[r] * e[r];return this.dataSync()[n];\n  }, e.prototype.buffer = function () {\n    return opHandler.buffer(this.shape, this.dtype, this.dataSync());\n  }, e.prototype.data = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (e) {\n        return this.throwIfDisposed(), [2, trackerFn().read(this.dataId)];\n      });\n    });\n  }, e.prototype.dataSync = function () {\n    return this.throwIfDisposed(), trackerFn().readSync(this.dataId);\n  }, e.prototype.dispose = function () {\n    this.isDisposed || (trackerFn().disposeTensor(this), this.isDisposedInternal = !0);\n  }, Object.defineProperty(e.prototype, \"isDisposed\", { get: function () {\n      return this.isDisposedInternal;\n    }, enumerable: !0, configurable: !0 }), e.prototype.throwIfDisposed = function () {\n    if (this.isDisposed) throw new Error(\"Tensor is disposed.\");\n  }, e.prototype.toFloat = function () {\n    return this.asType(\"float32\");\n  }, e.prototype.toInt = function () {\n    return this.asType(\"int32\");\n  }, e.prototype.toBool = function () {\n    return this.asType(\"bool\");\n  }, e.prototype.print = function (e) {\n    return void 0 === e && (e = !1), opHandler.print(this, e);\n  }, e.prototype.reshape = function (e) {\n    return this.throwIfDisposed(), opHandler.reshape(this, e);\n  }, e.prototype.reshapeAs = function (e) {\n    return this.throwIfDisposed(), this.reshape(e.shape);\n  }, e.prototype.expandDims = function (e) {\n    return void 0 === e && (e = 0), opHandler.expandDims(this, e);\n  }, e.prototype.cumsum = function (e, t, n) {\n    return void 0 === e && (e = 0), void 0 === t && (t = !1), void 0 === n && (n = !1), opHandler.cumsum(this, e, t, n);\n  }, e.prototype.squeeze = function (e) {\n    return this.throwIfDisposed(), opHandler.squeeze(this, e);\n  }, e.prototype.clone = function () {\n    return this.throwIfDisposed(), opHandler.clone(this);\n  }, e.prototype.toString = function (e) {\n    return void 0 === e && (e = !1), tensorToString(this.dataSync(), this.shape, this.dtype, e);\n  }, e.prototype.tile = function (e) {\n    return this.throwIfDisposed(), opHandler.tile(this, e);\n  }, e.prototype.gather = function (e, t) {\n    return void 0 === t && (t = 0), this.throwIfDisposed(), opHandler.gather(this, e, t);\n  }, e.prototype.matMul = function (e, t, n) {\n    return void 0 === t && (t = !1), void 0 === n && (n = !1), this.throwIfDisposed(), opHandler.matMul(this, e, t, n);\n  }, e.prototype.dot = function (e) {\n    return this.throwIfDisposed(), opHandler.dot(this, e);\n  }, e.prototype.norm = function (e, t, n) {\n    return void 0 === e && (e = \"euclidean\"), void 0 === t && (t = null), void 0 === n && (n = !1), this.throwIfDisposed(), opHandler.norm(this, e, t, n);\n  }, e.prototype.slice = function (e, t) {\n    return this.throwIfDisposed(), opHandler.slice(this, e, t);\n  }, e.prototype.reverse = function (e) {\n    return this.throwIfDisposed(), opHandler.reverse(this, e);\n  }, e.prototype.concat = function (e, t) {\n    return void 0 === t && (t = 0), this.throwIfDisposed(), opHandler.concat([this, e], t);\n  }, e.prototype.split = function (e, t) {\n    return void 0 === t && (t = 0), this.throwIfDisposed(), opHandler.split(this, e, t);\n  }, e.prototype.stack = function (e, t) {\n    return void 0 === t && (t = 0), opHandler.stack([this, e], t);\n  }, e.prototype.unstack = function (e, t) {\n    return void 0 === t && (t = 0), opHandler.unstack(this, t);\n  }, e.prototype.pad = function (e, t) {\n    return void 0 === t && (t = 0), opHandler.pad(this, e, t);\n  }, e.prototype.batchNormalization = function (e, t, n, r, o) {\n    return void 0 === n && (n = .001), this.throwIfDisposed(), opHandler.batchNormalization(this, e, t, n, r, o);\n  }, e.prototype.all = function (e, t) {\n    return void 0 === e && (e = null), void 0 === t && (t = !1), this.throwIfDisposed(), opHandler.all(this, e, t);\n  }, e.prototype.any = function (e, t) {\n    return void 0 === e && (e = null), void 0 === t && (t = !1), this.throwIfDisposed(), opHandler.any(this, e, t);\n  }, e.prototype.logSumExp = function (e, t) {\n    return void 0 === e && (e = null), void 0 === t && (t = !1), this.throwIfDisposed(), opHandler.logSumExp(this, e, t);\n  }, e.prototype.sum = function (e, t) {\n    return void 0 === e && (e = null), void 0 === t && (t = !1), this.throwIfDisposed(), opHandler.sum(this, e, t);\n  }, e.prototype.mean = function (e, t) {\n    return void 0 === e && (e = null), void 0 === t && (t = !1), this.throwIfDisposed(), opHandler.mean(this, e, t);\n  }, e.prototype.min = function (e, t) {\n    return void 0 === e && (e = null), void 0 === t && (t = !1), this.throwIfDisposed(), opHandler.min(this, e, t);\n  }, e.prototype.max = function (e, t) {\n    return void 0 === e && (e = null), void 0 === t && (t = !1), this.throwIfDisposed(), opHandler.max(this, e, t);\n  }, e.prototype.argMin = function (e) {\n    return void 0 === e && (e = null), this.throwIfDisposed(), opHandler.argMin(this, e);\n  }, e.prototype.argMax = function (e) {\n    return void 0 === e && (e = null), this.throwIfDisposed(), opHandler.argMax(this, e);\n  }, e.prototype.cast = function (e) {\n    return this.throwIfDisposed(), opHandler.cast(this, e);\n  }, e.prototype.add = function (e) {\n    return this.throwIfDisposed(), opHandler.add(this, e);\n  }, e.prototype.addStrict = function (e) {\n    return this.throwIfDisposed(), opHandler.addStrict(this, e);\n  }, e.prototype.atan2 = function (e) {\n    return this.throwIfDisposed(), opHandler.atan2(this, e);\n  }, e.prototype.sub = function (e) {\n    return this.throwIfDisposed(), opHandler.sub(this, e);\n  }, e.prototype.subStrict = function (e) {\n    return this.throwIfDisposed(), opHandler.subStrict(this, e);\n  }, e.prototype.pow = function (e) {\n    return this.throwIfDisposed(), opHandler.pow(this, e);\n  }, e.prototype.powStrict = function (e) {\n    return this.throwIfDisposed(), opHandler.powStrict(this, e);\n  }, e.prototype.mul = function (e) {\n    return this.throwIfDisposed(), opHandler.mul(this, e);\n  }, e.prototype.mulStrict = function (e) {\n    return this.throwIfDisposed(), opHandler.mulStrict(this, e);\n  }, e.prototype.div = function (e) {\n    return this.throwIfDisposed(), opHandler.div(this, e);\n  }, e.prototype.floorDiv = function (e) {\n    return this.throwIfDisposed(), opHandler.floorDiv(this, e);\n  }, e.prototype.divStrict = function (e) {\n    return this.throwIfDisposed(), opHandler.divStrict(this, e);\n  }, e.prototype.minimum = function (e) {\n    return this.throwIfDisposed(), opHandler.minimum(this, e);\n  }, e.prototype.minimumStrict = function (e) {\n    return this.throwIfDisposed(), opHandler.minimumStrict(this, e);\n  }, e.prototype.maximum = function (e) {\n    return this.throwIfDisposed(), opHandler.maximum(this, e);\n  }, e.prototype.maximumStrict = function (e) {\n    return this.throwIfDisposed(), opHandler.maximumStrict(this, e);\n  }, e.prototype.mod = function (e) {\n    return this.throwIfDisposed(), opHandler.mod(this, e);\n  }, e.prototype.modStrict = function (e) {\n    return this.throwIfDisposed(), opHandler.modStrict(this, e);\n  }, e.prototype.squaredDifference = function (e) {\n    return this.throwIfDisposed(), opHandler.squaredDifference(this, e);\n  }, e.prototype.squaredDifferenceStrict = function (e) {\n    return this.throwIfDisposed(), opHandler.squaredDifferenceStrict(this, e);\n  }, e.prototype.transpose = function (e) {\n    return this.throwIfDisposed(), opHandler.transpose(this, e);\n  }, e.prototype.notEqual = function (e) {\n    return this.throwIfDisposed(), opHandler.notEqual(this, e);\n  }, e.prototype.notEqualStrict = function (e) {\n    return this.throwIfDisposed(), opHandler.notEqualStrict(this, e);\n  }, e.prototype.less = function (e) {\n    return this.throwIfDisposed(), opHandler.less(this, e);\n  }, e.prototype.lessStrict = function (e) {\n    return this.throwIfDisposed(), opHandler.lessStrict(this, e);\n  }, e.prototype.equal = function (e) {\n    return this.throwIfDisposed(), opHandler.equal(this, e);\n  }, e.prototype.equalStrict = function (e) {\n    return this.throwIfDisposed(), opHandler.equalStrict(this, e);\n  }, e.prototype.lessEqual = function (e) {\n    return this.throwIfDisposed(), opHandler.lessEqual(this, e);\n  }, e.prototype.lessEqualStrict = function (e) {\n    return this.throwIfDisposed(), opHandler.lessEqualStrict(this, e);\n  }, e.prototype.greater = function (e) {\n    return this.throwIfDisposed(), opHandler.greater(this, e);\n  }, e.prototype.greaterStrict = function (e) {\n    return this.throwIfDisposed(), opHandler.greaterStrict(this, e);\n  }, e.prototype.greaterEqual = function (e) {\n    return this.throwIfDisposed(), opHandler.greaterEqual(this, e);\n  }, e.prototype.greaterEqualStrict = function (e) {\n    return this.throwIfDisposed(), opHandler.greaterEqualStrict(this, e);\n  }, e.prototype.logicalAnd = function (e) {\n    return this.throwIfDisposed(), opHandler.logicalAnd(this, e);\n  }, e.prototype.logicalOr = function (e) {\n    return this.throwIfDisposed(), opHandler.logicalOr(this, e);\n  }, e.prototype.logicalNot = function () {\n    return this.throwIfDisposed(), opHandler.logicalNot(this);\n  }, e.prototype.logicalXor = function (e) {\n    return this.throwIfDisposed(), opHandler.logicalXor(this, e);\n  }, e.prototype.where = function (e, t) {\n    return this.throwIfDisposed(), opHandler.where(e, this, t);\n  }, e.prototype.neg = function () {\n    return this.throwIfDisposed(), opHandler.neg(this);\n  }, e.prototype.ceil = function () {\n    return this.throwIfDisposed(), opHandler.ceil(this);\n  }, e.prototype.floor = function () {\n    return this.throwIfDisposed(), opHandler.floor(this);\n  }, e.prototype.sign = function () {\n    return this.throwIfDisposed(), opHandler.sign(this);\n  }, e.prototype.exp = function () {\n    return this.throwIfDisposed(), opHandler.exp(this);\n  }, e.prototype.expm1 = function () {\n    return this.throwIfDisposed(), opHandler.expm1(this);\n  }, e.prototype.log = function () {\n    return this.throwIfDisposed(), opHandler.log(this);\n  }, e.prototype.log1p = function () {\n    return this.throwIfDisposed(), opHandler.log1p(this);\n  }, e.prototype.sqrt = function () {\n    return this.throwIfDisposed(), opHandler.sqrt(this);\n  }, e.prototype.rsqrt = function () {\n    return this.throwIfDisposed(), opHandler.rsqrt(this);\n  }, e.prototype.square = function () {\n    return this.throwIfDisposed(), opHandler.square(this);\n  }, e.prototype.reciprocal = function () {\n    return this.throwIfDisposed(), opHandler.reciprocal(this);\n  }, e.prototype.abs = function () {\n    return this.throwIfDisposed(), opHandler.abs(this);\n  }, e.prototype.clipByValue = function (e, t) {\n    return this.throwIfDisposed(), opHandler.clipByValue(this, e, t);\n  }, e.prototype.relu = function () {\n    return this.throwIfDisposed(), opHandler.relu(this);\n  }, e.prototype.elu = function () {\n    return this.throwIfDisposed(), opHandler.elu(this);\n  }, e.prototype.selu = function () {\n    return this.throwIfDisposed(), opHandler.selu(this);\n  }, e.prototype.leakyRelu = function (e) {\n    return void 0 === e && (e = .2), this.throwIfDisposed(), opHandler.leakyRelu(this, e);\n  }, e.prototype.prelu = function (e) {\n    return this.throwIfDisposed(), opHandler.prelu(this, e);\n  }, e.prototype.sigmoid = function () {\n    return this.throwIfDisposed(), opHandler.sigmoid(this);\n  }, e.prototype.logSigmoid = function () {\n    return this.throwIfDisposed(), opHandler.logSigmoid(this);\n  }, e.prototype.softplus = function () {\n    return this.throwIfDisposed(), opHandler.softplus(this);\n  }, e.prototype.zerosLike = function () {\n    return this.throwIfDisposed(), opHandler.zerosLike(this);\n  }, e.prototype.onesLike = function () {\n    return this.throwIfDisposed(), opHandler.onesLike(this);\n  }, e.prototype.sin = function () {\n    return this.throwIfDisposed(), opHandler.sin(this);\n  }, e.prototype.cos = function () {\n    return this.throwIfDisposed(), opHandler.cos(this);\n  }, e.prototype.tan = function () {\n    return this.throwIfDisposed(), opHandler.tan(this);\n  }, e.prototype.asin = function () {\n    return this.throwIfDisposed(), opHandler.asin(this);\n  }, e.prototype.acos = function () {\n    return this.throwIfDisposed(), opHandler.acos(this);\n  }, e.prototype.atan = function () {\n    return this.throwIfDisposed(), opHandler.atan(this);\n  }, e.prototype.sinh = function () {\n    return this.throwIfDisposed(), opHandler.sinh(this);\n  }, e.prototype.cosh = function () {\n    return this.throwIfDisposed(), opHandler.cosh(this);\n  }, e.prototype.tanh = function () {\n    return this.throwIfDisposed(), opHandler.tanh(this);\n  }, e.prototype.asinh = function () {\n    return this.throwIfDisposed(), opHandler.asinh(this);\n  }, e.prototype.acosh = function () {\n    return this.throwIfDisposed(), opHandler.acosh(this);\n  }, e.prototype.atanh = function () {\n    return this.throwIfDisposed(), opHandler.atanh(this);\n  }, e.prototype.erf = function () {\n    return this.throwIfDisposed(), opHandler.erf(this);\n  }, e.prototype.round = function () {\n    return this.throwIfDisposed(), opHandler.round(this);\n  }, e.prototype.step = function (e) {\n    return void 0 === e && (e = 0), this.throwIfDisposed(), opHandler.step(this, e);\n  }, e.prototype.softmax = function (e) {\n    return void 0 === e && (e = -1), this.throwIfDisposed(), opHandler.softmax(this, e);\n  }, e.prototype.resizeBilinear = function (e, t) {\n    return void 0 === t && (t = !1), this.throwIfDisposed(), opHandler.image.resizeBilinear(this, e, t);\n  }, e.prototype.resizeNearestNeighbor = function (e, t) {\n    return void 0 === t && (t = !1), this.throwIfDisposed(), opHandler.image.resizeNearestNeighbor(this, e, t);\n  }, e.prototype.conv1d = function (e, t, n, r, o, a) {\n    return void 0 === r && (r = \"NWC\"), void 0 === o && (o = 1), this.throwIfDisposed(), opHandler.conv1d(this, e, t, n, r, o, a);\n  }, e.prototype.conv2d = function (e, t, n, r, o, a) {\n    return void 0 === r && (r = \"NHWC\"), void 0 === o && (o = [1, 1]), this.throwIfDisposed(), opHandler.conv2d(this, e, t, n, r, o, a);\n  }, e.prototype.conv2dTranspose = function (e, t, n, r, o) {\n    return this.throwIfDisposed(), opHandler.conv2dTranspose(this, e, t, n, r, o);\n  }, e.prototype.depthwiseConv2D = function (e, t, n, r, o, a) {\n    return void 0 === r && (r = \"NHWC\"), void 0 === o && (o = [1, 1]), this.throwIfDisposed(), opHandler.depthwiseConv2d(this, e, t, n, r, o, a);\n  }, e.prototype.separableConv2d = function (e, t, n, r, o, a) {\n    return void 0 === o && (o = [1, 1]), void 0 === a && (a = \"NHWC\"), this.throwIfDisposed(), opHandler.separableConv2d(this, e, t, n, r, o, a);\n  }, e.prototype.avgPool = function (e, t, n, r) {\n    return this.throwIfDisposed(), opHandler.avgPool(this, e, t, n, r);\n  }, e.prototype.maxPool = function (e, t, n, r) {\n    return this.throwIfDisposed(), opHandler.maxPool(this, e, t, n, r);\n  }, e.prototype.localResponseNormalization = function (e, t, n, r) {\n    return void 0 === e && (e = 5), void 0 === t && (t = 1), void 0 === n && (n = 1), void 0 === r && (r = .5), opHandler.localResponseNormalization(this, e, t, n, r);\n  }, e.prototype.variable = function (e, t, n) {\n    return void 0 === e && (e = !0), this.throwIfDisposed(), Variable.variable(this, e, t, n);\n  }, e.prototype.unsortedSegmentSum = function (e, t) {\n    return this.throwIfDisposed(), opHandler.unsortedSegmentSum(this, e, t);\n  }, e.prototype.batchToSpaceND = function (e, t) {\n    return this.throwIfDisposed(), opHandler.batchToSpaceND(this, e, t);\n  }, e.prototype.spaceToBatchND = function (e, t) {\n    return this.throwIfDisposed(), opHandler.spaceToBatchND(this, e, t);\n  }, e.prototype.topk = function (e, t) {\n    return void 0 === e && (e = 1), void 0 === t && (t = !0), this.throwIfDisposed(), opHandler.topk(this, e, t);\n  }, e.prototype.stridedSlice = function (e, t, n, r, o) {\n    return void 0 === r && (r = 0), void 0 === o && (o = 0), this.throwIfDisposed(), opHandler.stridedSlice(this, e, t, n, r, o);\n  }, e.prototype.depthToSpace = function (e, t) {\n    return this.throwIfDisposed(), opHandler.depthToSpace(this, e, t);\n  }, e.nextId = 0, e;\n}();Object.defineProperty(Tensor, Symbol.hasInstance, { value: function (e) {\n    return !!e && null != e.shape && null != e.dtype;\n  } });var Variable = function (e) {\n  function t(n, r, o) {\n    void 0 === r && (r = !0);var a = e.call(this, n.shape, n.dtype, null, n.dataId) || this;a.trainable = r, a.name = o, null == a.name && (a.name = t.nextVarId.toString(), t.nextVarId++);try {\n      trackerFn().registerVariable(a);\n    } catch (e) {\n      throw trackerFn().disposeTensor(a), e;\n    }return a;\n  }return __extends(t, e), t.variable = function (e, n, r, o) {\n    return void 0 === n && (n = !0), null != o && o !== e.dtype && (e = e.asType(o)), new t(e, n, r);\n  }, t.prototype.assign = function (e) {\n    if (e.dtype !== this.dtype) throw new Error(\"dtype of the new value (\" + e.dtype + \") and previous value (\" + this.dtype + \") must match\");if (!arraysEqual(e.shape, this.shape)) throw new Error(\"shape of the new value (\" + e.shape + \") and previous value (\" + this.shape + \") must match\");trackerFn().disposeTensor(this), this.dataId = e.dataId, trackerFn().registerTensor(this);\n  }, t.nextVarId = 0, t;\n}(Tensor);Object.defineProperty(Variable, Symbol.hasInstance, { value: function (e) {\n    return e instanceof Tensor && null != e.assign && e.assign instanceof Function;\n  } });var variable = Variable.variable;function getFilteredNodesXToY(e, t, n) {\n  for (var r = {}, o = {}, a = 0; a < t.length; a++) r[t[a].id] = !0;for (a = 0; a < e.length; a++) {\n    var i = (f = e[a]).inputs;for (var s in i) {\n      for (var u = i[s], l = !1, c = 0; c < t.length; c++) if (r[u.id]) {\n        f.outputs.forEach(function (e) {\n          return r[e.id] = !0;\n        }), l = !0, o[f.id] = !0;break;\n      }if (l) break;\n    }\n  }var p = {};p[n.id] = !0;var d = {};for (a = e.length - 1; a >= 0; a--) for (i = (f = e[a]).inputs, c = 0; c < f.outputs.length; c++) if (p[f.outputs[c].id]) {\n    for (var s in i) p[i[s].id] = !0, d[f.id] = !0;break;\n  }var h = [];for (a = 0; a < e.length; a++) {\n    var f;if (o[(f = e[a]).id] && d[f.id]) {\n      var m = {};for (var s in f.inputs) {\n        var g = f.inputs[s];r[g.id] && (m[s] = g);\n      }var v = Object.assign({}, f);v.inputs = m, v.outputs = f.outputs, h.push(v);\n    }\n  }return h;\n}function backpropagateGradients(e, t) {\n  for (var n = function (n) {\n    var r = t[n],\n        o = [];if (r.outputs.forEach(function (t) {\n      var n = e[t.id];if (null != n) o.push(n);else {\n        var r = Tensor.make(t.shape, { values: makeZerosTypedArray(t.size, t.dtype) }, t.dtype);o.push(r);\n      }\n    }), null == r.gradient) throw new Error(\"Cannot compute gradient: gradient function not found for \" + r.name + \".\");var a = r.gradient(1 === r.outputs.length ? o[0] : o);for (var i in r.inputs) {\n      if (!(i in a)) throw new Error(\"Cannot backprop through input \" + i + \". Available gradients found: \" + Object.keys(a) + \".\");var s = a[i](),\n          u = r.inputs[i];if (!arraysEqual(s.shape, u.shape)) throw new Error(\"Error in gradient for op \" + r.name + \". The gradient of input '\" + i + \"' has shape '\" + s.shape + \"', which does not match the shape of the input '\" + u.shape + \"'\");if (null == e[u.id]) e[u.id] = s;else {\n        var l = e[u.id];e[u.id] = l.add(s), l.dispose();\n      }\n    }\n  }, r = t.length - 1; r >= 0; r--) n(r);\n}function assertTypesMatch(e, t) {\n  assert(e.dtype === t.dtype, \"The dtypes of the first(\" + e.dtype + \") and second(\" + t.dtype + \") input must match\");\n}function isTensorInList(e, t) {\n  for (var n = 0; n < t.length; n++) if (t[n].id === e.id) return !0;return !1;\n}function getTensorsInContainer(e) {\n  var t = [];return walkTensorContainer(e, t, new Set()), t;\n}function walkTensorContainer(e, t, n) {\n  if (null != e) if (e instanceof Tensor) t.push(e);else if (isIterable(e)) {\n    var r = e;for (var o in r) {\n      var a = r[o];n.has(a) || (n.add(a), walkTensorContainer(a, t, n));\n    }\n  }\n}function isIterable(e) {\n  return Array.isArray(e) || \"object\" == typeof e;\n}var Type,\n    Engine = function () {\n  function e(e, t, n) {\n    this.backend = e, this.safeMode = t, this.debugMode = n, this.registeredVariables = {}, this.refCounter = new WeakMap(), this.nextTapeNodeId = 0, this.numBytes = 0, this.numTensors = 0, this.numDataBuffers = 0, this.profiling = !1, this.gradientScopeCount = 0, this.customGradientDepth = 0, this.keepTensors = new Set(), this.activeScope = { track: [], name: \"default scope\" }, this.scopeStack = [this.activeScope], this.profiler = new Profiler(e), this.activeProfile = { newBytes: 0, newTensors: 0, peakBytes: 0, kernels: [], result: null };\n  }return e.prototype.tidy = function (e, t, n) {\n    var r = this;void 0 === n && (n = !1);var o,\n        a = null;if (null == t) {\n      if (\"function\" != typeof e) throw new Error(\"Please provide a function to tidy()\");t = e;\n    } else {\n      if (\"string\" != typeof e && !(e instanceof String)) throw new Error(\"When calling with two arguments, the first argument to tidy() must be a string\");if (\"function\" != typeof t) throw new Error(\"When calling with two arguments, the 2nd argument to tidy() must be a function\");a = e;\n    }return this.scopedRun(function () {\n      return r.startScope(a, n);\n    }, function () {\n      return r.endScope(o, n);\n    }, function () {\n      return (o = t()) instanceof Promise && console.error(\"Cannot return a Promise inside of tidy.\"), o;\n    });\n  }, e.prototype.scopedRun = function (e, t, n) {\n    e();try {\n      var r = n();return t(), r;\n    } catch (e) {\n      throw t(), e;\n    }\n  }, e.prototype.runKernel = function (e, t, n) {\n    var r,\n        o = this,\n        a = [],\n        i = function (e) {\n      return a.push(e), e;\n    },\n        s = this.activeScope.name,\n        u = this.numBytes,\n        l = this.numTensors;if (this.scopedRun(function () {\n      return o.customGradientDepth++;\n    }, function () {\n      return o.customGradientDepth--;\n    }, function () {\n      r = o.debugMode() ? o.profiler.profileKernel(s, function () {\n        return e(o.backend, i);\n      }) : e(o.backend, i);\n    }), this.shouldRecord()) {\n      var c = { id: this.nextTapeNodeId++, name: s, inputs: t, outputs: Array.isArray(r) ? r : [r] };null != n && (c.gradient = function (e) {\n        return n(e, a);\n      }), this.activeTape.push(c);\n    }return this.profiling && this.activeProfile.kernels.push({ name: s, bytesAdded: this.numBytes - u, totalBytesSnapshot: this.numBytes, tensorsAdded: this.numTensors - l, totalTensorsSnapshot: this.numTensors, inputShapes: Object.keys(t).map(function (e) {\n        return t[e].shape;\n      }), outputShape: Array.isArray(r) ? r.map(function (e) {\n        return e.shape;\n      }) : r.shape }), r;\n  }, e.prototype.registerTensor = function (e) {\n    var t = this.refCounter.has(e.dataId) ? this.refCounter.get(e.dataId) : 0;this.numTensors++, 0 === t && (this.numDataBuffers++, \"complex64\" !== e.dtype && (this.numBytes += sizeFromShape(e.shape) * bytesPerElement(e.dtype)), this.backend.register(e.dataId, e.shape, e.dtype)), this.refCounter.set(e.dataId, t + 1), e instanceof Variable || this.track(e);\n  }, e.prototype.registerVariable = function (e) {\n    if (null != this.registeredVariables[e.name]) throw new Error(\"Variable with name \" + e.name + \" was already registered\");this.registeredVariables[e.name] = e;\n  }, e.prototype.disposeTensor = function (e) {\n    if (this.refCounter.has(e.dataId)) {\n      this.keepTensors.has(e.id) && this.keepTensors.delete(e.id), this.numTensors--;var t = this.refCounter.get(e.dataId);t <= 1 ? (this.refCounter.delete(e.dataId), this.backend.disposeData(e.dataId), this.numDataBuffers--, \"complex64\" !== e.dtype && (this.numBytes -= sizeFromShape(e.shape) * bytesPerElement(e.dtype))) : this.refCounter.set(e.dataId, t - 1);\n    }\n  }, e.prototype.disposeVariables = function () {\n    for (var e in this.registeredVariables) {\n      var t = this.registeredVariables[e];this.disposeTensor(t), delete this.registeredVariables[e];\n    }\n  }, e.prototype.memory = function () {\n    var e = this.backend.memory();return e.numTensors = this.numTensors, e.numDataBuffers = this.numDataBuffers, e.numBytes = this.numBytes, e;\n  }, e.prototype.profile = function (e) {\n    return __awaiter(this, void 0, void 0, function () {\n      var t, n;return __generator(this, function (r) {\n        return this.profiling = !0, t = this.numBytes, n = this.numTensors, this.activeProfile.kernels = [], this.activeProfile.result = e(), this.profiling = !1, this.activeProfile.peakBytes = Math.max.apply(Math, this.activeProfile.kernels.map(function (e) {\n          return e.totalBytesSnapshot;\n        })), this.activeProfile.newBytes = this.numBytes - t, this.activeProfile.newTensors = this.numTensors - n, [2, this.activeProfile];\n      });\n    });\n  }, e.prototype.shouldRecord = function () {\n    return null != this.activeTape && 0 === this.customGradientDepth;\n  }, e.prototype.addTapeNode = function (e, t, n) {\n    var r = {};e.forEach(function (e, t) {\n      r[t] = e;\n    });var o = { id: this.nextTapeNodeId++, name: this.activeScope.name, inputs: r, outputs: [t], gradient: function (e) {\n        var t = {};return n(e).forEach(function (e, n) {\n          t[n] = function () {\n            return e;\n          };\n        }), t;\n      } };this.activeTape.push(o);\n  }, e.prototype.keep = function (e) {\n    if (1 === this.scopeStack.length && this.safeMode) throw new Error(\"Safe mode is ON. Enclose all tensor operations inside tf.tidy(): tf.tidy(() => {...}) to avoid memory leaks.\");return this.keepTensors.add(e.id), e;\n  }, e.prototype.startScope = function (e, t) {\n    void 0 === t && (t = !1), t && 0 === this.gradientScopeCount && (this.activeTape = []), t && this.gradientScopeCount++;var n = { track: [], name: \"unnamed scope\" };e && (n.name = e), this.scopeStack.push(n), this.activeScope = n;\n  }, e.prototype.endScope = function (e, t) {\n    var n = this;void 0 === t && (t = !1), t && (this.gradientScopeCount--, 0 === this.gradientScopeCount && (this.activeTape = null));var r = new Set(this.keepTensors),\n        o = getTensorsInContainer(e);o.forEach(function (e) {\n      return r.add(e.id);\n    });for (var a = 0; a < this.activeScope.track.length; a++) {\n      var i = this.activeScope.track[a];r.has(i.id) || (null != this.activeTape ? o.push(i) : i.dispose());\n    }var s = this.scopeStack.pop();this.activeScope = 0 === this.scopeStack.length ? { track: [], name: \"default scope\" } : this.scopeStack[this.scopeStack.length - 1], o.forEach(function (e) {\n      !n.keepTensors.has(e.id) && isTensorInList(e, s.track) && n.track(e);\n    });\n  }, e.prototype.gradients = function (e, t, n, r) {\n    var o = this;return void 0 === r && (r = !1), assert(t.length > 0, \"gradients() received an empty list of xs.\"), this.tidy(\"gradients\", function () {\n      var a = e();assert(a instanceof Tensor, \"The result y returned by f() must be a tensor.\");var i = getFilteredNodesXToY(o.activeTape, t, a);if (!r && 0 === i.length && t.length > 0) throw new Error(\"Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.\");var s = {};return s[a.id] = null == n ? ones(a.shape) : n, backpropagateGradients(s, i), { value: a, grads: t.map(function (e) {\n          return s[e.id];\n        }) };\n    }, !0);\n  }, e.prototype.customGrad = function (e) {\n    var t = this;return assert(isFunction(e), \"The f passed in customGrad(f) must be a function.\"), function () {\n      for (var n, r, o = [], a = 0; a < arguments.length; a++) o[a] = arguments[a];if (assert(o.every(function (e) {\n        return e instanceof Tensor;\n      }), \"The args passed in customGrad(f)(x1, x2,...) must all be tensors\"), t.scopedRun(function () {\n        return t.customGradientDepth++;\n      }, function () {\n        return t.customGradientDepth--;\n      }, function () {\n        r = t.tidy(e.name, function () {\n          var t = e.apply(void 0, o),\n              r = t.value,\n              a = t.gradFunc;return assert(r instanceof Tensor, \"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor\"), assert(isFunction(a), \"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function.\"), n = a, r;\n        }, !0);\n      }), t.shouldRecord()) {\n        t.addTapeNode(o, r, function (e) {\n          var t = n(e),\n              r = Array.isArray(t) ? t : [t];return assert(r.length === o.length, \"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...).\"), assert(r.every(function (e) {\n            return e instanceof Tensor;\n          }), \"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.\"), r;\n        });\n      }return r;\n    };\n  }, e.prototype.write = function (e, t) {\n    this.backend.write(e, t);\n  }, e.prototype.readSync = function (e) {\n    return this.backend.readSync(e);\n  }, e.prototype.read = function (e) {\n    return this.backend.read(e);\n  }, e.prototype.fromPixels = function (e, t) {\n    return this.backend.fromPixels(e, t);\n  }, e.prototype.time = function (e) {\n    return __awaiter(this, void 0, void 0, function () {\n      var t, n;return __generator(this, function (r) {\n        switch (r.label) {case 0:\n            return t = now(), [4, this.backend.time(e)];case 1:\n            return (n = r.sent()).wallMs = now() - t, [2, n];}\n      });\n    });\n  }, e.prototype.track = function (e) {\n    if (1 === this.scopeStack.length && this.safeMode) throw new Error(\"Safe mode is ON. Enclose all tensor operations inside tf.tidy(): tf.tidy(() => {op();...}); to avoid memory leaks.\");return this.activeScope.track.push(e), e;\n  }, e;\n}();function ones(e) {\n  var t = makeOnesTypedArray(sizeFromShape(e), \"float32\");return Tensor.make(e, { values: t });\n}!function (e) {\n  e[e.NUMBER = 0] = \"NUMBER\", e[e.BOOLEAN = 1] = \"BOOLEAN\", e[e.STRING = 2] = \"STRING\";\n}(Type || (Type = {}));var URL_PROPERTIES = [{ name: \"DEBUG\", type: Type.BOOLEAN }, { name: \"IS_BROWSER\", type: Type.BOOLEAN }, { name: \"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION\", type: Type.NUMBER }, { name: \"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE\", type: Type.BOOLEAN }, { name: \"WEBGL_VERSION\", type: Type.NUMBER }, { name: \"WEBGL_RENDER_FLOAT32_ENABLED\", type: Type.BOOLEAN }, { name: \"WEBGL_DOWNLOAD_FLOAT_ENABLED\", type: Type.BOOLEAN }, { name: \"WEBGL_FENCE_API_ENABLED\", type: Type.BOOLEAN }, { name: \"BACKEND\", type: Type.STRING }, { name: \"EPSILON\", type: Type.NUMBER }];function isWebGLVersionEnabled(e, t) {\n  var n;try {\n    n = getWebGLRenderingContext(e, t);\n  } catch (e) {\n    return !1;\n  }return null != n && (loseContext(n), !0);\n}function getWebGLDisjointQueryTimerVersion(e, t) {\n  if (0 === e) return 0;var n,\n      r = getWebGLRenderingContext(e, t);return n = hasExtension(r, \"EXT_disjoint_timer_query_webgl2\") && 2 === e ? 2 : hasExtension(r, \"EXT_disjoint_timer_query\") ? 1 : 0, null != r && loseContext(r), n;\n}function isRenderToFloatTextureEnabled(e, t) {\n  if (0 === e) return !1;var n = getWebGLRenderingContext(e, t);if (1 === e) {\n    if (!hasExtension(n, \"OES_texture_float\")) return !1;\n  } else if (!hasExtension(n, \"EXT_color_buffer_float\")) return !1;var r = createFloatTextureAndBindToFramebuffer(n, e);return loseContext(n), r;\n}function isDownloadFloatTextureEnabled(e, t) {\n  if (0 === e) return !1;var n = getWebGLRenderingContext(e, t);if (1 === e) {\n    if (!hasExtension(n, \"OES_texture_float\")) return !1;if (!hasExtension(n, \"WEBGL_color_buffer_float\")) return !1;\n  } else if (!hasExtension(n, \"EXT_color_buffer_float\")) return !1;var r = createFloatTextureAndBindToFramebuffer(n, e);return loseContext(n), r;\n}function isWebGLFenceEnabled(e, t) {\n  if (2 !== e) return !1;var n = getWebGLRenderingContext(e, t),\n      r = null != n.fenceSync;return loseContext(n), r;\n}function isChrome() {\n  return \"undefined\" != typeof navigator && null != navigator && null != navigator.userAgent && /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor);\n}var TENSORFLOWJS_FLAGS_PREFIX = \"tfjsflags\";function getFeaturesFromURL() {\n  var e = {};if (\"undefined\" == typeof window || void 0 === window.location) return e;var t = getQueryParams(window.location.search);if (TENSORFLOWJS_FLAGS_PREFIX in t) {\n    var n = {};t[TENSORFLOWJS_FLAGS_PREFIX].split(\",\").forEach(function (e) {\n      var t = e.split(\":\"),\n          r = t[0],\n          o = t[1];n[r] = o;\n    }), URL_PROPERTIES.forEach(function (t) {\n      t.name in n && (console.log(\"Setting feature override from URL \" + t.name + \": \" + n[t.name]), t.type === Type.NUMBER ? e[t.name] = +n[t.name] : t.type === Type.BOOLEAN ? e[t.name] = \"true\" === n[t.name] : t.type === Type.STRING ? e[t.name] = n[t.name] : console.warn(\"Unknown URL param: \" + t.name + \".\"));\n    });\n  }return e;\n}function hasExtension(e, t) {\n  return null != e.getExtension(t);\n}function getWebGLRenderingContext(e, t) {\n  if (0 === e || !t) throw new Error(\"Cannot get WebGL rendering context, WebGL is disabled.\");var n = document.createElement(\"canvas\");return 1 === e ? n.getContext(\"webgl\") || n.getContext(\"experimental-webgl\") : n.getContext(\"webgl2\");\n}function loseContext(e) {\n  if (null != e) {\n    var t = e.getExtension(\"WEBGL_lose_context\");if (null == t) throw new Error(\"Extension WEBGL_lose_context not supported on this browser.\");t.loseContext();\n  }\n}function createFloatTextureAndBindToFramebuffer(e, t) {\n  var n = e.createFramebuffer(),\n      r = e.createTexture();e.bindTexture(e.TEXTURE_2D, r);var o = 2 === t ? e.RGBA32F : e.RGBA;e.texImage2D(e.TEXTURE_2D, 0, o, 1, 1, 0, e.RGBA, e.FLOAT, null), e.bindFramebuffer(e.FRAMEBUFFER, n), e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, r, 0);var a = e.checkFramebufferStatus(e.FRAMEBUFFER) === e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D, null), e.bindFramebuffer(e.FRAMEBUFFER, null), e.deleteTexture(r), e.deleteFramebuffer(n), a;\n}function getQueryParams(e) {\n  var t = {};return e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g, function (e) {\n    for (var n = [], r = 1; r < arguments.length; r++) n[r - 1] = arguments[r];return decodeParam(t, n[0], n[1]), n.join(\"=\");\n  }), t;\n}function decodeParam(e, t, n) {\n  e[decodeURIComponent(t)] = decodeURIComponent(n || \"\");\n}var EPSILON_FLOAT16 = .001,\n    TEST_EPSILON_FLOAT16 = .1,\n    EPSILON_FLOAT32 = 1e-7,\n    TEST_EPSILON_FLOAT32 = .001,\n    Environment = function () {\n  function e(e) {\n    this.features = {}, this.engines = {}, this.registry = {}, null != e && (this.features = e), this.get(\"DEBUG\") && console.warn(\"Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.\");\n  }return e.setBackend = function (e, t) {\n    if (void 0 === t && (t = !1), !(e in ENV.registry)) throw new Error(\"Backend name '\" + e + \"' not found in registry\");ENV.initBackend(e, t);\n  }, e.getBackend = function () {\n    return ENV.initDefaultBackend(), ENV.backendName;\n  }, e.disposeVariables = function () {\n    ENV.engine.disposeVariables();\n  }, e.memory = function () {\n    return ENV.engine.memory();\n  }, e.profile = function (e) {\n    return ENV.engine.profile(e);\n  }, e.tidy = function (e, t, n) {\n    return void 0 === n && (n = !1), ENV.engine.tidy(e, t, n);\n  }, e.dispose = function (e) {\n    getTensorsInContainer(e).forEach(function (e) {\n      return e.dispose();\n    });\n  }, e.keep = function (e) {\n    return ENV.engine.keep(e);\n  }, e.time = function (e) {\n    return ENV.engine.time(e);\n  }, e.prototype.get = function (e) {\n    return e in this.features ? this.features[e] : (this.features[e] = this.evaluateFeature(e), this.features[e]);\n  }, e.prototype.getFeatures = function () {\n    return this.features;\n  }, e.prototype.set = function (e, t) {\n    this.features[e] = t;\n  }, e.prototype.getBestBackendName = function () {\n    var e = this;if (0 === Object.keys(this.registry).length) throw new Error(\"No backend found in registry.\");return Object.keys(this.registry).map(function (t) {\n      return { name: t, entry: e.registry[t] };\n    }).sort(function (e, t) {\n      return t.entry.priority - e.entry.priority;\n    })[0].name;\n  }, e.prototype.evaluateFeature = function (e) {\n    if (\"DEBUG\" === e) return !1;if (\"IS_BROWSER\" === e) return \"undefined\" != typeof window;if (\"IS_NODE\" === e) return \"undefined\" != typeof process && void 0 !== process.versions.node;if (\"IS_CHROME\" === e) return isChrome();if (\"IS_TEST\" === e) return !1;if (\"BACKEND\" === e) return this.getBestBackendName();if (\"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION\" === e) {\n      var t = this.get(\"WEBGL_VERSION\");return 0 === t ? 0 : t > 0 ? 0 : getWebGLDisjointQueryTimerVersion(t, this.get(\"IS_BROWSER\"));\n    }if (\"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE\" === e) return this.get(\"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION\") > 0 && !isMobile();if (\"HAS_WEBGL\" === e) return this.get(\"WEBGL_VERSION\") > 0;if (\"WEBGL_VERSION\" === e) return isWebGLVersionEnabled(2, this.get(\"IS_BROWSER\")) ? 2 : isWebGLVersionEnabled(1, this.get(\"IS_BROWSER\")) ? 1 : 0;if (\"WEBGL_RENDER_FLOAT32_ENABLED\" === e) return isRenderToFloatTextureEnabled(this.get(\"WEBGL_VERSION\"), this.get(\"IS_BROWSER\"));if (\"WEBGL_DOWNLOAD_FLOAT_ENABLED\" === e) return isDownloadFloatTextureEnabled(this.get(\"WEBGL_VERSION\"), this.get(\"IS_BROWSER\"));if (\"WEBGL_FENCE_API_ENABLED\" === e) return isWebGLFenceEnabled(this.get(\"WEBGL_VERSION\"), this.get(\"IS_BROWSER\"));if (\"TEST_EPSILON\" === e) return 32 === this.backend.floatPrecision() ? TEST_EPSILON_FLOAT32 : TEST_EPSILON_FLOAT16;if (\"EPSILON\" === e) return 32 === this.backend.floatPrecision() ? EPSILON_FLOAT32 : EPSILON_FLOAT16;throw new Error(\"Unknown feature \" + e + \".\");\n  }, e.prototype.setFeatures = function (e) {\n    this.features = Object.assign({}, e);\n  }, e.prototype.reset = function () {\n    this.features = getFeaturesFromURL(), null != this.globalEngine && (this.globalEngine = null);\n  }, e.prototype.initBackend = function (e, t) {\n    var n = this;if (void 0 === t && (t = !1), this.backendName = e, this.engines[e]) this.globalEngine = this.engines[e];else {\n      var r = this.findBackend(e);this.globalEngine = new Engine(r, t, function () {\n        return n.get(\"DEBUG\");\n      }), this.engines[e] = this.globalEngine;\n    }\n  }, Object.defineProperty(e.prototype, \"backend\", { get: function () {\n      return this.engine.backend;\n    }, enumerable: !0, configurable: !0 }), e.prototype.findBackend = function (e) {\n    return e in this.registry ? this.registry[e].backend : null;\n  }, e.prototype.registerBackend = function (e, t, n, r) {\n    var o = this;if (void 0 === n && (n = 1), e in this.registry) return console.warn(e + \" backend was already registered. Reusing existing backend\"), null != r && r(function () {\n      return o.engine;\n    }), !1;try {\n      var a = t();return this.registry[e] = { backend: a, priority: n }, !0;\n    } catch (t) {\n      return console.warn(\"Registration of backend \" + e + \" failed\"), console.warn(t.stack || t.message), !1;\n    }\n  }, e.prototype.removeBackend = function (e) {\n    if (!(e in this.registry)) throw new Error(e + \" backend not found in registry\");this.registry[e].backend.dispose(), delete this.registry[e], e in this.engines && delete this.engines[e];\n  }, Object.defineProperty(e.prototype, \"engine\", { get: function () {\n      return this.initDefaultBackend(), this.globalEngine;\n    }, enumerable: !0, configurable: !0 }), e.prototype.initDefaultBackend = function () {\n    null == this.globalEngine && this.initBackend(this.get(\"BACKEND\"), !1);\n  }, e;\n}();function getGlobalNamespace() {\n  var e;if (\"undefined\" != typeof window) e = window;else {\n    if (\"undefined\" == typeof process) throw new Error(\"Could not find a global object\");e = process;\n  }return e;\n}function getOrMakeEnvironment() {\n  var e = getGlobalNamespace();return null == e.ENV && (e.ENV = new Environment(getFeaturesFromURL()), setTensorTracker(function () {\n    return e.ENV.engine;\n  })), e.ENV;\n}var ENV = getOrMakeEnvironment(),\n    environment = Object.freeze({ Environment: Environment, ENV: ENV });function grad(e) {\n  return assert(isFunction(e), \"The f passed in grad(f) must be a function\"), function (t, n) {\n    return assert(t instanceof Tensor, \"The x passed in grad(f)(x) must be a tensor\"), assert(null == n || n instanceof Tensor, \"The dy passed in grad(f)(x, dy) must be a tensor\"), ENV.engine.tidy(function () {\n      var r = ENV.engine.gradients(function () {\n        return e(t);\n      }, [t], n),\n          o = r.value,\n          a = r.grads;return null != n && assertShapesMatch(o.shape, n.shape, \"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)\"), checkGrads(a), a[0];\n    });\n  };\n}function grads(e) {\n  return assert(isFunction(e), \"The f passed in grads(f) must be a function\"), function (t, n) {\n    return assert(Array.isArray(t) && t.every(function (e) {\n      return e instanceof Tensor;\n    }), \"The args passed in grads(f)(args) must be an array of tensors\"), assert(null == n || n instanceof Tensor, \"The dy passed in grads(f)(args, dy) must be a tensor\"), ENV.engine.tidy(function () {\n      var r = ENV.engine.gradients(function () {\n        return e.apply(void 0, t);\n      }, t, n),\n          o = r.value,\n          a = r.grads;return null != n && assertShapesMatch(o.shape, n.shape, \"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])\"), checkGrads(a), a;\n    });\n  };\n}function valueAndGrad(e) {\n  return assert(isFunction(e), \"The f passed in valueAndGrad(f) must be a function\"), function (t, n) {\n    assert(t instanceof Tensor, \"The x passed in valueAndGrad(f)(x) must be a tensor\"), assert(null == n || n instanceof Tensor, \"The dy passed in valueAndGrad(f)(x, dy) must be a tensor\");var r = ENV.engine.gradients(function () {\n      return e(t);\n    }, [t], n),\n        o = r.grads,\n        a = r.value;return checkGrads(o), { grad: o[0], value: a };\n  };\n}function valueAndGrads(e) {\n  return assert(isFunction(e), \"The f passed in valueAndGrads(f) must be a function\"), function (t, n) {\n    assert(Array.isArray(t) && t.every(function (e) {\n      return e instanceof Tensor;\n    }), \"The args passed in valueAndGrads(f)(args) must be array of tensors\"), assert(null == n || n instanceof Tensor, \"The dy passed in valueAndGrads(f)(args, dy) must be a tensor\");var r = ENV.engine.gradients(function () {\n      return e.apply(void 0, t);\n    }, t, n);return null != n && assertShapesMatch(r.value.shape, n.shape, \"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])\"), checkGrads(r.grads), r;\n  };\n}function variableGrads(e, t) {\n  if (assert(isFunction(e), \"The f passed in variableGrads(f) must be a function\"), assert(null == t || Array.isArray(t) && t.every(function (e) {\n    return e instanceof Variable;\n  }), \"The varList passed in variableGrads(f, varList) must be an array of variables\"), null == t) for (var n in t = [], ENV.engine.registeredVariables) t.push(ENV.engine.registeredVariables[n]);var r = t.length;assert((t = t.filter(function (e) {\n    return e.trainable;\n  })).length > 0, \"variableGrads() expects at least one of the input variables to be trainable, but none of the \" + r + \" variables is trainable.\");var o = ENV.engine.gradients(e, t, null, !0),\n      a = o.value,\n      i = o.grads;assert(i.some(function (e) {\n    return null != e;\n  }), \"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize().\"), assert(0 === a.rank, \"The f passed in variableGrads(f) must return a scalar, but it returned a rank-\" + a.rank + \" tensor\");var s = {};return t.forEach(function (e, t) {\n    null != i[t] && (s[e.name] = i[t]);\n  }), { value: a, grads: s };\n}function customGrad(e) {\n  return ENV.engine.customGrad(e);\n}function checkGrads(e) {\n  if (e.filter(function (e) {\n    return null == e;\n  }).length > 0) throw new Error(\"Cannot compute gradient of y=f(x) with respect to x. Make sure that\\n    the f you passed encloses all operations that lead from x to y.\");\n}var tidy = Environment.tidy,\n    keep = Environment.keep,\n    dispose = Environment.dispose,\n    time = Environment.time,\n    profile = Environment.profile;function warn() {\n  for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];ENV.get(\"IS_TEST\") || console.warn.apply(console, e);\n}function getReshaped(e, t, n, r) {\n  void 0 === r && (r = !0);var o = [];if (r) (o = o.concat(t.slice(0))).push(e[0] / n), o = o.concat(e.slice(1));else {\n    o = o.concat(e[0]);for (var a = t.length, i = 0; i < a; ++i) o = o.concat([e[i + 1] / t[i], t[i]]);o = o.concat(e.slice(a + 1));\n  }return o;\n}function getPermuted(e, t, n) {\n  void 0 === n && (n = !0);var r = [];if (n) {\n    r.push(t);for (var o = t + 1; o < e; ++o) o <= 2 * t ? (r.push(o), r.push(o - (t + 1))) : r.push(o);\n  } else {\n    var a = [],\n        i = [];for (o = 1; o < e; ++o) o >= 2 * t + 1 || o % 2 == 1 ? i.push(o) : a.push(o);r.push.apply(r, a), r.push(0), r.push.apply(r, i);\n  }return r;\n}function getReshapedPermuted(e, t, n, r) {\n  void 0 === r && (r = !0);var o = [];r ? o.push(e[0] / n) : o.push(e[0] * n);for (var a = 1; a < e.length; ++a) a <= t.length ? r ? o.push(t[a - 1] * e[a]) : o.push(e[a] / t[a - 1]) : o.push(e[a]);return o;\n}function getSliceBeginCoords(e, t) {\n  for (var n = [0], r = 0; r < t; ++r) n.push(e[r][0]);return n;\n}function getSliceSize(e, t, n) {\n  for (var r = e.slice(0, 1), o = 0; o < n; ++o) r.push(e[o + 1] - t[o][0] - t[o][1]);return r;\n}function axesAreInnerMostDims(e, t) {\n  for (var n = 0; n < e.length; ++n) if (e[e.length - n - 1] !== t - 1 - n) return !1;return !0;\n}function combineLocations(e, t, n) {\n  for (var r = e.length + t.length, o = [], a = 0, i = 0, s = 0; s < r; s++) -1 === n.indexOf(s) ? o.push(e[a++]) : o.push(t[i++]);return o;\n}function computeOutAndReduceShapes(e, t) {\n  for (var n = [], r = e.length, o = 0; o < r; o++) -1 === t.indexOf(o) && n.push(e[o]);return [n, t.map(function (t) {\n    return e[t];\n  })];\n}function expandShapeToKeepDim(e, t) {\n  return combineLocations(e, t.map(function (e) {\n    return 1;\n  }), t);\n}function parseAxisParam(e, t) {\n  var n = t.length;return assert((e = null == e ? t.map(function (e, t) {\n    return t;\n  }) : [].concat(e)).every(function (e) {\n    return e >= -n && e < n;\n  }), \"All values in axis param must be in range [-\" + n + \", \" + n + \") but got axis \" + e), assert(e.every(function (e) {\n    return isInt(e);\n  }), \"All values in axis param must be integers but got axis \" + e), e.map(function (e) {\n    return e < 0 ? n + e : e;\n  });\n}function assertAxesAreInnerMostDims(e, t, n) {\n  assert(axesAreInnerMostDims(t, n), e + \" supports only inner-most axes for now. Got axes \" + t + \" and rank-\" + n + \" input.\");\n}function getAxesPermutation(e, t) {\n  if (axesAreInnerMostDims(e, t)) return null;for (var n = [], r = 0; r < t; ++r) -1 === e.indexOf(r) && n.push(r);return e.forEach(function (e) {\n    return n.push(e);\n  }), n;\n}function getUndoAxesPermutation(e) {\n  return e.map(function (e, t) {\n    return [t, e];\n  }).sort(function (e, t) {\n    return e[1] - t[1];\n  }).map(function (e) {\n    return e[0];\n  });\n}function getInnerMostAxes(e, t) {\n  for (var n = [], r = t - e; r < t; ++r) n.push(r);return n;\n}function assertParamsConsistent(e, t) {\n  var n = e[0].length;e.forEach(function (e, t) {\n    assert(e.length === n, \"Error in concat\" + n + \"D: rank of tensors[\" + t + \"] must be the same as the rank of the rest (\" + n + \")\");\n  }), assert(t >= 0 && t < n, \"Error in concat\" + n + \"D: axis must be between 0 and \" + (n - 1) + \".\");var r = e[0];e.forEach(function (e, o) {\n    for (var a = 0; a < n; a++) assert(a === t || e[a] === r[a], \"Error in concat\" + n + \"D: Shape of tensors[\" + o + \"] (\" + e + \") does not match the shape of the rest (\" + r + \") along the non-concatenated axis \" + o + \".\");\n  });\n}function computeOutShape(e, t) {\n  for (var n = e[0].slice(), r = 1; r < e.length; r++) n[t] += e[r][t];return n;\n}var PARALLELIZE_THRESHOLD = 30;function computeOptimalWindowSize(e) {\n  return e <= PARALLELIZE_THRESHOLD ? e : nearestDivisor(e, Math.floor(Math.sqrt(e)));\n}function segOpComputeOptimalWindowSize(e, t) {\n  var n,\n      r = !1;for (e <= PARALLELIZE_THRESHOLD ? (n = e, r = !0) : n = nearestDivisor(e, Math.floor(Math.sqrt(e))); !r;) {\n    if (n > t || n === e) {\n      r = !0;break;\n    }n = nearestDivisor(e, n + 1);\n  }return n;\n}function computeOutShape$1(e, t, n) {\n  for (var r = [], o = e.length, a = 0; a < o; a++) a !== t ? r.push(e[a]) : r.push(n);return r;\n}function assertParamsValid(e, t, n) {\n  assert(e.rank === t.length, \"Error in slice\" + e.rank + \"D: Length of begin \" + t + \" must match the rank of the array (\" + e.rank + \").\"), assert(e.rank === n.length, \"Error in slice\" + e.rank + \"D: Length of size \" + n + \" must match the rank of the array (\" + e.rank + \").\");for (var r = 0; r < e.rank; ++r) assert(t[r] + n[r] <= e.shape[r], \"Error in slice\" + e.rank + \"D: begin[\" + r + \"] + size[\" + r + \"] (\" + (t[r] + n[r]) + \") would overflow input.shape[\" + r + \"] (\" + e.shape[r] + \")\");\n}function getStridedSlicedInfo(e, t, n, r, o, a, i, s, u) {\n  if (void 0 === o && (o = 0), void 0 === a && (a = 0), void 0 === i && (i = 0), void 0 === s && (s = 0), void 0 === u && (u = 0), 0 !== i) throw new Error(\"ellipsis mask is not yet supported\");if (0 !== s) throw new Error(\"new axis mask is not yet supported\");for (var l = [], c = [], p = [], d = 0; d < e.length; d++) l[d] = startForAxis(o, t, r, e, d), c[d] = stopForAxis(a, n, r, e, d), u & 1 << d && (c[d] = l[d] + 1, p.push(d));var h = new Array(e.length).fill(0);return h = h.map(function (e, t) {\n    for (var n = 0, o = l[t]; !(r[t] > 0 ? o >= c[t] : o <= c[t]); o += r[t]) n += 1;return n;\n  }), [l, h, p];\n}function startForAxis(e, t, n, r, o) {\n  var a = t[o];e & 1 << o && (a = n[o] > 0 ? Number.MIN_SAFE_INTEGER : Number.MAX_SAFE_INTEGER);var i = r[o];return a < 0 && (a += i), a = clamp(0, a, i - 1);\n}function stopForAxis(e, t, n, r, o) {\n  var a = t[o];e & 1 << o && (a = n[o] > 0 ? Number.MAX_SAFE_INTEGER : Number.MIN_SAFE_INTEGER);var i = r[o];return a < 0 && (a += i), a = n[o] > 0 ? clamp(0, a, i) : clamp(-1, a, i - 1);\n}function convertToTensor(e, t, n, r) {\n  if (void 0 === r && (r = \"float32\"), r = r || \"float32\", e instanceof Tensor) return e;if (!isTypedArray(e) && !Array.isArray(e) && \"number\" != typeof e && \"boolean\" != typeof e) throw new Error(\"Argument '\" + t + \"' passed to '\" + n + \"' must be a Tensor or TensorLike, but got \" + e.constructor.name);var o = inferShape(e);return isTypedArray(e) || Array.isArray(e) || (e = [e]), Tensor.make(o, { values: toTypedArray(e, r, ENV.get(\"DEBUG\")) }, r);\n}function convertToTensorArray(e, t, n) {\n  if (!Array.isArray(e)) throw new Error(\"Argument \" + t + \" passed to \" + n + \" must be a `Tensor[]` or `TensorLike[]`\");return e.map(function (e, r) {\n    return convertToTensor(e, t + \"[\" + r + \"]\", n);\n  });\n}function op(e) {\n  var t = Object.keys(e);if (1 !== t.length) throw new Error(\"Please provide an object with a single key (operation name) mapping to a function. Got an object with \" + t.length + \" keys.\");var n = t[0],\n      r = e[n];n.endsWith(\"_\") && (n = n.substring(0, n.length - 1));var o = function () {\n    for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];ENV.engine.startScope(n);try {\n      var o = r.apply(void 0, e);return o instanceof Promise && console.error(\"Cannot return a Promise inside of tidy.\"), ENV.engine.endScope(o), o;\n    } catch (e) {\n      throw ENV.engine.endScope(null), e;\n    }\n  };return Object.defineProperty(o, \"name\", { value: n, configurable: !0 }), o;\n}function softmax_(e, t) {\n  void 0 === t && (t = -1);var n = convertToTensor(e, \"logits\", \"softmax\");if (-1 === t && (t = n.rank - 1), t !== n.rank - 1) throw Error(\"Softmax along a non-last dimension is not yet supported. Logits was rank \" + n.rank + \" and dim was \" + t);return customGrad(function (e) {\n    var n = e.logSumExp([t], !0),\n        r = e.toFloat().sub(n).exp();return { value: r, gradFunc: function (e) {\n        var n = e.mul(r);return n.sub(n.sum([t], !0).mul(r));\n      } };\n  })(n);\n}var softmax = op({ softmax_: softmax_ });function complex_(e, t) {\n  var n = convertToTensor(e, \"real\", \"complex\"),\n      r = convertToTensor(t, \"imag\", \"complex\");return assertShapesMatch(n.shape, r.shape, \"real and imag shapes, \" + n.shape + \" and \" + r.shape + \", must match in call to tf.complex().\"), ENV.engine.runKernel(function (e) {\n    return e.complex(n, r);\n  }, { $real: n, $imag: r });\n}function real_(e) {\n  var t = convertToTensor(e, \"input\", \"real\");return ENV.engine.runKernel(function (e) {\n    return e.real(t);\n  }, { $input: t });\n}function imag_(e) {\n  var t = convertToTensor(e, \"input\", \"imag\");return ENV.engine.runKernel(function (e) {\n    return e.imag(t);\n  }, { $input: t });\n}var complex = op({ complex_: complex_ }),\n    real = op({ real_: real_ }),\n    imag = op({ imag_: imag_ });function tensor(e, t, n) {\n  if (void 0 === n && (n = \"float32\"), \"complex64\" === n) throw new Error(\"Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).\");if (!isTypedArray(e) && !Array.isArray(e) && \"number\" != typeof e && \"boolean\" != typeof e) throw new Error(\"values passed to tensor(values) must be an array of numbers or booleans, or a TypedArray\");var r = inferShape(e);return null != t && 1 !== r.length && assertShapesMatch(t, r, \"Error creating a new Tensor. Inferred shape (\" + r + \") does not match the provided shape (\" + t + \"). \"), isTypedArray(e) || Array.isArray(e) || (e = [e]), t = t || r, Tensor.make(t, { values: toTypedArray(e, n, ENV.get(\"DEBUG\")) }, n);\n}function scalar(e, t) {\n  if (void 0 === t && (t = \"float32\"), (isTypedArray(e) || Array.isArray(e)) && \"complex64\" !== t) throw new Error(\"Error creating a new Scalar: value must be a primitive (number|boolean)\");return tensor(e, [], t);\n}function tensor1d(e, t) {\n  void 0 === t && (t = \"float32\"), assertNonNull(e);var n = inferShape(e);if (1 !== n.length) throw new Error(\"tensor1d() requires values to be a flat/TypedArray\");return tensor(e, n, t);\n}function tensor2d(e, t, n) {\n  if (void 0 === n && (n = \"float32\"), assertNonNull(e), null != t && 2 !== t.length) throw new Error(\"tensor2d() requires shape to have two numbers\");var r = inferShape(e);if (2 !== r.length && 1 !== r.length) throw new Error(\"tensor2d() requires values to be number[][] or flat/TypedArray\");if (1 === r.length && null == t) throw new Error(\"tensor2d() requires shape to be provided when `values` are a flat/TypedArray\");return tensor(e, t = t || r, n);\n}function tensor3d(e, t, n) {\n  if (void 0 === n && (n = \"float32\"), assertNonNull(e), null != t && 3 !== t.length) throw new Error(\"tensor3d() requires shape to have three numbers\");var r = inferShape(e);if (3 !== r.length && 1 !== r.length) throw new Error(\"tensor3d() requires values to be number[][][] or flat/TypedArray\");if (1 === r.length && null == t) throw new Error(\"tensor3d() requires shape to be provided when `values` are a flat array\");return tensor(e, t = t || r, n);\n}function tensor4d(e, t, n) {\n  if (void 0 === n && (n = \"float32\"), assertNonNull(e), null != t && 4 !== t.length) throw new Error(\"tensor4d() requires shape to have four numbers\");var r = inferShape(e);if (4 !== r.length && 1 !== r.length) throw new Error(\"tensor4d() requires values to be number[][][][] or flat/TypedArray\");if (1 === r.length && null == t) throw new Error(\"tensor4d() requires shape to be provided when `values` are a flat array\");return tensor(e, t = t || r, n);\n}function tensor5d(e, t, n) {\n  if (void 0 === n && (n = \"float32\"), assertNonNull(e), null != t && 5 !== t.length) throw new Error(\"tensor5d() requires shape to have five numbers\");var r = inferShape(e);if (5 !== r.length && 1 !== r.length) throw new Error(\"tensor5d() requires values to be number[][][][][] or flat/TypedArray\");if (1 === r.length && null == t) throw new Error(\"tensor5d() requires shape to be provided when `values` are a flat array\");return tensor(e, t = t || r, n);\n}function tensor6d(e, t, n) {\n  if (void 0 === n && (n = \"float32\"), assertNonNull(e), null != t && 6 !== t.length) throw new Error(\"tensor6d() requires shape to have six numbers\");var r = inferShape(e);if (6 !== r.length && 1 !== r.length) throw new Error(\"tensor6d() requires values to be number[][][][] or flat/TypedArray\");if (1 === r.length && null == t) throw new Error(\"tensor6d() requires shape to be provided when `values` are a flat array\");return tensor(e, t = t || r, n);\n}function ones$1(e, t) {\n  if (void 0 === t && (t = \"float32\"), \"complex64\" === t) {\n    var n = ones$1(e, \"float32\"),\n        r = ones$1(e, \"float32\");return complex(n, r);\n  }var o = makeOnesTypedArray(sizeFromShape(e), t);return Tensor.make(e, { values: o }, t);\n}function zeros(e, t) {\n  if (void 0 === t && (t = \"float32\"), \"complex64\" === t) {\n    var n = zeros(e, \"float32\"),\n        r = zeros(e, \"float32\");return complex(n, r);\n  }var o = makeZerosTypedArray(sizeFromShape(e), t);return Tensor.make(e, { values: o }, t);\n}function fill(e, t, n) {\n  void 0 === n && (n = \"float32\");var r = getTypedArrayFromDType(n, sizeFromShape(e));return r.fill(t), Tensor.make(e, { values: r }, n);\n}function onesLike_(e) {\n  var t = convertToTensor(e, \"x\", \"onesLike\");return ones$1(t.shape, t.dtype);\n}function zerosLike_(e) {\n  var t = convertToTensor(e, \"x\", \"zerosLike\");return zeros(t.shape, t.dtype);\n}function linspace(e, t, n) {\n  if (0 === n) throw new Error(\"Cannot request zero samples\");var r = (t - e) / (n - 1),\n      o = makeZerosTypedArray(n, \"float32\");o[0] = e;for (var a = 1; a < o.length; a++) o[a] = o[a - 1] + r;return tensor1d(o, \"float32\");\n}function range(e, t, n, r) {\n  if (void 0 === n && (n = 1), void 0 === r && (r = \"float32\"), 0 === n) throw new Error(\"Cannot have a step of zero\");if (e === t || e < t && n < 0 || t < e && n > 1) return zeros([0], r);var o = makeZerosTypedArray(Math.abs(Math.ceil((t - e) / n)), r);t < e && 1 === n && (n = -1), o[0] = e;for (var a = 1; a < o.length; a++) o[a] = o[a - 1] + n;return tensor1d(o, r);\n}var DType,\n    Rank,\n    UpcastInt32AndMap,\n    UpcastBoolAndMap,\n    UpcastFloat32AndMap,\n    UpcastComplex64AndMap,\n    onesLike = op({ onesLike_: onesLike_ }),\n    zerosLike = op({ zerosLike_: zerosLike_ });!function (e) {\n  e.float32 = \"float32\", e.int32 = \"int32\", e.bool = \"bool\";\n}(DType || (DType = {})), function (e) {\n  e.R0 = \"R0\", e.R1 = \"R1\", e.R2 = \"R2\", e.R3 = \"R3\", e.R4 = \"R4\", e.R5 = \"R5\", e.R6 = \"R6\";\n}(Rank || (exports.Rank = Rank = {})), function (e) {\n  e.float32 = \"float32\", e.int32 = \"int32\", e.bool = \"int32\", e.complex64 = \"complex64\";\n}(UpcastInt32AndMap || (UpcastInt32AndMap = {})), function (e) {\n  e.float32 = \"float32\", e.int32 = \"int32\", e.bool = \"bool\", e.complex64 = \"complex64\";\n}(UpcastBoolAndMap || (UpcastBoolAndMap = {})), function (e) {\n  e.float32 = \"float32\", e.int32 = \"float32\", e.bool = \"float32\", e.complex64 = \"complex64\";\n}(UpcastFloat32AndMap || (UpcastFloat32AndMap = {})), function (e) {\n  e.float32 = \"complex64\", e.int32 = \"complex64\", e.bool = \"complex64\", e.complex64 = \"complex64\";\n}(UpcastComplex64AndMap || (UpcastComplex64AndMap = {}));var upcastTypeMap = { float32: UpcastFloat32AndMap, int32: UpcastInt32AndMap, bool: UpcastBoolAndMap, complex64: UpcastComplex64AndMap };function upcastType(e, t) {\n  return upcastTypeMap[e][t];\n}function sumOutType(e) {\n  return upcastType(e, \"int32\");\n}function castTensor(e, t, n) {\n  if (\"complex64\" === t) {\n    if (\"complex64\" === e.dtype) return e.clone();var r = zeros(e.shape),\n        o = e.toFloat(),\n        a = n.complex(o, r);return r.dispose(), o.dispose(), a;\n  }if (!hasEncodingLoss(e.dtype, t)) return Tensor.make(e.shape, { dataId: e.dataId }, t);if (\"complex64\" === e.dtype) {\n    var i = n.real(e);a = i.cast(t);return i.dispose(), a;\n  }if (\"int32\" === t) return n.int(e);if (\"bool\" === t) {\n    var s = scalar(0, e.dtype);a = n.notEqual(e, s);return s.dispose(), a;\n  }throw new Error(\"Error in Cast: unknown dtype argument (\" + t + \")\");\n}function reshapeTensor(e, t) {\n  return Tensor.make(t, { dataId: e.dataId }, e.dtype);\n}function mergeRealAndImagArrays(e, t) {\n  if (e.length !== t.length) throw new Error(\"Cannot merge real and imag arrays of different lengths. real:\" + e.length + \", imag: \" + t.length + \".\");for (var n = new Float32Array(2 * e.length), r = 0; r < n.length; r += 2) n[r] = e[r / 2], n[r + 1] = t[r / 2];return n;\n}function nonMaxSuppressionImpl(e, t, n, r, o) {\n  for (var a = Array.from(t).map(function (e, t) {\n    return { score: e, boxIndex: t };\n  }).filter(function (e) {\n    return e.score > o;\n  }).sort(function (e, t) {\n    return t.score - e.score;\n  }), i = [], s = 0; s < a.length; s++) {\n    var u = a[s],\n        l = u.score,\n        c = u.boxIndex;if (l < o) break;for (var p = !1, d = i.length - 1; d >= 0; --d) {\n      if (intersectionOverUnion(e, c, i[d]) >= r) {\n        p = !0;break;\n      }\n    }if (!p && (i.push(c), i.length >= n)) break;\n  }return tensor1d(i, \"int32\");\n}function intersectionOverUnion(e, t, n) {\n  var r = e.subarray(4 * t, 4 * t + 4),\n      o = e.subarray(4 * n, 4 * n + 4),\n      a = Math.min(r[0], r[2]),\n      i = Math.min(r[1], r[3]),\n      s = Math.max(r[0], r[2]),\n      u = Math.max(r[1], r[3]),\n      l = Math.min(o[0], o[2]),\n      c = Math.min(o[1], o[3]),\n      p = Math.max(o[0], o[2]),\n      d = Math.max(o[1], o[3]),\n      h = (s - a) * (u - i),\n      f = (p - l) * (d - c);if (h <= 0 || f <= 0) return 0;var m = Math.max(a, l),\n      g = Math.max(i, c),\n      v = Math.min(s, p),\n      x = Math.min(u, d),\n      y = Math.max(v - m, 0) * Math.max(x - g, 0);return y / (h + f - y);\n}function split(e, t, n) {\n  var r = Array(e.rank).fill(0),\n      o = e.shape.slice();return t.map(function (t) {\n    o[n] = t;var a = e.slice(r, o);return r[n] += t, a;\n  });\n}function topkImpl(e, t, n, r, o) {\n  for (var a = t[t.length - 1], i = [e.length / a, a], s = i[0], u = i[1], l = getTypedArrayFromDType(n, s * r), c = getTypedArrayFromDType(\"int32\", s * r), p = 0; p < s; p++) {\n    for (var d = p * u, h = e.subarray(d, d + u), f = [], m = 0; m < h.length; m++) f.push({ value: h[m], index: m });f.sort(function (e, t) {\n      return t.value - e.value;\n    });var g = p * r,\n        v = l.subarray(g, g + r),\n        x = c.subarray(g, g + r);for (m = 0; m < r; m++) v[m] = f[m].value, x[m] = f[m].index;\n  }var y = t.slice();return y[y.length - 1] = r, [tensor(l, y, n), tensor(c, y, \"int32\")];\n}var ArgMinMaxProgram = function () {\n  return function (e, t, n) {\n    this.variableNames = [\"A\"];var r = e.windowSize,\n        o = e.batchSize,\n        a = e.inSize,\n        i = Math.ceil(a / r);n || this.variableNames.push(\"bestIndicesA\"), this.outputShape = [o, i];var s = \"max\" === t ? \">\" : \"<\",\n        u = n ? \"inOffset + i;\" : \"round(getBestIndicesA(batch, inOffset + i));\";this.userCode = \"\\n      void main() {\\n        ivec2 coords = getOutputCoords();\\n        int batch = coords[0];\\n        int outIdx = coords[1];\\n        int inOffset = outIdx * \" + r + \";\\n\\n        int bestIndex = 0;\\n        float bestValue = getA(batch, inOffset);\\n\\n        for (int i = 0; i < \" + r + \"; i++) {\\n          int inIdx = \" + u + \";\\n          float candidate = getA(batch, inIdx);\\n          if (candidate \" + s + \" bestValue) {\\n            bestValue = candidate;\\n            bestIndex = inIdx;\\n          }\\n        }\\n        setOutput(float(bestIndex));\\n      }\\n    \";\n  };\n}(),\n    AvgPool2DBackpropProgram = function () {\n  return function (e) {\n    this.variableNames = [\"dy\"], this.outputShape = e.inShape;var t = e.filterHeight,\n        n = e.filterWidth,\n        r = e.strideHeight,\n        o = e.strideWidth,\n        a = t - 1 - e.padInfo.top,\n        i = n - 1 - e.padInfo.left,\n        s = 1 / (t * n);this.userCode = \"\\n      const ivec2 pads = ivec2(\" + a + \", \" + i + \");\\n      const float avgMultiplier = float(\" + s + \");\\n\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int b = coords[0];\\n        int d = coords[3];\\n\\n        ivec2 dyRCCorner = coords.yz - pads;\\n        int dyRCorner = dyRCCorner.x;\\n        int dyCCorner = dyRCCorner.y;\\n\\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\\n        // ? = to be determined. : = across all values in that axis.\\n        float dotProd = 0.0;\\n        for (int wR = 0; wR < \" + t + \"; wR++) {\\n          float dyR = float(dyRCorner + wR) / \" + r + \".0;\\n\\n          if (dyR < 0.0 || dyR >= \" + e.outHeight + \".0 || fract(dyR) > 0.0) {\\n            continue;\\n          }\\n          int idyR = int(dyR);\\n\\n          for (int wC = 0; wC < \" + n + \"; wC++) {\\n            float dyC = float(dyCCorner + wC) / \" + o + \".0;\\n\\n            if (dyC < 0.0 || dyC >= \" + e.outWidth + \".0 ||\\n                fract(dyC) > 0.0) {\\n              continue;\\n            }\\n            int idyC = int(dyC);\\n\\n            float dyValue = getDy(b, idyR, idyC, d);\\n\\n            dotProd += dyValue * avgMultiplier;\\n          }\\n        }\\n        setOutput(dotProd);\\n      }\\n    \";\n  };\n}();function getBroadcastDims(e, t) {\n  for (var n = e.length, r = [], o = 0; o < n; o++) {\n    var a = n - 1 - o,\n        i = e[a] || 1;(t[t.length - 1 - o] || 1) > 1 && 1 === i && r.unshift(a);\n  }return r;\n}function getReductionAxes(e, t) {\n  for (var n = [], r = 0; r < t.length; r++) {\n    var o = e[e.length - r - 1],\n        a = t.length - r - 1,\n        i = t[a];(null == o || 1 === o && i > 1) && n.unshift(a);\n  }return n;\n}function broadcastDimsAreOuter(e) {\n  for (var t = 0; t < e.length; t++) if (e[t] !== t) return !1;return !0;\n}function assertAndGetBroadcastShape(e, t) {\n  for (var n = [], r = Math.max(e.length, t.length), o = 0; o < r; o++) {\n    var a = e[e.length - o - 1];null == a && (a = 1);var i = t[t.length - o - 1];if (null == i && (i = 1), 1 === a) n.unshift(i);else if (1 === i) n.unshift(a);else {\n      if (a !== i) throw Error(\"Operands could not be broadcast together with shapes \" + e + \" and \" + t + \".\");n.unshift(a);\n    }\n  }return n;\n}var BatchNormProgram = function () {\n  return function (e, t, n, r, o, a) {\n    this.outputShape = [], this.supportsBroadcasting = !0, this.variableNames = [\"x\", \"mean\", \"variance\"], assertAndGetBroadcastShape(e, t), assertAndGetBroadcastShape(e, n);var i = \"0.0\";null != r && (assertAndGetBroadcastShape(e, r), this.variableNames.push(\"offset\"), i = \"getOffsetAtOutCoords()\");var s = \"1.0\";null != o && (assertAndGetBroadcastShape(e, o), this.variableNames.push(\"scale\"), s = \"getScaleAtOutCoords()\"), this.outputShape = e, this.userCode = \"\\n      void main() {\\n        float x = getXAtOutCoords();\\n        float mean = getMeanAtOutCoords();\\n        float variance = getVarianceAtOutCoords();\\n        float offset = \" + i + \";\\n        float scale = \" + s + \";\\n        float inv = scale * inversesqrt(variance + float(\" + a + \"));\\n        setOutput((x - mean) * inv + offset);\\n      }\\n    \";\n  };\n}(),\n    COMPLEX_MULTIPLY = { REAL: \"return areal * breal - aimag * bimag;\", IMAG: \"return areal * bimag + aimag * breal;\" },\n    BinaryOpComplexProgram = function () {\n  return function (e, t, n) {\n    this.variableNames = [\"AReal\", \"AImag\", \"BReal\", \"BImag\"], this.supportsBroadcasting = !0, this.outputShape = assertAndGetBroadcastShape(t, n), this.userCode = \"\\n      float binaryOpComplex(\\n          float areal, float aimag, float breal, float bimag) {\\n        \" + e + \"\\n      }\\n\\n      void main() {\\n        float areal = getARealAtOutCoords();\\n        float aimag = getAImagAtOutCoords();\\n        float breal = getBRealAtOutCoords();\\n        float bimag = getBImagAtOutCoords();\\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\\n      }\\n    \";\n  };\n}(),\n    CHECK_NAN_SNIPPET = \"\\n  if (isNaN(a)) return a;\\n  if (isNaN(b)) return b;\\n\",\n    ADD = \"return a + b;\",\n    SUB = \"return a - b;\",\n    MUL = \"return a * b;\",\n    DIV = \"if (a == b) return 1.0;\\n  return a / b;\",\n    INT_DIV = \"\\n  float resultSign = sign(a) * sign(b);\\n  int ia = round(a);\\n  int ib = round(b);\\n  int result = ia / ib;\\n  int amodb = ia - ib * result;\\n\\n  if (resultSign < 0.0 && amodb != 0) {\\n    result -= 1;\\n  }\\n  return float(result);\\n\",\n    POW = \"\\nif(a < 0.0 && floor(b) < b){\\n  return NAN;\\n}\\nreturn (round(mod(b, 2.0)) == 0 || round(mod(b, 2.0)) == 2) ?\\n    pow(abs(a), b) : sign(a) * pow(abs(a), b);\\n\",\n    SQUARED_DIFFERENCE = \"return (a - b) * (a - b);\",\n    EQUAL = \"return float(a == b);\",\n    NOT_EQUAL = \"return float(a != b);\",\n    LESS = \"return float(a < b);\",\n    LESS_EQUAL = \"return float(a <= b);\",\n    GREATER = \"return float(a > b);\",\n    GREATER_EQUAL = \"return float(a >= b);\",\n    LOGICAL_AND = \"return float(a >= 1.0 && b >= 1.0);\",\n    LOGICAL_OR = \"return float(a >= 1.0 || b >= 1.0);\",\n    MAX = CHECK_NAN_SNIPPET + \"\\n  return max(a, b);\\n\",\n    MIN = CHECK_NAN_SNIPPET + \"\\n  return min(a, b);\\n\",\n    MOD = \"if (b == 0.0) return NAN;\\n  return mod(a, b);\",\n    ATAN2 = CHECK_NAN_SNIPPET + \"\\n  return atan(a, b);\\n\",\n    ELU_DER = \"return (b >= 1.0) ? a : a * (b + 1.0);\",\n    BinaryOpProgram = function () {\n  function e(e, t, n) {\n    this.variableNames = [\"A\", \"B\"], this.supportsBroadcasting = !0, this.outputShape = assertAndGetBroadcastShape(t, n), this.userCode = \"\\n      uniform float NAN;\\n      float binaryOperation(float a, float b) {\\n        \" + e + \"\\n      }\\n\\n      void main() {\\n        float a = getAAtOutCoords();\\n        float b = getBAtOutCoords();\\n        setOutput(binaryOperation(a, b));\\n      }\\n    \";\n  }return e.prototype.getCustomSetupFunc = function () {\n    var e = this;return function (t, n) {\n      null == e.startLoc && (e.startLoc = t.getUniformLocationNoThrow(n, \"NAN\"), null == e.startLoc) || t.gl.uniform1f(e.startLoc, NaN);\n    };\n  }, e;\n}(),\n    ClipProgram = function () {\n  return function (e, t, n) {\n    this.variableNames = [\"A\"], this.outputShape = e, this.userCode = \"\\n      void main() {\\n        float value = getAAtOutCoords();\\n        if (isNaN(value)) {\\n          setOutput(value);\\n          return;\\n        }\\n\\n        setOutput(clamp(value, float(\" + t + \"), float(\" + n + \")));\\n      }\\n    \";\n  };\n}(),\n    ConcatProgram = function () {\n  return function (e, t) {\n    this.variableNames = [\"A\", \"B\"], this.outputShape = [], this.outputShape = computeOutShape([e, t], 1), this.userCode = \"\\n      void main() {\\n        ivec2 coords = getOutputCoords();\\n        int yR = coords.x;\\n        int yC = coords.y;\\n\\n        float value = 0.0;\\n        if (yC < \" + e[1] + \") {\\n          value = getA(yR, yC);\\n        } else {\\n          yC -= \" + e[1] + \";\\n          value = getB(yR, yC);\\n        }\\n\\n        setOutput(value);\\n      }\\n    \";\n  };\n}(),\n    Conv2DDerFilterProgram = function () {\n  return function (e) {\n    this.variableNames = [\"x\", \"dy\"], this.outputShape = e.filterShape;var t = e.strideHeight,\n        n = e.strideWidth,\n        r = e.padInfo.top,\n        o = e.padInfo.left;this.userCode = \"\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int wR = coords.x;\\n        int wC = coords.y;\\n        int d1 = coords.z;\\n        int d2 = coords.w;\\n\\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\\n        // ? = to be determined. : = across all values in that axis.\\n        float dotProd = 0.0;\\n\\n        for (int b = 0; b < \" + e.batchSize + \"; b++) {\\n          for (int yR = 0; yR < \" + e.outHeight + \"; yR++) {\\n            int xR = wR + yR * \" + t + \" - \" + r + \";\\n\\n            if (xR < 0 || xR >= \" + e.inHeight + \") {\\n              continue;\\n            }\\n\\n            for (int yC = 0; yC < \" + e.outWidth + \"; yC++) {\\n              int xC = wC + yC * \" + n + \" - \" + o + \";\\n\\n              if (xC < 0 || xC >= \" + e.inWidth + \") {\\n                continue;\\n              }\\n\\n              float dyValue = getDy(b, yR, yC, d2);\\n              float xValue = getX(b, xR, xC, d1);\\n              dotProd += (xValue * dyValue);\\n            }\\n          }\\n        }\\n        setOutput(dotProd);\\n      }\\n    \";\n  };\n}(),\n    Conv2DDerInputProgram = function () {\n  return function (e) {\n    this.variableNames = [\"dy\", \"W\"], this.outputShape = e.inShape;var t = e.filterHeight,\n        n = e.filterWidth,\n        r = e.strideHeight,\n        o = e.strideWidth,\n        a = t - 1 - e.padInfo.top,\n        i = n - 1 - e.padInfo.left;this.userCode = \"\\n      const ivec2 pads = ivec2(\" + a + \", \" + i + \");\\n\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int batch = coords[0];\\n        int d1 = coords[3];\\n\\n        ivec2 dyCorner = coords.yz - pads;\\n        int dyRCorner = dyCorner.x;\\n        int dyCCorner = dyCorner.y;\\n\\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\\n        // ? = to be determined. : = across all values in that axis.\\n        float dotProd = 0.0;\\n        for (int wR = 0; wR < \" + t + \"; wR++) {\\n          float dyR = float(dyRCorner + wR) / \" + r + \".0;\\n\\n          if (dyR < 0.0 || dyR >= \" + e.outHeight + \".0 || fract(dyR) > 0.0) {\\n            continue;\\n          }\\n          int idyR = int(dyR);\\n\\n          int wRPerm = \" + t + \" - 1 - wR;\\n\\n          for (int wC = 0; wC < \" + n + \"; wC++) {\\n            float dyC = float(dyCCorner + wC) / \" + o + \".0;\\n\\n            if (dyC < 0.0 || dyC >= \" + e.outWidth + \".0 ||\\n                fract(dyC) > 0.0) {\\n              continue;\\n            }\\n            int idyC = int(dyC);\\n\\n            int wCPerm = \" + n + \" - 1 - wC;\\n\\n            for (int d2 = 0; d2 < \" + e.outChannels + \"; d2++) {\\n              float xValue = getDy(batch, idyR, idyC, d2);\\n              float wValue = getW(wRPerm, wCPerm, d1, d2);\\n              dotProd += xValue * wValue;\\n            }\\n          }\\n        }\\n        setOutput(dotProd);\\n      }\\n    \";\n  };\n}(),\n    DepthwiseConv2DDerFilterProgram = function () {\n  return function (e) {\n    this.variableNames = [\"x\", \"dy\"], this.outputShape = e.filterShape;var t = e.strideHeight,\n        n = e.strideWidth,\n        r = e.padInfo.top,\n        o = e.padInfo.left,\n        a = e.outChannels / e.inChannels;this.userCode = \"\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int wR = coords.x;\\n        int wC = coords.y;\\n        int d1 = coords.z;\\n        int dm = coords.w;\\n        int d2 = d1 * \" + a + \" + dm;\\n\\n        float dotProd = 0.0;\\n\\n        // TODO: Vec4 over the batch size\\n        for (int b = 0; b < \" + e.batchSize + \"; b++) {\\n          for (int yR = 0; yR < \" + e.outHeight + \"; yR++) {\\n            int xR = wR + yR * \" + t + \" - \" + r + \";\\n\\n            if (xR < 0 || xR >= \" + e.inHeight + \") {\\n              continue;\\n            }\\n\\n            for (int yC = 0; yC < \" + e.outWidth + \"; yC++) {\\n              int xC = wC + yC * \" + n + \" - \" + o + \";\\n\\n              if (xC < 0 || xC >= \" + e.inWidth + \") {\\n                continue;\\n              }\\n\\n              float dyValue = getDy(b, yR, yC, d2);\\n              float xValue = getX(b, xR, xC, d1);\\n              dotProd += (xValue * dyValue);\\n            }\\n          }\\n        }\\n        setOutput(dotProd);\\n      }\\n    \";\n  };\n}(),\n    DepthwiseConv2DDerInputProgram = function () {\n  return function (e) {\n    this.variableNames = [\"dy\", \"W\"], this.outputShape = e.inShape;var t = e.filterHeight,\n        n = e.filterWidth,\n        r = e.strideHeight,\n        o = e.strideWidth,\n        a = t - 1 - e.padInfo.top,\n        i = n - 1 - e.padInfo.left,\n        s = e.outChannels / e.inChannels;this.userCode = \"\\n      const ivec2 pads = ivec2(\" + a + \", \" + i + \");\\n\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int batch = coords[0];\\n        int d1 = coords[3];\\n        ivec2 dyCorner = coords.yz - pads;\\n        int dyRCorner = dyCorner.x;\\n        int dyCCorner = dyCorner.y;\\n\\n        float dotProd = 0.0;\\n\\n        for (int wR = 0; wR < \" + t + \"; wR++) {\\n          float dyR = float(dyRCorner + wR) / \" + r + \".0;\\n\\n          if (dyR < 0.0 || dyR >= \" + e.outHeight + \".0 || fract(dyR) > 0.0) {\\n            continue;\\n          }\\n          int idyR = int(dyR);\\n\\n          int wRPerm = \" + t + \" - 1 - wR;\\n\\n          for (int wC = 0; wC < \" + n + \"; wC++) {\\n            float dyC = float(dyCCorner + wC) / \" + o + \".0;\\n\\n            if (dyC < 0.0 || dyC >= \" + e.outWidth + \".0 ||\\n                fract(dyC) > 0.0) {\\n              continue;\\n            }\\n            int idyC = int(dyC);\\n\\n            int wCPerm = \" + n + \" - 1 - wC;\\n\\n            // TODO: Vec4 over the channelMul\\n            for (int dm = 0; dm < \" + s + \"; dm++) {\\n              int d2 = d1 * \" + s + \" + dm;\\n              float xValue = getDy(batch, idyR, idyC, d2);\\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\\n              dotProd += xValue * wValue;\\n            }\\n          }\\n        }\\n        setOutput(dotProd);\\n      }\\n    \";\n  };\n}(),\n    Conv2DProgram = function () {\n  return function (e) {\n    this.variableNames = [\"x\", \"W\"], this.outputShape = e.outShape;var t = e.padInfo.top,\n        n = e.padInfo.left,\n        r = e.strideHeight,\n        o = e.strideWidth,\n        a = e.dilationHeight,\n        i = e.dilationWidth,\n        s = e.filterHeight,\n        u = e.filterWidth,\n        l = 4 * Math.floor(e.inChannels / 4),\n        c = e.inChannels % 4;this.userCode = \"\\n      const ivec2 strides = ivec2(\" + r + \", \" + o + \");\\n      const ivec2 pads = ivec2(\" + t + \", \" + n + \");\\n\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int batch = coords[0];\\n        int d2 = coords[3];\\n\\n        ivec2 xRCCorner = coords.yz * strides - pads;\\n        int xRCorner = xRCCorner.x;\\n        int xCCorner = xRCCorner.y;\\n\\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\\n        // ? = to be determined. : = across all values in that axis.\\n        float dotProd = 0.0;\\n        for (int wR = 0; wR < \" + s + \"; wR++) {\\n          int xR = xRCorner + wR * \" + a + \";\\n\\n          if (xR < 0 || xR >= \" + e.inHeight + \") {\\n            continue;\\n          }\\n\\n          for (int wC = 0; wC < \" + u + \"; wC++) {\\n            int xC = xCCorner + wC * \" + i + \";\\n\\n            if (xC < 0 || xC >= \" + e.inWidth + \") {\\n              continue;\\n            }\\n\\n            for (int d1 = 0; d1 < \" + l + \"; d1 += 4) {\\n              vec4 xValues = vec4(\\n                getX(batch, xR, xC, d1),\\n                getX(batch, xR, xC, d1 + 1),\\n                getX(batch, xR, xC, d1 + 2),\\n                getX(batch, xR, xC, d1 + 3)\\n              );\\n              vec4 wValues = vec4(\\n                getW(wR, wC, d1, d2),\\n                getW(wR, wC, d1 + 1, d2),\\n                getW(wR, wC, d1 + 2, d2),\\n                getW(wR, wC, d1 + 3, d2)\\n              );\\n\\n              dotProd += dot(xValues, wValues);\\n            }\\n\\n            if (\" + (1 === c) + \") {\\n              dotProd +=\\n                getX(batch, xR, xC, \" + l + \") *\\n                getW(wR, wC, \" + l + \", d2);\\n            } else if (\" + (2 === c) + \") {\\n              vec2 xValues = vec2(\\n                getX(batch, xR, xC, \" + l + \"),\\n                getX(batch, xR, xC, \" + l + \" + 1)\\n              );\\n              vec2 wValues = vec2(\\n                getW(wR, wC, \" + l + \", d2),\\n                getW(wR, wC, \" + l + \" + 1, d2)\\n              );\\n              dotProd += dot(xValues, wValues);\\n            } else if (\" + (3 === c) + \") {\\n              vec3 xValues = vec3(\\n                getX(batch, xR, xC, \" + l + \"),\\n                getX(batch, xR, xC, \" + l + \" + 1),\\n                getX(batch, xR, xC, \" + l + \" + 2)\\n              );\\n              vec3 wValues = vec3(\\n                getW(wR, wC, \" + l + \", d2),\\n                getW(wR, wC, \" + l + \" + 1, d2),\\n                getW(wR, wC, \" + l + \" + 2, d2)\\n              );\\n              dotProd += dot(xValues, wValues);\\n            }\\n          }\\n        }\\n        setOutput(dotProd);\\n      }\\n    \";\n  };\n}(),\n    DepthwiseConv2DProgram = function () {\n  return function (e) {\n    this.variableNames = [\"x\", \"W\"], this.outputShape = e.outShape;var t = e.inHeight,\n        n = e.inWidth,\n        r = e.padInfo.top,\n        o = e.padInfo.left,\n        a = e.strideHeight,\n        i = e.strideWidth,\n        s = e.dilationHeight,\n        u = e.dilationWidth,\n        l = e.filterHeight,\n        c = e.filterWidth,\n        p = e.outChannels / e.inChannels;this.userCode = \"\\n      const ivec2 strides = ivec2(\" + a + \", \" + i + \");\\n      const ivec2 pads = ivec2(\" + r + \", \" + o + \");\\n\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int batch = coords.x;\\n        ivec2 xRCCorner = coords.yz * strides - pads;\\n        int d2 = coords.w;\\n        int d1 = d2 / \" + p + \";\\n        int q = d2 - d1 * \" + p + \";\\n\\n        int xRCorner = xRCCorner.x;\\n        int xCCorner = xRCCorner.y;\\n\\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\\n        // ? = to be determined. : = across all values in that axis.\\n        float dotProd = 0.0;\\n        // TODO(dsmilkov): Flatten the two for loops and vec4 the operations.\\n        for (int wR = 0; wR < \" + l + \"; wR++) {\\n          int xR = xRCorner + wR * \" + s + \";\\n\\n          if (xR < 0 || xR >= \" + t + \") {\\n            continue;\\n          }\\n\\n          for (int wC = 0; wC < \" + c + \"; wC++) {\\n            int xC = xCCorner + wC * \" + u + \";\\n\\n            if (xC < 0 || xC >= \" + n + \") {\\n              continue;\\n            }\\n\\n            float xVal = getX(batch, xR, xC, d1);\\n            float wVal = getW(wR, wC, d1, q);\\n            dotProd += xVal * wVal;\\n          }\\n        }\\n        setOutput(dotProd);\\n      }\\n    \";\n  };\n}(),\n    CropAndResizeProgram = function () {\n  return function (e, t, n, r, o) {\n    this.variableNames = [\"Image\", \"Boxes\", \"BoxInd\"], this.outputShape = [];var a = e[0],\n        i = e[1],\n        s = e[2],\n        u = e[3],\n        l = t[0],\n        c = n[0],\n        p = n[1];this.outputShape = [l, c, p, u];var d = \"bilinear\" === r ? 1 : 0,\n        h = [i - 1 + \".0\", s - 1 + \".0\"],\n        f = h[0],\n        m = h[1],\n        g = c > 1 ? [\"\" + (i - 1) / (c - 1), \"(y2-y1) * height_ratio\", \"y1*\" + f + \" + float(y)*(height_scale)\"] : [\"0.0\", \"0.0\", \"0.5 * (y1+y2) * \" + f],\n        v = g[0],\n        x = g[1],\n        y = g[2],\n        T = p > 1 ? [\"\" + (s - 1) / (p - 1), \"(x2-x1) * width_ratio\", \"x1*\" + m + \" + float(x)*(width_scale)\"] : [\"0.0\", \"0.0\", \"0.5 * (x1+x2) * \" + m],\n        b = T[0],\n        S = T[1],\n        E = T[2];this.userCode = \"\\n      const float height_ratio = float(\" + v + \");\\n      const float width_ratio = float(\" + b + \");\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int b = coords[0];\\n        int y = coords[1];\\n        int x = coords[2];\\n        int d = coords[3];\\n\\n        // get box vals\\n        float y1 = getBoxes(b,0);\\n        float x1 = getBoxes(b,1);\\n        float y2 = getBoxes(b,2);\\n        float x2 = getBoxes(b,3);\\n\\n        // get image in batch index\\n        int bInd = round(getBoxInd(b));\\n        if(bInd < 0 || bInd >= \" + a + \") {\\n          return;\\n        }\\n\\n        float height_scale = \" + x + \";\\n        float width_scale = \" + S + \";\\n\\n        float in_y = \" + y + \";\\n        if( in_y < 0.0 || in_y > \" + f + \" ) {\\n          setOutput(float(\" + o + \"));\\n          return;\\n        }\\n        float in_x = \" + E + \";\\n        if( in_x < 0.0 || in_x > \" + m + \" ) {\\n          setOutput(float(\" + o + \"));\\n          return;\\n        }\\n\\n        vec2 sourceFracIndexRC = vec2(in_y,in_x);\\n        if(\" + d + \" == 1) {\\n          // Compute the four integer indices.\\n          ivec2 sourceFloorRC = ivec2(sourceFracIndexRC);\\n          ivec2 sourceCeilRC = ivec2(ceil(sourceFracIndexRC));\\n\\n          float topLeft = getImage(b, sourceFloorRC.x, sourceFloorRC.y, d);\\n          float bottomLeft = getImage(b, sourceCeilRC.x, sourceFloorRC.y, d);\\n          float topRight = getImage(b, sourceFloorRC.x, sourceCeilRC.y, d);\\n          float bottomRight = getImage(b, sourceCeilRC.x, sourceCeilRC.y, d);\\n\\n          vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\\n\\n          float top = topLeft + (topRight - topLeft) * fracRC.y;\\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\\n          float newValue = top + (bottom - top) * fracRC.x;\\n          setOutput(newValue);\\n        } else {\\n          // Compute the coordinators of nearest neighbor point.\\n          ivec2 sourceNearestRC = ivec2(floor(\\n            sourceFracIndexRC + vec2(0.5,0.5)));\\n          float newValue = getImage(b, sourceNearestRC.x, sourceNearestRC.y, d);\\n          setOutput(newValue);\\n        }\\n      }\\n    \";\n  };\n}();function makeShader(e, t, n, r) {\n  var o = e.map(function (e) {\n    var t = sizeFromShape(e.shapeInfo.logicalShape);return e.shapeInfo.isUniform ? \"uniform float \" + e.name + (t > 1 ? \"[\" + t + \"]\" : \"\") + \";\" : \"uniform sampler2D \" + e.name + \";\";\n  });o = o.join(\"\\n\");var a,\n      i = e.map(function (e) {\n    return getInputSamplingSnippet(e, t, r);\n  }).join(\"\\n\"),\n      s = t.texShape;return a = t.isPacked ? getPackedOutputSamplingSnippet(t.logicalShape, s) : getOutputSamplingSnippet(t.logicalShape, s), [SHADER_PREFIX, FLOAT_TEXTURE_SAMPLE_SNIPPET, FLOAT_TEXTURE_SETOUTPUT_SNIPPET, o, a, i, n].join(\"\\n\");\n}function getSamplerFromInInfo(e) {\n  var t = e.shapeInfo.logicalShape;switch (t.length) {case 0:\n      return getSamplerScalar(e);case 1:\n      return getSampler1D(e);case 2:\n      return getSampler2D(e);case 3:\n      return getSampler3D(e);case 4:\n      return getSampler4D(e);case 5:\n      return getSampler5D(e);case 6:\n      return getSampler6D(e);default:\n      throw new Error(t.length + \"-D input sampling is not yet supported\");}\n}function getInputSamplingSnippet(e, t, n) {\n  var r = getSamplerFlat(e);return r += getSamplerFromInInfo(e), (n || arraysEqual(e.shapeInfo.logicalShape, t.logicalShape)) && (r += getSamplerAtOutputCoords(e, t, n)), r;\n}function getPackedOutputSamplingSnippet(e, t) {\n  switch (e.length) {case 0:\n      return getOutputScalarCoords();case 2:\n      return getOutputPacked2DCoords(e, t);default:\n      throw new Error(e.length + \"-D output packed sampling is not yet supported\");}\n}function getOutputSamplingSnippet(e, t) {\n  switch (e.length) {case 0:\n      return getOutputScalarCoords();case 1:\n      return getOutput1DCoords(e, t);case 2:\n      return getOutput2DCoords(e, t);case 3:\n      return getOutput3DCoords(e, t);case 4:\n      return getOutput4DCoords(e, t);case 5:\n      return getOutput5DCoords(e, t);case 6:\n      return getOutput6DCoords(e, t);default:\n      throw new Error(e.length + \"-D output sampling is not yet supported\");}\n}var SAMPLE_1D_SNIPPET = \"\\nvec2 UVfrom1D(int texNumR, int texNumC, int index) {\\n  int texR = index / texNumC;\\n  int texC = index - texR * texNumC;\\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\\n}\\n\",\n    SAMPLE_2D_SNIPPET = \"\\nvec2 UVfrom2D(int texNumR, int texNumC, int numC, int row, int col) {\\n  int index = row * numC + col;\\n  int texR = index / texNumC;\\n  int texC = index - texR * texNumC;\\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\\n}\\n\",\n    SAMPLE_3D_SNIPPET = \"\\nvec2 UVfrom3D(int texNumR, int texNumC, int stride0,\\n    int stride1, int row, int col, int depth) {\\n  // Explicitly use integer operations as dot() only works on floats.\\n  int index = row * stride0 + col * stride1 + depth;\\n  int texR = index / texNumC;\\n  int texC = index - texR * texNumC;\\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\\n}\\n\",\n    SAMPLE_4D_SNIPPET = \"\\nvec2 UVfrom4D(int texNumR, int texNumC, int stride0,\\n    int stride1, int stride2, int row, int col, int depth,\\n    int depth2) {\\n  // Explicitly use integer operations as dot() only works on floats.\\n  int index = row * stride0 + col * stride1 + depth * stride2 + depth2;\\n  int texR = index / texNumC;\\n  int texC = index - texR * texNumC;\\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\\n}\\n\",\n    SAMPLE_5D_SNIPPET = \"\\nvec2 UVfrom5D(int texNumR, int texNumC, int stride0,\\n    int stride1, int stride2, int stride3, int row, int col, int depth,\\n    int depth2, int depth3) {\\n  // Explicitly use integer operations as dot() only works on floats.\\n  int index = row * stride0 + col * stride1 +\\n              depth * stride2 + depth2 * stride3 + depth3;\\n  int texR = index / texNumC;\\n  int texC = index - texR * texNumC;\\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\\n}\\n\",\n    SAMPLE_6D_SNIPPET = \"\\nvec2 UVfrom6D(int texNumR, int texNumC, int stride0,\\n    int stride1, int stride2, int stride3, int stride4,\\n    int row, int col, int depth, int depth2, int depth3, int depth4) {\\n  // Explicitly use integer operations as dot() only works on floats.\\n  int index = row * stride0 + col * stride1 + depth * stride2 + depth2 *\\n    stride3 + depth3 * stride4 + depth4;\\n  int texR = index / texNumC;\\n  int texC = index - texR * texNumC;\\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\\n}\\n\",\n    FLOAT_TEXTURE_SAMPLE_SNIPPET = \"\\n  float sampleTexture(sampler2D textureSampler, vec2 uv) {\\n    return texture2D(textureSampler, uv).r;\\n  }\\n\",\n    FLOAT_TEXTURE_SETOUTPUT_SNIPPET = \"\\n  void setOutput(float val) {\\n    gl_FragColor = vec4(val, 0, 0, 0);\\n  }\\n\",\n    SHADER_PREFIX = \"\\n  precision highp float;\\n  precision highp int;\\n  varying vec2 resultUV;\\n  const vec2 halfCR = vec2(0.5, 0.5);\\n\\n  struct ivec5\\n  {\\n    int x;\\n    int y;\\n    int z;\\n    int w;\\n    int u;\\n  };\\n\\n  struct ivec6\\n  {\\n    int x;\\n    int y;\\n    int z;\\n    int w;\\n    int u;\\n    int v;\\n  };\\n\\n  bool isNaN(float val) {\\n    return (val < 0.0 || 0.0 < val || val == 0.0) ? false : true;\\n  }\\n\\n  bool hasNaN(vec4 values) {\\n    vec4 v1 = values * values;\\n    vec4 v2 = values * values;\\n    return any(notEqual(v1, v2));\\n  }\\n\\n  float getNaN(vec4 values) {\\n    return dot(vec4(1), values);\\n  }\\n\\n  int round(float value) {\\n    return int(floor(value + 0.5));\\n  }\\n\\n  int imod(int x, int y) {\\n    return x - y * (x / y);\\n  }\\n\\n  //Based on the work of Dave Hoskins\\n  //https://www.shadertoy.com/view/4djSRW\\n  #define HASHSCALE1 443.8975\\n  float random(float seed){\\n    vec2 p = resultUV * seed;\\n    vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\\n    p3 += dot(p3, p3.yzx + 19.19);\\n    return fract((p3.x + p3.y) * p3.z);\\n  }\\n\\n  \" + SAMPLE_1D_SNIPPET + \"\\n  \" + SAMPLE_2D_SNIPPET + \"\\n  \" + SAMPLE_3D_SNIPPET + \"\\n  \" + SAMPLE_4D_SNIPPET + \"\\n  \" + SAMPLE_5D_SNIPPET + \"\\n  \" + SAMPLE_6D_SNIPPET + \"\\n\";function getOutputScalarCoords() {\n  return \"\\n    int getOutputCoords() {\\n      return 0;\\n    }\\n  \";\n}function getOutput1DCoords(e, t) {\n  return 1 === t[0] ? \"\\n      int getOutputCoords() {\\n        return int(resultUV.x * \" + t[1] + \".0);\\n      }\\n    \" : 1 === t[1] ? \"\\n      int getOutputCoords() {\\n        return int(resultUV.y * \" + t[0] + \".0);\\n      }\\n    \" : \"\\n    int getOutputCoords() {\\n      ivec2 resTexRC = ivec2(resultUV.yx *\\n                             vec2(\" + t[0] + \", \" + t[1] + \"));\\n      return resTexRC.x * \" + t[1] + \" + resTexRC.y;\\n    }\\n  \";\n}function getOutput3DCoords(e, t) {\n  var n = e[1] * e[2],\n      r = e[2];return \"\\n    ivec3 getOutputCoords() {\\n      ivec2 resTexRC = ivec2(resultUV.yx *\\n                             vec2(\" + t[0] + \", \" + t[1] + \"));\\n      int index = resTexRC.x * \" + t[1] + \" + resTexRC.y;\\n      int r = index / \" + n + \";\\n      index -= r * \" + n + \";\\n      int c = index / \" + r + \";\\n      int d = index - c * \" + r + \";\\n      return ivec3(r, c, d);\\n    }\\n  \";\n}function getOutput4DCoords(e, t) {\n  var n = e[3],\n      r = e[2] * n,\n      o = e[1] * r;return \"\\n    ivec4 getOutputCoords() {\\n      ivec2 resTexRC = ivec2(resultUV.yx *\\n        vec2(\" + t[0] + \", \" + t[1] + \"));\\n      int index = resTexRC.x * \" + t[1] + \" + resTexRC.y;\\n\\n      int r = index / \" + o + \";\\n      index -= r * \" + o + \";\\n\\n      int c = index / \" + r + \";\\n      index -= c * \" + r + \";\\n\\n      int d = index / \" + n + \";\\n      int d2 = index - d * \" + n + \";\\n\\n      return ivec4(r, c, d, d2);\\n    }\\n  \";\n}function getOutput5DCoords(e, t) {\n  var n = e[4],\n      r = e[3] * n,\n      o = e[2] * r,\n      a = e[1] * o;return \"\\n    ivec5 getOutputCoords() {\\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(\" + t[0] + \",\\n                             \" + t[1] + \"));\\n\\n      int index = resTexRC.x * \" + t[1] + \" + resTexRC.y;\\n\\n      int r = index / \" + a + \";\\n      index -= r * \" + a + \";\\n\\n      int c = index / \" + o + \";\\n      index -= c * \" + o + \";\\n\\n      int d = index / \" + r + \";\\n      index -= d * \" + r + \";\\n\\n      int d2 = index  / \" + n + \";\\n      int d3 = index - d2 * \" + n + \";\\n\\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\\n      return outShape;\\n    }\\n  \";\n}function getOutput6DCoords(e, t) {\n  var n = e[5],\n      r = e[4] * n,\n      o = e[3] * r,\n      a = e[2] * o,\n      i = e[1] * a;return \"\\n    ivec6 getOutputCoords() {\\n      ivec2 resTexRC = ivec2(resultUV.yx *\\n        vec2(\" + t[0] + \", \" + t[1] + \"));\\n      int index = resTexRC.x * \" + t[1] + \" + resTexRC.y;\\n\\n      int r = index / \" + i + \";\\n      index -= r * \" + i + \";\\n\\n      int c = index / \" + a + \";\\n      index -= c * \" + a + \";\\n\\n      int d = index / \" + o + \";\\n      index -= d * \" + o + \";\\n\\n      int d2 = index / \" + r + \";\\n      index -= d2 * \" + r + \";\\n\\n      int d3 = index / \" + n + \";\\n      int d4 = index - d3 * \" + n + \";\\n\\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\\n      return result;\\n    }\\n  \";\n}function getOutputPacked2DCoords(e, t) {\n  return \"\\n    ivec2 getOutputCoords() {\\n      return 2 * ivec2(resultUV.yx * vec2(\" + Math.ceil(t[0] / 2) + \", \" + Math.ceil(t[1] / 2) + \"));\\n    }\\n  \";\n}function getOutput2DCoords(e, t) {\n  return arraysEqual(e, t) ? \"\\n      ivec2 getOutputCoords() {\\n        return ivec2(resultUV.yx * vec2(\" + t[0] + \", \" + t[1] + \"));\\n      }\\n    \" : 1 === e[1] ? \"\\n      ivec2 getOutputCoords() {\\n        ivec2 resTexRC = ivec2(resultUV.yx *\\n                               vec2(\" + t[0] + \", \" + t[1] + \"));\\n        int index = resTexRC.x * \" + t[1] + \" + resTexRC.y;\\n        return ivec2(index, 0);\\n      }\\n    \" : 1 === e[0] ? \"\\n      ivec2 getOutputCoords() {\\n        ivec2 resTexRC = ivec2(resultUV.yx *\\n                               vec2(\" + t[0] + \", \" + t[1] + \"));\\n        int index = resTexRC.x * \" + t[1] + \" + resTexRC.y;\\n        return ivec2(0, index);\\n      }\\n    \" : \"\\n    ivec2 getOutputCoords() {\\n      ivec2 resTexRC = ivec2(resultUV.yx *\\n                             vec2(\" + t[0] + \", \" + t[1] + \"));\\n      int index = resTexRC.x * \" + t[1] + \" + resTexRC.y;\\n      int r = index / \" + e[1] + \";\\n      int c = index - r * \" + e[1] + \";\\n      return ivec2(r, c);\\n    }\\n  \";\n}function getSamplerScalar(e) {\n  var t = e.name,\n      n = \"get\" + t.charAt(0).toUpperCase() + t.slice(1);return e.shapeInfo.isUniform ? \"float \" + n + \"() {return \" + t + \";}\" : \"\\n    float \" + n + \"() {\\n      return sampleTexture(\" + t + \", halfCR);\\n    }\\n  \";\n}function getSampler1D(e) {\n  var t = e.name,\n      n = \"get\" + t.charAt(0).toUpperCase() + t.slice(1);return \"\\n    float \" + n + \"(int index) {\\n      return \" + n + \"Flat(index);\\n    }\\n  \";\n}function getSampler2D(e) {\n  var t = e.shapeInfo.logicalShape,\n      n = e.name,\n      r = \"get\" + n.charAt(0).toUpperCase() + n.slice(1),\n      o = e.shapeInfo.texShape;if (null != o && arraysEqual(t, o)) {\n    var a = o[0];return \"\\n    float \" + r + \"(int row, int col) {\\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(\" + o[1] + \".0, \" + a + \".0);\\n      return sampleTexture(\" + n + \", uv);\\n    }\\n  \";\n  }var i = squeezeShape(t),\n      s = i.newShape,\n      u = i.keptDims,\n      l = s;if (l.length < t.length) {\n    return \"\\n      \" + getSamplerFromInInfo(squeezeInputInfo(e, l)) + \"\\n      float \" + r + \"(int row, int col) {\\n        return \" + r + \"(\" + getSqueezedParams([\"row\", \"col\"], u) + \");\\n      }\\n    \";\n  }if (e.shapeInfo.isUniform) return \"\\n      float \" + r + \"(int row, int col) {\\n        int index = row * \" + t[1] + \" + col;\\n        return \" + r + \"Flat(index);\\n      }\\n    \";var c = o[0],\n      p = o[1];return 1 === p ? \"\\n    float \" + r + \"(int row, int col) {\\n      int index = row * \" + t[1] + \" + col;\\n      vec2 uv = vec2(0.5, (float(index) + 0.5) / \" + c + \".0);\\n      return sampleTexture(\" + n + \", uv);\\n    }\\n  \" : 1 === c ? \"\\n    float \" + r + \"(int row, int col) {\\n      int index = row * \" + t[1] + \" + col;\\n      vec2 uv = vec2((float(index) + 0.5) / \" + p + \".0, 0.5);\\n      return sampleTexture(\" + n + \", uv);\\n    }\\n  \" : \"\\n  float \" + r + \"(int row, int col) {\\n    vec2 uv = UVfrom2D(\" + c + \", \" + p + \", \" + t[1] + \", row, col);\\n    return sampleTexture(\" + n + \", uv);\\n  }\\n\";\n}function getSampler3D(e) {\n  var t = e.shapeInfo.logicalShape,\n      n = e.name,\n      r = \"get\" + n.charAt(0).toUpperCase() + n.slice(1),\n      o = t[1] * t[2],\n      a = t[2],\n      i = squeezeShape(t),\n      s = i.newShape,\n      u = i.keptDims,\n      l = s;if (l.length < t.length) {\n    return \"\\n        \" + getSamplerFromInInfo(squeezeInputInfo(e, l)) + \"\\n        float \" + r + \"(int row, int col, int depth) {\\n          return \" + r + \"(\" + getSqueezedParams([\"row\", \"col\", \"depth\"], u) + \");\\n        }\\n      \";\n  }if (e.shapeInfo.isUniform) return \"\\n      float \" + r + \"(int row, int col, int depth) {\\n        int index = row * \" + o + \" + col * \" + a + \" + depth;\\n        return \" + r + \"Flat(index);\\n      }\\n    \";var c = e.shapeInfo.texShape,\n      p = c[0],\n      d = c[1];return d === o ? \"\\n        float \" + r + \"(int row, int col, int depth) {\\n          int texR = row;\\n          int texC = col * \" + a + \" + depth;\\n          vec2 uv = (vec2(texC, texR) + halfCR) /\\n                     vec2(\" + d + \".0, \" + p + \".0);\\n          return sampleTexture(\" + n + \", uv);\\n        }\\n      \" : d === a ? \"\\n    float \" + r + \"(int row, int col, int depth) {\\n      int texR = row * \" + t[1] + \" + col;\\n      int texC = depth;\\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(\" + d + \".0, \" + p + \".0);\\n      return sampleTexture(\" + n + \", uv);\\n    }\\n  \" : \"\\n      float \" + r + \"(int row, int col, int depth) {\\n        vec2 uv = UVfrom3D(\\n            \" + p + \", \" + d + \", \" + o + \", \" + a + \", row, col, depth);\\n        return sampleTexture(\" + n + \", uv);\\n      }\\n  \";\n}function getSampler4D(e) {\n  var t = e.shapeInfo.logicalShape,\n      n = e.name,\n      r = \"get\" + n.charAt(0).toUpperCase() + n.slice(1),\n      o = t[3],\n      a = t[2] * o,\n      i = t[1] * a,\n      s = squeezeShape(t),\n      u = s.newShape,\n      l = s.keptDims;if (u.length < t.length) {\n    return \"\\n      \" + getSamplerFromInInfo(squeezeInputInfo(e, u)) + \"\\n      float \" + r + \"(int row, int col, int depth, int depth2) {\\n        return \" + r + \"(\" + getSqueezedParams([\"row\", \"col\", \"depth\", \"depth2\"], l) + \");\\n      }\\n    \";\n  }if (e.shapeInfo.isUniform) return \"\\n      float \" + r + \"(int row, int col, int depth, int depth2) {\\n        int index = row * \" + i + \" + col * \" + a + \" +\\n            depth * \" + o + \" + depth2;\\n        return \" + r + \"Flat(index);\\n      }\\n    \";var c = e.shapeInfo.texShape,\n      p = c[0],\n      d = c[1];return d === i ? \"\\n      float \" + r + \"(int row, int col, int depth, int depth2) {\\n        int texR = row;\\n        int texC = col * \" + a + \" + depth * \" + o + \" + depth2;\\n        vec2 uv = (vec2(texC, texR) + halfCR) /\\n                   vec2(\" + d + \".0, \" + p + \".0);\\n        return sampleTexture(\" + n + \", uv);\\n      }\\n    \" : d === o ? \"\\n      float \" + r + \"(int row, int col, int depth, int depth2) {\\n        int texR = row * \" + t[1] * t[2] + \" + col * \" + t[2] + \" + depth;\\n        int texC = depth2;\\n        vec2 uv = (vec2(texC, texR) + halfCR) /\\n                  vec2(\" + d + \".0, \" + p + \".0);\\n        return sampleTexture(\" + n + \", uv);\\n      }\\n    \" : \"\\n    float \" + r + \"(int row, int col, int depth, int depth2) {\\n      vec2 uv = UVfrom4D(\" + p + \", \" + d + \", \" + i + \", \" + a + \",\\n          \" + o + \", row, col, depth, depth2);\\n      return sampleTexture(\" + n + \", uv);\\n    }\\n  \";\n}function getSampler5D(e) {\n  var t = e.shapeInfo.logicalShape,\n      n = e.name,\n      r = \"get\" + n.charAt(0).toUpperCase() + n.slice(1),\n      o = t[4],\n      a = t[3] * o,\n      i = t[2] * a,\n      s = t[1] * i,\n      u = squeezeShape(t),\n      l = u.newShape,\n      c = u.keptDims;if (l.length < t.length) {\n    return \"\\n      \" + getSamplerFromInInfo(squeezeInputInfo(e, l)) + \"\\n      float \" + r + \"(int row, int col, int depth, int depth2, int depth3) {\\n        return \" + r + \"(\" + getSqueezedParams([\"row\", \"col\", \"depth\", \"depth2\", \"depth3\"], c) + \");\\n      }\\n    \";\n  }if (e.shapeInfo.isUniform) return \"\\n      float \" + r + \"(int row, int col, int depth, int depth2, int depth3) {\\n        int index = row * \" + s + \" + col * \" + i + \" +\\n            depth * \" + a + \" + depth2 * \" + o + \" + depth3;\\n        return \" + r + \"Flat(index);\\n      }\\n    \";var p = e.shapeInfo.texShape,\n      d = p[0],\n      h = p[1];return h === s ? \"\\n      float \" + r + \"(int row, int col, int depth, int depth2, int depth3) {\\n        int texR = row;\\n        int texC = col * \" + i + \" + depth * \" + a + \" +\\n                   depth2 * \" + o + \" + depth3;\\n        vec2 uv = (vec2(texC, texR) + halfCR) /\\n                   vec2(\" + h + \".0, \" + d + \".0);\\n        return sampleTexture(\" + n + \", uv);\\n      }\\n    \" : h === o ? \"\\n      float \" + r + \"(int row, int col, int depth, int depth2, int depth3) {\\n        int texR = row * \" + t[1] * t[2] + \" + col * \" + t[2] + \" +\\n                   depth * \" + t[3] + \" + depth2;\\n        int texC = depth3;\\n        vec2 uv = (vec2(texC, texR) + halfCR) /\\n                  vec2(\" + h + \".0, \" + d + \".0);\\n        return sampleTexture(\" + n + \", uv);\\n      }\\n    \" : \"\\n    float \" + r + \"(int row, int col, int depth, int depth2, int depth3) {\\n      vec2 uv = UVfrom5D(\" + d + \", \" + h + \", \" + s + \", \" + i + \",\\n          \" + a + \", \" + o + \", row, col, depth, depth2, depth3);\\n      return sampleTexture(\" + n + \", uv);\\n    }\\n  \";\n}function getSampler6D(e) {\n  var t = e.shapeInfo.logicalShape,\n      n = e.name,\n      r = \"get\" + n.charAt(0).toUpperCase() + n.slice(1),\n      o = t[5],\n      a = t[4] * o,\n      i = t[3] * a,\n      s = t[2] * i,\n      u = t[1] * s,\n      l = squeezeShape(t),\n      c = l.newShape,\n      p = l.keptDims;if (c.length < t.length) {\n    return \"\\n      \" + getSamplerFromInInfo(squeezeInputInfo(e, c)) + \"\\n      float \" + r + \"(int row, int col, int depth,\\n                    int depth2, int depth3, int depth4) {\\n        return \" + r + \"(\" + getSqueezedParams([\"row\", \"col\", \"depth\", \"depth2\", \"depth3\", \"depth4\"], p) + \");\\n      }\\n    \";\n  }if (e.shapeInfo.isUniform) return \"\\n      float \" + r + \"(int row, int col, int depth,\\n                  int depth2, int depth3, int depth4) {\\n        int index = row * \" + u + \" + col * \" + s + \" +\\n            depth * \" + i + \" + depth2 * \" + a + \" + depth3 * \" + a + \"\\n            + depth4\\n        return \" + r + \"Flat(index);\\n      }\\n    \";var d = e.shapeInfo.texShape,\n      h = d[0],\n      f = d[1];return f === u ? \"\\n      float \" + r + \"(int row, int col, int depth,\\n                    int depth2, int depth3, int depth4) {\\n        int texR = row;\\n        int texC = col * \" + s + \" + depth * \" + i + \" + depth2;\\n        vec2 uv = (vec2(texC, texR) + halfCR) /\\n                   vec2(\" + f + \".0, \" + h + \".0);\\n        return sampleTexture(\" + n + \", uv);\\n      }\\n    \" : f === o ? \"\\n      float \" + r + \"(int row, int col, int depth,\\n                    int depth2, int depth3, int depth4) {\\n        int texR = row * \" + t[1] * t[2] + \" + col * \" + t[2] + \" + depth;\\n        int texC = depth4;\\n        vec2 uv = (vec2(texC, texR) + halfCR) /\\n                  vec2(\" + f + \".0, \" + h + \".0);\\n        return sampleTexture(\" + n + \", uv);\\n      }\\n    \" : \"\\n    float \" + r + \"(int row, int col, int depth,\\n                  int depth2, int depth3, int depth4) {\\n      vec2 uv = UVfrom6D(\" + h + \", \" + f + \", \" + u + \", \" + s + \",\\n          \" + i + \", \" + a + \", \" + o + \"\\n          ,row, col, depth, depth2, depth3, depth4);\\n      return sampleTexture(\" + n + \", uv);\\n    }\\n  \";\n}function getSamplerFlat(e) {\n  var t = e.name,\n      n = \"get\" + t.charAt(0).toUpperCase() + t.slice(1) + \"Flat\",\n      r = sizeFromShape(e.shapeInfo.logicalShape);if (e.shapeInfo.isUniform) return 1 === r ? \"float \" + n + \"(int index) {return \" + t + \";}\" : \"\\n      float \" + n + \"(int index) {\\n        for (int i = 0; i < \" + r + \"; i++) {\\n          if (i == index) {\\n            return \" + t + \"[i];\\n          }\\n        }\\n      }\\n    \";var o = e.shapeInfo.texShape,\n      a = o[0],\n      i = o[1];return 1 === i && 1 === a ? \"\\n      float \" + n + \"(int index) {\\n        return sampleTexture(\" + t + \", halfCR);\\n      }\\n    \" : 1 === i ? \"\\n      float \" + n + \"(int index) {\\n        vec2 uv = vec2(0.5, (float(index) + 0.5) / \" + a + \".0);\\n        return sampleTexture(\" + t + \", uv);\\n      }\\n    \" : 1 === a ? \"\\n      float \" + n + \"(int index) {\\n        vec2 uv = vec2((float(index) + 0.5) / \" + i + \".0, 0.5);\\n        return sampleTexture(\" + t + \", uv);\\n      }\\n    \" : \"\\n    float \" + n + \"(int index) {\\n      vec2 uv = UVfrom1D(\" + a + \", \" + i + \", index);\\n      return sampleTexture(\" + t + \", uv);\\n    }\\n  \";\n}function getBroadcastOutputCoordsSampler(e, t, n, r) {\n  var o = e.shapeInfo.logicalShape.length,\n      a = t.logicalShape.length,\n      i = \"int\";2 === a ? i = \"ivec2\" : 3 === a ? i = \"ivec3\" : 4 === a && (i = \"ivec4\");var s = getBroadcastDims(e.shapeInfo.logicalShape, t.logicalShape),\n      u = a - o;return \"\\n    float \" + r + \"() {\\n      \" + i + \" coords = getOutputCoords();\\n      \" + (0 === o ? \"\" : a < 2 && s.length >= 1 ? \"coords = 0;\" : s.map(function (e) {\n    return \"coords[\" + (e + u) + \"] = 0;\";\n  }).join(\"\\n\")) + \"\\n      return get\" + n + \"(\" + (a < 2 && o > 0 ? \"coords\" : e.shapeInfo.logicalShape.map(function (e, t) {\n    return \"coords[\" + (t + u) + \"]\";\n  }).join(\", \")) + \");\\n    }\\n  \";\n}function getSamplerAtOutputCoords(e, t, n) {\n  var r = e.name,\n      o = r.charAt(0).toUpperCase() + r.slice(1),\n      a = \"get\" + o + \"AtOutCoords\",\n      i = getBroadcastDims(e.shapeInfo.logicalShape, t.logicalShape),\n      s = e.shapeInfo.logicalShape.length,\n      u = t.logicalShape.length,\n      l = n && (u > s || i.length > 0),\n      c = broadcastDimsAreOuter(i),\n      p = e.shapeInfo.isUniform;if (l && !c) return getBroadcastOutputCoordsSampler(e, t, o, a);var d = sizeFromShape(e.shapeInfo.logicalShape),\n      h = \"\";l && c && (h = \"\\n        int mainPart = index / \" + d + \";\\n        index -= mainPart * \" + d + \";\\n      \");var f = t.texShape;if (p) return 1 === d ? \"float \" + a + \"() {return \" + r + \";}\" : \"\\n      float \" + a + \"() {\\n        ivec2 resTexRC = ivec2(resultUV.yx *\\n                              vec2(\" + f[0] + \", \" + f[1] + \"));\\n        int index = resTexRC.x * \" + f[1] + \" + resTexRC.y;\\n        \" + h + \"\\n        return get\" + o + \"Flat(index);\\n      }\\n    \";var m = e.shapeInfo.texShape;return arraysEqual(m, f) ? \"\\n      float \" + a + \"() {\\n        return sampleTexture(\" + r + \", resultUV);\\n      }\\n    \" : \"\\n    float \" + a + \"() {\\n      ivec2 resTexRC = ivec2(resultUV.yx *\\n                             vec2(\" + f[0] + \", \" + f[1] + \"));\\n      int index = resTexRC.x * \" + f[1] + \" + resTexRC.y;\\n      \" + h + \"\\n      int texR = index / \" + m[1] + \";\\n      int texC = index - texR * \" + m[1] + \";\\n      vec2 uv = (vec2(texC, texR) + halfCR) /\\n                 vec2(\" + m[1] + \".0, \" + m[0] + \".0);\\n\\n      return sampleTexture(\" + r + \", uv);\\n    }\\n  \";\n}function getCoordsDataType(e) {\n  if (e <= 1) return \"int\";if (2 === e) return \"ivec2\";if (3 === e) return \"ivec3\";if (4 === e) return \"ivec4\";if (5 === e) return \"ivec5\";if (6 === e) return \"ivec6\";throw Error(\"GPU for rank \" + e + \" is not yet supported\");\n}function squeezeInputInfo(e, t) {\n  var n = JSON.parse(JSON.stringify(e));return n.shapeInfo.logicalShape = t, n;\n}function getSqueezedParams(e, t) {\n  return t.map(function (t) {\n    return e[t];\n  }).join(\", \");\n}var CumSumProgram = function () {\n  return function (e, t, n) {\n    this.variableNames = [\"x\"], this.outputShape = e;var r = e.length,\n        o = e[e.length - 1],\n        a = n ? \"<\" : \">\";this.userCode = \"\\n      int getIndex(int i) {\\n        \" + (n ? \"return \" + o + \" -i - 1;\" : \"return i;\") + \"\\n      }\\n\\n      void main() {\\n        \" + getCoordsDataType(r) + \" coords = getOutputCoords();\\n        int end = \" + getFinalCoord(r, \"coords\") + \";\\n        float val = 0.0;\\n        for (int i = \" + o + \" - 1; i >= 0; i -= 1) {\\n          int idx = getIndex(i);\\n          if (idx \" + a + \" end) {\\n            continue;\\n          }\\n          if (idx == end && \" + t + \") {\\n            continue;\\n          }\\n          \" + getFinalCoord(r, \"coords\") + \" = idx;\\n          val += getX(\" + getCoords(r, \"coords\") + \");\\n        }\\n        setOutput(val);\\n      }\\n    \";\n  };\n}();function getCoords(e, t) {\n  if (1 === e) return \"\" + t;if (2 === e) return t + \".x, \" + t + \".y\";if (3 === e) return t + \".x, \" + t + \".y, \" + t + \".z\";if (4 === e) return t + \".x, \" + t + \".y, \" + t + \".z, \" + t + \".w\";throw Error(\"Cumulative sum for rank \" + e + \" is not yet supported\");\n}function getFinalCoord(e, t) {\n  if (1 === e) return \"\" + t;if (2 === e) return t + \".y\";if (3 === e) return t + \".z\";if (4 === e) return t + \".w\";throw Error(\"Cumulative sum for rank \" + e + \" is not yet supported\");\n}var TextureUsage,\n    PhysicalTextureType,\n    DepthToSpaceProgram = function () {\n  function e(e, t, n) {\n    this.variableNames = [\"x\"], this.outputShape = [], this.outputShape = e, this.blockSize = t, this.dataFormat = n, this.userCode = \"\\n    void main() {\\n      ivec4 coords = getOutputCoords();\\n      int b = coords[0];\\n      int h = \" + this.getHeightCoordString() + \";\\n      int w = \" + this.getWidthCoordString() + \";\\n      int d = \" + this.getDepthCoordString() + \";\\n\\n      int in_h = h / \" + t + \";\\n      int offset_h = imod(h, \" + t + \");\\n      int in_w = w / \" + t + \";\\n      int offset_w = imod(w, \" + t + \");\\n      int offset_d = (offset_h * \" + t + \" + offset_w) *\\n        \" + this.getOutputDepthSize() + \";\\n      int in_d = d + offset_d;\\n\\n      float result = \" + this.getInputSamplingString() + \";\\n      setOutput(result);\\n    }\\n  \";\n  }return e.prototype.getHeightCoordString = function () {\n    return \"NHWC\" === this.dataFormat ? \"coords[1]\" : \"coords[2]\";\n  }, e.prototype.getWidthCoordString = function () {\n    return \"NHWC\" === this.dataFormat ? \"coords[2]\" : \"coords[3]\";\n  }, e.prototype.getDepthCoordString = function () {\n    return \"NHWC\" === this.dataFormat ? \"coords[3]\" : \"coords[1]\";\n  }, e.prototype.getOutputDepthSize = function () {\n    return \"NHWC\" === this.dataFormat ? this.outputShape[3] : this.outputShape[1];\n  }, e.prototype.getInputSamplingString = function () {\n    return \"NHWC\" === this.dataFormat ? \"getX(b, in_h, in_w, in_d)\" : \"getX(b, in_d, in_h, in_w)\";\n  }, e;\n}(),\n    EncodeFloatProgram = function () {\n  return function (e) {\n    this.variableNames = [\"A\"], this.outputShape = e, this.userCode = \"\\n      const float FLOAT_MAX = 1.70141184e38;\\n      const float FLOAT_MIN = 1.17549435e-38;\\n\\n      lowp vec4 encode_float(highp float v) {\\n        if (isNaN(v)) {\\n          return vec4(255, 255, 255, 255);\\n        }\\n\\n        highp float av = abs(v);\\n\\n        if(av < FLOAT_MIN) {\\n          return vec4(0.0, 0.0, 0.0, 0.0);\\n        } else if(v > FLOAT_MAX) {\\n          return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\\n        } else if(v < -FLOAT_MAX) {\\n          return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\\n        }\\n\\n        highp vec4 c = vec4(0,0,0,0);\\n\\n        highp float e = floor(log2(av));\\n        highp float m = exp2(fract(log2(av))) - 1.0;\\n\\n        c[2] = floor(128.0 * m);\\n        m -= c[2] / 128.0;\\n        c[1] = floor(32768.0 * m);\\n        m -= c[1] / 32768.0;\\n        c[0] = floor(8388608.0 * m);\\n\\n        highp float ebias = e + 127.0;\\n        c[3] = floor(ebias / 2.0);\\n        ebias -= c[3] * 2.0;\\n        c[2] += floor(ebias) * 128.0;\\n\\n        c[3] += 128.0 * step(0.0, -v);\\n\\n        return c / 255.0;\\n      }\\n\\n      void main() {\\n        float x = getAAtOutCoords();\\n        gl_FragColor = encode_float(x);\\n      }\\n    \";\n  };\n}(),\n    FromPixelsProgram = function () {\n  return function (e) {\n    this.variableNames = [\"A\"];var t = e[0],\n        n = e[1];this.outputShape = e, this.userCode = \"\\n      void main() {\\n        ivec3 coords = getOutputCoords();\\n        int texR = coords[0];\\n        int texC = coords[1];\\n        int depth = coords[2];\\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(\" + n + \".0, \" + t + \".0);\\n\\n        vec4 values = texture2D(A, uv);\\n        float value;\\n        if (depth == 0) {\\n          value = values.r;\\n        } else if (depth == 1) {\\n          value = values.g;\\n        } else if (depth == 2) {\\n          value = values.b;\\n        } else if (depth == 3) {\\n          value = values.a;\\n        }\\n\\n        setOutput(floor(value * 255.0 + 0.5));\\n      }\\n    \";\n  };\n}(),\n    GatherProgram = function () {\n  return function (e, t, n) {\n    this.variableNames = [\"A\", \"indices\"];var r = e.slice();r[n] = t, this.outputShape = r, this.rank = r.length;var o = getCoordsDataType(this.rank),\n        a = getSourceCoords(e, n);this.userCode = \"\\n      void main() {\\n        \" + o + \" resRC = getOutputCoords();\\n        setOutput(getA(\" + a + \"));\\n      }\\n    \";\n  };\n}();function getSourceCoords(e, t) {\n  var n = e.length;if (n > 4) throw Error(\"Gather for rank \" + n + \" is not yet supported\");if (1 === n) return \"int(getIndices(resRC))\";for (var r = [\"resRC.x\", \"resRC.y\", \"resRC.z\", \"resRC.w\"], o = [], a = 0; a < e.length; a++) a === t ? o.push(\"int(getIndices(\" + r[a] + \"))\") : o.push(\"\" + r[a]);return o.join();\n}function getUnpackedMatrixTextureShapeWidthHeight(e, t) {\n  return [t, e];\n}function getUnpackedArraySizeFromMatrixSize(e, t) {\n  return e * t;\n}function getMatrixSizeFromUnpackedArraySize(e, t) {\n  if (e % t != 0) throw new Error(\"unpackedSize (\" + e + \") must be a multiple of \" + t);return e / t;\n}function encodeMatrixToUnpackedArray(e, t, n) {\n  var r = getUnpackedArraySizeFromMatrixSize(e.length, n);if (t.length < r) throw new Error(\"unpackedArray length (\" + t.length + \") must be >= \" + r);for (var o = 0, a = 0; a < e.length; ++a) t[o] = e[a], o += n;\n}function decodeMatrixFromUnpackedArray(e, t, n) {\n  var r = getMatrixSizeFromUnpackedArraySize(e.length, n);if (t.length < r) throw new Error(\"matrix length (\" + t.length + \") must be >= \" + r);for (var o = 0, a = 0; a < e.length; a += n) t[o++] = e[a];\n}function getPackedMatrixTextureShapeWidthHeight(e, t) {\n  return [Math.ceil(t / 2), Math.ceil(e / 2)];\n}function getPackedRGBAArraySizeFromMatrixShape(e, t) {\n  var n = getPackedMatrixTextureShapeWidthHeight(e, t);return n[0] * n[1] * 4;\n}function encodeMatrixToPackedRGBA(e, t, n, r) {\n  var o = getPackedRGBAArraySizeFromMatrixShape(t, n);if (r.length < o) throw new Error(\"packedRGBA length (\" + r.length + \") must be >= \" + o);for (var a = getPackedMatrixTextureShapeWidthHeight(t, n), i = a[0], s = a[1], u = n % 2 == 1, l = t % 2 == 1, c = Math.floor(n / 2), p = Math.floor(t / 2), d = u ? 4 : 0, h = n, f = 0, m = 0; m < p; ++m) {\n    for (var g = 2 * m * n, v = 0; v < c; ++v) {\n      var x = g + 2 * v;r[f] = e[x], r[f + 1] = e[x + 1], r[f + 2] = e[x + h], r[f + 3] = e[x + h + 1], f += 4;\n    }f += d;\n  }if (u) {\n    x = n - 1, f = 4 * (i - 1);var y = 2 * n;for (d = 4 * i, m = 0; m < p; ++m) r[f] = e[x], r[f + 2] = e[x + n], x += y, f += d;\n  }if (l) for (x = (t - 1) * n, f = (s - 1) * i * 4, v = 0; v < c; ++v) r[f++] = e[x++], r[f++] = e[x++], f += 2;return u && l && (r[r.length - 4] = e[e.length - 1]), r;\n}function decodeMatrixFromPackedRGBA(e, t, n, r) {\n  var o = t * n;if (o < r.length) throw new Error(\"matrix length (\" + r.length + \") must be >= \" + o);for (var a = n % 2 == 1, i = t % 2 == 1, s = Math.floor(n / 2), u = Math.floor(t / 2), l = getPackedMatrixTextureShapeWidthHeight(t, n), c = l[0], p = l[1], d = a ? 4 : 0, h = n + (a ? 1 : 0), f = 0, m = 0, g = n, v = 0; v < u; ++v) {\n    for (var x = 0; x < s; ++x) r[m++] = e[f++], r[m++] = e[f++], r[g++] = e[f++], r[g++] = e[f++];f += d, m += h, g += h;\n  }if (a) {\n    f = 4 * (c - 1);var y = n - 1;for (d = 4 * c, h = 2 * n, v = 0; v < u; ++v) r[y] = e[f], r[y + n] = e[f + 2], f += d, y += h;\n  }if (i) for (f = (p - 1) * c * 4, y = (t - 1) * n, x = 0; x < s; ++x) r[y++] = e[f++], r[y++] = e[f++], f += 2;return a && i && (r[r.length - 1] = e[e.length - 4]), r;\n}!function (e) {\n  e[e.RENDER = 0] = \"RENDER\", e[e.UPLOAD = 1] = \"UPLOAD\", e[e.PIXELS = 2] = \"PIXELS\", e[e.DOWNLOAD = 3] = \"DOWNLOAD\", e[e.PACK = 4] = \"PACK\";\n}(TextureUsage || (TextureUsage = {})), function (e) {\n  e[e.UNPACKED_FLOAT16 = 0] = \"UNPACKED_FLOAT16\", e[e.UNPACKED_FLOAT32 = 1] = \"UNPACKED_FLOAT32\", e[e.PACKED_4X1_UNSIGNED_BYTE = 2] = \"PACKED_4X1_UNSIGNED_BYTE\", e[e.PACKED_2X2_FLOAT32 = 3] = \"PACKED_2X2_FLOAT32\";\n}(PhysicalTextureType || (PhysicalTextureType = {}));var MAX_TEXTURE_SIZE = null;function createWebGLRenderingContext(e) {\n  var t = document.createElement(\"canvas\");return t.width = 1, t.height = 1, createWebGLRenderingContextFromCanvas(t, e);\n}function createWebGLRenderingContextFromCanvas(e, t) {\n  var n,\n      r = ENV.get(\"WEBGL_VERSION\");if (2 === r ? n = e.getContext(\"webgl2\", t) : 1 === r && (n = e.getContext(\"webgl\", t) || e.getContext(\"experimental-webgl\", t)), 0 === r || null == n) throw new Error(\"This browser does not support WebGL.\");return n;\n}function callAndCheck(e, t) {\n  var n = t();return checkWebGLError(e), n;\n}var webGLDebugErrorCheckingEnabled = !1;function enableDebugWebGLErrorChecking(e) {\n  webGLDebugErrorCheckingEnabled = e;\n}function checkWebGLError(e) {\n  if (webGLDebugErrorCheckingEnabled) {\n    var t = e.getError();if (t !== e.NO_ERROR) throw new Error(\"WebGL Error: \" + getWebGLErrorMessage(e, t));\n  }\n}function getWebGLErrorMessage(e, t) {\n  switch (t) {case e.NO_ERROR:\n      return \"NO_ERROR\";case e.INVALID_ENUM:\n      return \"INVALID_ENUM\";case e.INVALID_VALUE:\n      return \"INVALID_VALUE\";case e.INVALID_OPERATION:\n      return \"INVALID_OPERATION\";case e.INVALID_FRAMEBUFFER_OPERATION:\n      return \"INVALID_FRAMEBUFFER_OPERATION\";case e.OUT_OF_MEMORY:\n      return \"OUT_OF_MEMORY\";case e.CONTEXT_LOST_WEBGL:\n      return \"CONTEXT_LOST_WEBGL\";default:\n      return \"Unknown error code \" + t;}\n}function getExtensionOrThrow(e, t) {\n  return throwIfNull(e, function () {\n    return e.getExtension(t);\n  }, 'Extension \"' + t + '\" not supported on this browser.');\n}function createVertexShader(e, t) {\n  var n = throwIfNull(e, function () {\n    return e.createShader(e.VERTEX_SHADER);\n  }, \"Unable to create vertex WebGLShader.\");if (callAndCheck(e, function () {\n    return e.shaderSource(n, t);\n  }), callAndCheck(e, function () {\n    return e.compileShader(n);\n  }), !1 === e.getShaderParameter(n, e.COMPILE_STATUS)) throw console.log(e.getShaderInfoLog(n)), new Error(\"Failed to compile vertex shader.\");return n;\n}function createFragmentShader(e, t) {\n  var n = throwIfNull(e, function () {\n    return e.createShader(e.FRAGMENT_SHADER);\n  }, \"Unable to create fragment WebGLShader.\");if (callAndCheck(e, function () {\n    return e.shaderSource(n, t);\n  }), callAndCheck(e, function () {\n    return e.compileShader(n);\n  }), !1 === e.getShaderParameter(n, e.COMPILE_STATUS)) throw logShaderSourceAndInfoLog(t, e.getShaderInfoLog(n)), new Error(\"Failed to compile fragment shader.\");return n;\n}var lineNumberRegex = /ERROR: [0-9]+:([0-9]+):/g;function logShaderSourceAndInfoLog(e, t) {\n  var n = lineNumberRegex.exec(t);if (null == n) return console.log(\"Couldn't parse line number in error: \" + t), void console.log(e);for (var r = +n[1], o = e.split(\"\\n\"), a = o.length.toString().length + 2, i = o.map(function (e, t) {\n    return rightPad((t + 1).toString(), a) + e;\n  }), s = 0, u = 0; u < i.length; u++) s = Math.max(i[u].length, s);var l = i.slice(0, r - 1),\n      c = i.slice(r - 1, r),\n      p = i.slice(r);console.log(l.join(\"\\n\")), console.log(t.split(\"\\n\")[0]), console.log(\"%c \" + rightPad(c[0], s), \"border:1px solid red; background-color:#e3d2d2; color:#a61717\"), console.log(p.join(\"\\n\"));\n}function createProgram(e) {\n  return throwIfNull(e, function () {\n    return e.createProgram();\n  }, \"Unable to create WebGLProgram.\");\n}function linkProgram(e, t) {\n  if (callAndCheck(e, function () {\n    return e.linkProgram(t);\n  }), !1 === e.getProgramParameter(t, e.LINK_STATUS)) throw console.log(e.getProgramInfoLog(t)), new Error(\"Failed to link vertex and fragment shaders.\");\n}function validateProgram(e, t) {\n  if (callAndCheck(e, function () {\n    return e.validateProgram(t);\n  }), !1 === e.getProgramParameter(t, e.VALIDATE_STATUS)) throw console.log(e.getProgramInfoLog(t)), new Error(\"Shader program validation failed.\");\n}function createStaticVertexBuffer(e, t) {\n  var n = throwIfNull(e, function () {\n    return e.createBuffer();\n  }, \"Unable to create WebGLBuffer\");return callAndCheck(e, function () {\n    return e.bindBuffer(e.ARRAY_BUFFER, n);\n  }), callAndCheck(e, function () {\n    return e.bufferData(e.ARRAY_BUFFER, t, e.STATIC_DRAW);\n  }), n;\n}function createStaticIndexBuffer(e, t) {\n  var n = throwIfNull(e, function () {\n    return e.createBuffer();\n  }, \"Unable to create WebGLBuffer\");return callAndCheck(e, function () {\n    return e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, n);\n  }), callAndCheck(e, function () {\n    return e.bufferData(e.ELEMENT_ARRAY_BUFFER, t, e.STATIC_DRAW);\n  }), n;\n}function queryMaxTextureSize(e) {\n  return null != MAX_TEXTURE_SIZE ? MAX_TEXTURE_SIZE : MAX_TEXTURE_SIZE = callAndCheck(e, function () {\n    return e.getParameter(e.MAX_TEXTURE_SIZE);\n  });\n}function getNumChannels() {\n  return 2 === ENV.get(\"WEBGL_VERSION\") ? 1 : 4;\n}function createTexture(e) {\n  return throwIfNull(e, function () {\n    return e.createTexture();\n  }, \"Unable to create WebGLTexture.\");\n}function validateTextureSize(e, t, n) {\n  var r = queryMaxTextureSize(e);if (t <= 0 || n <= 0) {\n    var o = \"[\" + t + \"x\" + n + \"]\";throw new Error(\"Requested texture size \" + o + \" is invalid.\");\n  }if (t > r || n > r) {\n    o = \"[\" + t + \"x\" + n + \"]\";throw new Error(\"Requested texture size \" + o + \" greater than WebGL maximum on this browser / GPU \" + (\"[\" + r + \"x\" + r + \"]\") + \".\");\n  }\n}function createFramebuffer(e) {\n  return throwIfNull(e, function () {\n    return e.createFramebuffer();\n  }, \"Unable to create WebGLFramebuffer.\");\n}function bindVertexBufferToProgramAttribute(e, t, n, r, o, a, i) {\n  var s = e.getAttribLocation(t, n);return -1 !== s && (callAndCheck(e, function () {\n    return e.bindBuffer(e.ARRAY_BUFFER, r);\n  }), callAndCheck(e, function () {\n    return e.vertexAttribPointer(s, o, e.FLOAT, !1, a, i);\n  }), callAndCheck(e, function () {\n    return e.enableVertexAttribArray(s);\n  }), !0);\n}function bindTextureUnit(e, t, n) {\n  validateTextureUnit(e, n), callAndCheck(e, function () {\n    return e.activeTexture(e.TEXTURE0 + n);\n  }), callAndCheck(e, function () {\n    return e.bindTexture(e.TEXTURE_2D, t);\n  });\n}function unbindTextureUnit(e, t) {\n  validateTextureUnit(e, t), callAndCheck(e, function () {\n    return e.activeTexture(e.TEXTURE0 + t);\n  }), callAndCheck(e, function () {\n    return e.bindTexture(e.TEXTURE_2D, null);\n  });\n}function getProgramUniformLocationOrThrow(e, t, n) {\n  return throwIfNull(e, function () {\n    return e.getUniformLocation(t, n);\n  }, 'uniform \"' + n + '\" not present in program.');\n}function getProgramUniformLocation(e, t, n) {\n  return e.getUniformLocation(t, n);\n}function bindTextureToProgramUniformSampler(e, t, n, r, o) {\n  callAndCheck(e, function () {\n    return bindTextureUnit(e, n, o);\n  }), callAndCheck(e, function () {\n    return e.uniform1i(r, o);\n  });\n}function bindCanvasToFramebuffer(e) {\n  callAndCheck(e, function () {\n    return e.bindFramebuffer(e.FRAMEBUFFER, null);\n  }), callAndCheck(e, function () {\n    return e.viewport(0, 0, e.canvas.width, e.canvas.height);\n  }), callAndCheck(e, function () {\n    return e.scissor(0, 0, e.canvas.width, e.canvas.height);\n  });\n}function bindColorTextureToFramebuffer(e, t, n) {\n  callAndCheck(e, function () {\n    return e.bindFramebuffer(e.FRAMEBUFFER, n);\n  }), callAndCheck(e, function () {\n    return e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, t, 0);\n  });\n}function unbindColorTextureFromFramebuffer(e, t) {\n  callAndCheck(e, function () {\n    return e.bindFramebuffer(e.FRAMEBUFFER, t);\n  }), callAndCheck(e, function () {\n    return e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, null, 0);\n  });\n}function validateFramebuffer(e) {\n  var t = e.checkFramebufferStatus(e.FRAMEBUFFER);if (t !== e.FRAMEBUFFER_COMPLETE) throw new Error(\"Error binding framebuffer: \" + getFramebufferErrorMessage(e, t));\n}function getFramebufferErrorMessage(e, t) {\n  switch (t) {case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:\n      return \"FRAMEBUFFER_INCOMPLETE_ATTACHMENT\";case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:\n      return \"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT\";case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:\n      return \"FRAMEBUFFER_INCOMPLETE_DIMENSIONS\";case e.FRAMEBUFFER_UNSUPPORTED:\n      return \"FRAMEBUFFER_UNSUPPORTED\";default:\n      return \"unknown error \" + t;}\n}function throwIfNull(e, t, n) {\n  var r = callAndCheck(e, function () {\n    return t();\n  });if (null == r) throw new Error(n);return r;\n}function validateTextureUnit(e, t) {\n  var n = e.MAX_COMBINED_TEXTURE_IMAGE_UNITS - 1,\n      r = t + e.TEXTURE0;if (r < e.TEXTURE0 || r > n) throw new Error(\"textureUnit must be in \" + (\"[gl.TEXTURE0, gl.TEXTURE\" + n + \"]\") + \".\");\n}function getTextureShapeFromLogicalShape(e, t) {\n  2 !== t.length && (t = squeezeShape(t).newShape);var n = queryMaxTextureSize(e),\n      r = sizeFromShape(t);return t.length <= 1 && r <= n ? [r, 1] : 2 === t.length && t[0] <= n && t[1] <= n ? t : 3 === t.length && t[0] <= n && t[1] * t[2] <= n ? [t[0], t[1] * t[2]] : 4 === t.length && t[0] <= n && t[1] * t[2] * t[3] <= n ? [t[0], t[1] * t[2] * t[3]] : sizeToSquarishShape(r);\n}var webgl_util = Object.freeze({ createWebGLRenderingContext: createWebGLRenderingContext, createWebGLRenderingContextFromCanvas: createWebGLRenderingContextFromCanvas, callAndCheck: callAndCheck, enableDebugWebGLErrorChecking: enableDebugWebGLErrorChecking, checkWebGLError: checkWebGLError, getWebGLErrorMessage: getWebGLErrorMessage, getExtensionOrThrow: getExtensionOrThrow, createVertexShader: createVertexShader, createFragmentShader: createFragmentShader, createProgram: createProgram, linkProgram: linkProgram, validateProgram: validateProgram, createStaticVertexBuffer: createStaticVertexBuffer, createStaticIndexBuffer: createStaticIndexBuffer, queryMaxTextureSize: queryMaxTextureSize, getNumChannels: getNumChannels, createTexture: createTexture, validateTextureSize: validateTextureSize, createFramebuffer: createFramebuffer, bindVertexBufferToProgramAttribute: bindVertexBufferToProgramAttribute, bindTextureUnit: bindTextureUnit, unbindTextureUnit: unbindTextureUnit, getProgramUniformLocationOrThrow: getProgramUniformLocationOrThrow, getProgramUniformLocation: getProgramUniformLocation, bindTextureToProgramUniformSampler: bindTextureToProgramUniformSampler, bindCanvasToFramebuffer: bindCanvasToFramebuffer, bindColorTextureToFramebuffer: bindColorTextureToFramebuffer, unbindColorTextureFromFramebuffer: unbindColorTextureFromFramebuffer, validateFramebuffer: validateFramebuffer, getFramebufferErrorMessage: getFramebufferErrorMessage, getTextureShapeFromLogicalShape: getTextureShapeFromLogicalShape });function getWebGLContextAttributes() {\n  return { alpha: !1, antialias: !1, premultipliedAlpha: !1, preserveDrawingBuffer: !1, depth: !1, stencil: !1, failIfMajorPerformanceCaveat: !0 };\n}function createWebGLContext(e) {\n  var t,\n      n = getWebGLContextAttributes();return callAndCheck(t = null != e ? createWebGLRenderingContextFromCanvas(e, n) : createWebGLRenderingContext(n), function () {\n    return t.disable(t.DEPTH_TEST);\n  }), callAndCheck(t, function () {\n    return t.disable(t.STENCIL_TEST);\n  }), callAndCheck(t, function () {\n    return t.disable(t.BLEND);\n  }), callAndCheck(t, function () {\n    return t.disable(t.DITHER);\n  }), callAndCheck(t, function () {\n    return t.disable(t.POLYGON_OFFSET_FILL);\n  }), callAndCheck(t, function () {\n    return t.disable(t.SAMPLE_COVERAGE);\n  }), callAndCheck(t, function () {\n    return t.enable(t.SCISSOR_TEST);\n  }), callAndCheck(t, function () {\n    return t.enable(t.CULL_FACE);\n  }), callAndCheck(t, function () {\n    return t.cullFace(t.BACK);\n  }), t;\n}function createVertexShader$1(e) {\n  return createVertexShader(e, \"\\n    precision highp float;\\n    attribute vec3 clipSpacePos;\\n    attribute vec2 uv;\\n    varying vec2 resultUV;\\n\\n    void main() {\\n      gl_Position = vec4(clipSpacePos, 1);\\n      resultUV = uv;\\n    }\");\n}function createVertexBuffer(e) {\n  return createStaticVertexBuffer(e, new Float32Array([-1, 1, 0, 0, 1, -1, -1, 0, 0, 0, 1, 1, 0, 1, 1, 1, -1, 0, 1, 0]));\n}function createIndexBuffer(e) {\n  return createStaticIndexBuffer(e, new Uint16Array([0, 1, 2, 2, 1, 3]));\n}function getTextureConfig(e, t) {\n  var n,\n      r,\n      o,\n      a,\n      i,\n      s,\n      u,\n      l = e;return 2 === ENV.get(\"WEBGL_VERSION\") ? (n = l.R32F, r = l.R16F, o = l.RGBA32F, a = l.RED, i = 4, s = 1, u = l.HALF_FLOAT) : (n = e.RGBA, r = e.RGBA, o = l.RGBA, a = e.RGBA, i = 4, s = 4, u = null != t ? t.HALF_FLOAT_OES : null), { internalFormatFloat: n, internalFormatHalfFloat: r, internalFormatPackedFloat: o, textureFormatFloat: a, downloadTextureFormat: e.RGBA, downloadUnpackNumChannels: i, defaultNumChannels: s, textureTypeHalfFloat: u };\n}function createAndConfigureTexture(e, t, n, r, o, a) {\n  validateTextureSize(e, t, n);var i = createTexture(e),\n      s = e.TEXTURE_2D;return callAndCheck(e, function () {\n    return e.bindTexture(s, i);\n  }), callAndCheck(e, function () {\n    return e.texParameteri(s, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE);\n  }), callAndCheck(e, function () {\n    return e.texParameteri(s, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE);\n  }), callAndCheck(e, function () {\n    return e.texParameteri(s, e.TEXTURE_MIN_FILTER, e.NEAREST);\n  }), callAndCheck(e, function () {\n    return e.texParameteri(s, e.TEXTURE_MAG_FILTER, e.NEAREST);\n  }), callAndCheck(e, function () {\n    return e.texImage2D(s, 0, r, t, n, 0, o, a, null);\n  }), callAndCheck(e, function () {\n    return e.bindTexture(e.TEXTURE_2D, null);\n  }), i;\n}function createFloat32MatrixTexture(e, t, n, r) {\n  var o = getUnpackedMatrixTextureShapeWidthHeight(t, n);return createAndConfigureTexture(e, o[0], o[1], r.internalFormatFloat, r.textureFormatFloat, e.FLOAT);\n}function createFloat16MatrixTexture(e, t, n, r) {\n  var o = getUnpackedMatrixTextureShapeWidthHeight(t, n);return createAndConfigureTexture(e, o[0], o[1], r.internalFormatFloat, r.textureFormatFloat, r.textureTypeHalfFloat);\n}function createUnsignedBytesMatrixTexture(e, t, n, r) {\n  var o = getUnpackedMatrixTextureShapeWidthHeight(t, n);return createAndConfigureTexture(e, o[0], o[1], e.RGBA, e.RGBA, e.UNSIGNED_BYTE);\n}function createPackedMatrixTexture(e, t, n, r) {\n  var o = getPackedMatrixTextureShapeWidthHeight(t, n);return createAndConfigureTexture(e, o[0], o[1], r.internalFormatPackedFloat, e.RGBA, e.FLOAT);\n}function bindVertexProgramAttributeStreams(e, t, n) {\n  return callAndCheck(e, function () {\n    return e.bindBuffer(e.ARRAY_BUFFER, n);\n  }), bindVertexBufferToProgramAttribute(e, t, \"clipSpacePos\", n, 3, 20, 0) && bindVertexBufferToProgramAttribute(e, t, \"uv\", n, 2, 20, 12);\n}function uploadPixelDataToTexture(e, t, n) {\n  callAndCheck(e, function () {\n    return e.bindTexture(e.TEXTURE_2D, t);\n  }), callAndCheck(e, function () {\n    return e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, e.RGBA, e.UNSIGNED_BYTE, n);\n  }), callAndCheck(e, function () {\n    return e.bindTexture(e.TEXTURE_2D, null);\n  });\n}function uploadDataToTexture(e, t, n, r, o, a) {\n  validateTextureSize(e, n, r), callAndCheck(e, function () {\n    return e.bindTexture(e.TEXTURE_2D, t);\n  }), callAndCheck(e, function () {\n    return e.texSubImage2D(e.TEXTURE_2D, 0, 0, 0, n, r, a, e.FLOAT, o);\n  }), callAndCheck(e, function () {\n    return e.bindTexture(e.TEXTURE_2D, null);\n  });\n}function uploadMatrixToTexture(e, t, n, r, o, a, i) {\n  var s,\n      u = getUnpackedMatrixTextureShapeWidthHeight(n, r),\n      l = u[0],\n      c = u[1];1 === i.defaultNumChannels ? s = o : encodeMatrixToUnpackedArray(o, s = new Float32Array(getUnpackedArraySizeFromMatrixSize(o.length, a)), a), uploadDataToTexture(e, t, l, c, s, i.textureFormatFloat);\n}function uploadMatrixToPackedTexture(e, t, n, r, o, a) {\n  var i = getPackedMatrixTextureShapeWidthHeight(n, r),\n      s = i[0],\n      u = i[1],\n      l = new Float32Array(getPackedRGBAArraySizeFromMatrixShape(n, r));encodeMatrixToPackedRGBA(o, n, r, l), uploadDataToTexture(e, t, s, u, l, e.RGBA);\n}function maybeCreateBufferFromOutputTexture(e, t, n, r, o) {\n  var a = t;if (2 === ENV.get(\"WEBGL_VERSION\")) {\n    var i = e,\n        s = i.createBuffer();callAndCheck(e, function () {\n      return e.bindBuffer(i.PIXEL_PACK_BUFFER, s);\n    });var u = 4 * getUnpackedArraySizeFromMatrixSize(n * r, o.downloadUnpackNumChannels);callAndCheck(e, function () {\n      return e.bufferData(i.PIXEL_PACK_BUFFER, u, e.STATIC_DRAW);\n    }), callAndCheck(e, function () {\n      return i.readPixels(0, 0, r, n, e.RGBA, e.FLOAT, 0);\n    }), callAndCheck(e, function () {\n      return e.bindBuffer(i.PIXEL_PACK_BUFFER, null);\n    }), a = s;\n  }return a;\n}function downloadFloat32MatrixFromBuffer(e, t, n, r, o) {\n  var a = e,\n      i = new Float32Array(getUnpackedArraySizeFromMatrixSize(n * r, o.downloadUnpackNumChannels));a.bindBuffer(e.ARRAY_BUFFER, t), a.getBufferSubData(e.ARRAY_BUFFER, 0, i), a.bindBuffer(e.ARRAY_BUFFER, null);var s = new Float32Array(n * r);return decodeMatrixFromUnpackedArray(i, s, o.downloadUnpackNumChannels), s;\n}function downloadFloat32MatrixFromOutputTexture(e, t, n, r) {\n  var o = getUnpackedMatrixTextureShapeWidthHeight(t, n),\n      a = o[0],\n      i = o[1],\n      s = new Float32Array(getUnpackedArraySizeFromMatrixSize(t * n, r.downloadUnpackNumChannels));callAndCheck(e, function () {\n    return e.readPixels(0, 0, a, i, r.downloadTextureFormat, e.FLOAT, s);\n  });var u = new Float32Array(t * n);return decodeMatrixFromUnpackedArray(s, u, r.downloadUnpackNumChannels), u;\n}function downloadByteEncodedFloatMatrixFromOutputTexture(e, t, n, r) {\n  var o = getUnpackedMatrixTextureShapeWidthHeight(t, n),\n      a = o[0],\n      i = o[1],\n      s = new Uint8Array(getUnpackedArraySizeFromMatrixSize(t * n, 4));return callAndCheck(e, function () {\n    return e.readPixels(0, 0, a, i, r.downloadTextureFormat, e.UNSIGNED_BYTE, s);\n  }), new Float32Array(s.buffer);\n}function downloadMatrixFromPackedOutputTexture(e, t, n, r) {\n  var o = getPackedMatrixTextureShapeWidthHeight(t, n),\n      a = o[0],\n      i = o[1],\n      s = new Float32Array(getPackedRGBAArraySizeFromMatrixShape(t, n));callAndCheck(e, function () {\n    return e.readPixels(0, 0, a, i, e.RGBA, e.FLOAT, s);\n  });var u = new Float32Array(t * n);return decodeMatrixFromPackedRGBA(s, t, n, u);\n}var gpgpu_util = Object.freeze({ getWebGLContextAttributes: getWebGLContextAttributes, createWebGLContext: createWebGLContext, createVertexShader: createVertexShader$1, createVertexBuffer: createVertexBuffer, createIndexBuffer: createIndexBuffer, getTextureConfig: getTextureConfig, createFloat32MatrixTexture: createFloat32MatrixTexture, createFloat16MatrixTexture: createFloat16MatrixTexture, createUnsignedBytesMatrixTexture: createUnsignedBytesMatrixTexture, createPackedMatrixTexture: createPackedMatrixTexture, bindVertexProgramAttributeStreams: bindVertexProgramAttributeStreams, uploadPixelDataToTexture: uploadPixelDataToTexture, uploadMatrixToTexture: uploadMatrixToTexture, uploadMatrixToPackedTexture: uploadMatrixToPackedTexture, maybeCreateBufferFromOutputTexture: maybeCreateBufferFromOutputTexture, downloadFloat32MatrixFromBuffer: downloadFloat32MatrixFromBuffer, downloadFloat32MatrixFromOutputTexture: downloadFloat32MatrixFromOutputTexture, downloadByteEncodedFloatMatrixFromOutputTexture: downloadByteEncodedFloatMatrixFromOutputTexture, downloadMatrixFromPackedOutputTexture: downloadMatrixFromPackedOutputTexture }),\n    GPGPUContext = function () {\n  function e(e) {\n    this.outputTexture = null, this.program = null, this.disposed = !1, this.autoDebugValidate = !1, this.vertexAttrsAreBound = !1, this.itemsToPoll = [], this.gl = null != e ? e : createWebGLContext(), 1 === ENV.get(\"WEBGL_VERSION\") ? (this.textureFloatExtension = getExtensionOrThrow(this.gl, \"OES_texture_float\"), this.colorBufferFloatExtension = this.gl.getExtension(\"WEBGL_color_buffer_float\"), ENV.get(\"WEBGL_RENDER_FLOAT32_ENABLED\") || (this.textureHalfFloatExtension = getExtensionOrThrow(this.gl, \"OES_texture_half_float\"), this.colorBufferHalfFloatExtension = this.gl.getExtension(\"EXT_color_buffer_half_float\"))) : this.colorBufferFloatExtension = getExtensionOrThrow(this.gl, \"EXT_color_buffer_float\"), this.loseContextExtension = getExtensionOrThrow(this.gl, \"WEBGL_lose_context\"), this.vertexBuffer = createVertexBuffer(this.gl), this.indexBuffer = createIndexBuffer(this.gl), this.framebuffer = createFramebuffer(this.gl), this.textureConfig = getTextureConfig(this.gl, this.textureHalfFloatExtension);\n  }return e.prototype.dispose = function () {\n    var e = this;if (!this.disposed) {\n      null != this.program && console.warn(\"Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing.\"), null != this.outputTexture && console.warn(\"Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.\");var t = this.gl;callAndCheck(t, function () {\n        return t.finish();\n      }), callAndCheck(t, function () {\n        return t.bindFramebuffer(t.FRAMEBUFFER, null);\n      }), callAndCheck(t, function () {\n        return t.deleteFramebuffer(e.framebuffer);\n      }), callAndCheck(t, function () {\n        return t.bindBuffer(t.ARRAY_BUFFER, null);\n      }), callAndCheck(t, function () {\n        return t.deleteBuffer(e.vertexBuffer);\n      }), callAndCheck(t, function () {\n        return t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, null);\n      }), callAndCheck(t, function () {\n        return t.deleteBuffer(e.indexBuffer);\n      }), this.loseContextExtension.loseContext(), this.disposed = !0;\n    }\n  }, e.prototype.enableAutomaticDebugValidation = function (e) {\n    this.autoDebugValidate = e, enableDebugWebGLErrorChecking(e);\n  }, e.prototype.createFloat32MatrixTexture = function (e, t) {\n    return this.throwIfDisposed(), createFloat32MatrixTexture(this.gl, e, t, this.textureConfig);\n  }, e.prototype.createFloat16MatrixTexture = function (e, t) {\n    return this.throwIfDisposed(), createFloat16MatrixTexture(this.gl, e, t, this.textureConfig);\n  }, e.prototype.createUnsignedBytesMatrixTexture = function (e, t) {\n    return this.throwIfDisposed(), createUnsignedBytesMatrixTexture(this.gl, e, t, this.textureConfig);\n  }, e.prototype.uploadPixelDataToTexture = function (e, t) {\n    this.throwIfDisposed(), uploadPixelDataToTexture(this.gl, e, t);\n  }, e.prototype.createPackedMatrixTexture = function (e, t) {\n    return this.throwIfDisposed(), createPackedMatrixTexture(this.gl, e, t, this.textureConfig);\n  }, e.prototype.deleteMatrixTexture = function (e) {\n    var t = this;this.throwIfDisposed(), this.outputTexture === e && (unbindColorTextureFromFramebuffer(this.gl, this.framebuffer), this.outputTexture = null), callAndCheck(this.gl, function () {\n      return t.gl.deleteTexture(e);\n    });\n  }, e.prototype.uploadMatrixToTexture = function (e, t, n, r) {\n    this.throwIfDisposed();var o = getNumChannels();return uploadMatrixToTexture(this.gl, e, t, n, r, o, this.textureConfig);\n  }, e.prototype.uploadMatrixToPackedTexture = function (e, t, n, r) {\n    return this.throwIfDisposed(), uploadMatrixToPackedTexture(this.gl, e, t, n, r, this.textureConfig);\n  }, e.prototype.downloadFloat32MatrixFromOutputTexture = function (e, t, n) {\n    var r = this;return this.downloadMatrixDriver(e, function () {\n      return downloadFloat32MatrixFromOutputTexture(r.gl, t, n, r.textureConfig);\n    });\n  }, e.prototype.downloadByteEncodedFloatMatrixFromOutputTexture = function (e, t, n) {\n    var r = this;return this.downloadMatrixDriver(e, function () {\n      return downloadByteEncodedFloatMatrixFromOutputTexture(r.gl, t, n, r.textureConfig);\n    });\n  }, e.prototype.downloadFloat32MatrixFromBuffer = function (e, t, n) {\n    return downloadFloat32MatrixFromBuffer(this.gl, e, t, n, this.textureConfig);\n  }, e.prototype.maybeCreateBufferFromTexture = function (e, t, n) {\n    this.bindTextureToFrameBuffer(e);var r = maybeCreateBufferFromOutputTexture(this.gl, e, t, n, this.textureConfig);return this.unbindTextureToFrameBuffer(), r;\n  }, e.prototype.createAndWaitForFence = function () {\n    var e = this.createFence(this.gl);return this.pollFence(e);\n  }, e.prototype.createFence = function (e) {\n    var t,\n        n,\n        r = this;if (ENV.get(\"WEBGL_FENCE_API_ENABLED\")) {\n      var o = e,\n          a = o.fenceSync(o.SYNC_GPU_COMMANDS_COMPLETE, 0);e.flush(), n = function () {\n        var e = o.clientWaitSync(a, 0, 0);return e === o.ALREADY_SIGNALED || e === o.CONDITION_SATISFIED;\n      }, t = a;\n    } else ENV.get(\"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION\") > 0 ? (t = this.beginQuery(), this.endQuery(), n = function () {\n      return r.isQueryAvailable(t, ENV.get(\"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION\"));\n    }) : n = function () {\n      return !0;\n    };return { query: t, isFencePassed: n };\n  }, e.prototype.downloadMatrixFromPackedTexture = function (e, t, n) {\n    var r = this;return this.downloadMatrixDriver(e, function () {\n      return downloadMatrixFromPackedOutputTexture(r.gl, t, n, r.textureConfig);\n    });\n  }, e.prototype.createProgram = function (e) {\n    this.throwIfDisposed();var t = this.gl,\n        n = createFragmentShader(t, e),\n        r = createVertexShader$1(t),\n        o = createProgram(t);return callAndCheck(t, function () {\n      return t.attachShader(o, r);\n    }), callAndCheck(t, function () {\n      return t.attachShader(o, n);\n    }), linkProgram(t, o), this.autoDebugValidate && validateProgram(t, o), this.vertexAttrsAreBound || (this.setProgram(o), this.vertexAttrsAreBound = bindVertexProgramAttributeStreams(t, this.program, this.vertexBuffer)), o;\n  }, e.prototype.deleteProgram = function (e) {\n    var t = this;this.throwIfDisposed(), e === this.program && (this.program = null), null != e && callAndCheck(this.gl, function () {\n      return t.gl.deleteProgram(e);\n    });\n  }, e.prototype.setProgram = function (e) {\n    var t = this;this.throwIfDisposed(), this.program = e, null != this.program && this.autoDebugValidate && validateProgram(this.gl, this.program), callAndCheck(this.gl, function () {\n      return t.gl.useProgram(e);\n    });\n  }, e.prototype.getUniformLocation = function (e, t, n) {\n    return void 0 === n && (n = !0), this.throwIfDisposed(), n ? getProgramUniformLocationOrThrow(this.gl, e, t) : getProgramUniformLocation(this.gl, e, t);\n  }, e.prototype.getAttributeLocation = function (e, t) {\n    var n = this;return this.throwIfDisposed(), callAndCheck(this.gl, function () {\n      return n.gl.getAttribLocation(e, t);\n    });\n  }, e.prototype.getUniformLocationNoThrow = function (e, t) {\n    return this.throwIfDisposed(), this.gl.getUniformLocation(e, t);\n  }, e.prototype.setInputMatrixTexture = function (e, t, n) {\n    this.throwIfDisposed(), this.throwIfNoProgram(), bindTextureToProgramUniformSampler(this.gl, this.program, e, t, n);\n  }, e.prototype.setOutputMatrixTexture = function (e, t, n) {\n    this.setOutputMatrixTextureDriver(e, n, t);\n  }, e.prototype.setOutputPackedMatrixTexture = function (e, t, n) {\n    this.throwIfDisposed();var r = getPackedMatrixTextureShapeWidthHeight(t, n),\n        o = r[0],\n        a = r[1];this.setOutputMatrixTextureDriver(e, o, a);\n  }, e.prototype.setOutputMatrixWriteRegion = function (e, t, n, r) {\n    this.setOutputMatrixWriteRegionDriver(n, e, r, t);\n  }, e.prototype.setOutputPackedMatrixWriteRegion = function (e, t, n, r) {\n    throw new Error(\"setOutputPackedMatrixWriteRegion not implemented.\");\n  }, e.prototype.debugValidate = function () {\n    null != this.program && validateProgram(this.gl, this.program), validateFramebuffer(this.gl);\n  }, e.prototype.executeProgram = function () {\n    this.throwIfDisposed(), this.throwIfNoProgram();var e = this.gl;this.autoDebugValidate && this.debugValidate(), callAndCheck(e, function () {\n      return e.drawElements(e.TRIANGLES, 6, e.UNSIGNED_SHORT, 0);\n    });\n  }, e.prototype.blockUntilAllProgramsCompleted = function () {\n    var e = this;this.throwIfDisposed(), callAndCheck(this.gl, function () {\n      return e.gl.finish();\n    });\n  }, e.prototype.getQueryTimerExtension = function () {\n    return null == this.disjointQueryTimerExtension && (this.disjointQueryTimerExtension = getExtensionOrThrow(this.gl, 2 === ENV.get(\"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION\") ? \"EXT_disjoint_timer_query_webgl2\" : \"EXT_disjoint_timer_query\")), this.disjointQueryTimerExtension;\n  }, e.prototype.getQueryTimerExtensionWebGL2 = function () {\n    return this.getQueryTimerExtension();\n  }, e.prototype.getQueryTimerExtensionWebGL1 = function () {\n    return this.getQueryTimerExtension();\n  }, e.prototype.beginQuery = function () {\n    if (2 === ENV.get(\"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION\")) {\n      var e = this.gl,\n          t = this.getQueryTimerExtensionWebGL2(),\n          n = e.createQuery();return e.beginQuery(t.TIME_ELAPSED_EXT, n), n;\n    }var r = this.getQueryTimerExtensionWebGL1(),\n        o = r.createQueryEXT();return r.beginQueryEXT(r.TIME_ELAPSED_EXT, o), o;\n  }, e.prototype.endQuery = function () {\n    if (2 !== ENV.get(\"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION\")) {\n      var e = this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT);\n    } else {\n      var t = this.gl,\n          n = this.getQueryTimerExtensionWebGL2();t.endQuery(n.TIME_ELAPSED_EXT);\n    }\n  }, e.prototype.waitForQueryAndGetTime = function (e) {\n    return __awaiter(this, void 0, void 0, function () {\n      var t = this;return __generator(this, function (n) {\n        switch (n.label) {case 0:\n            return [4, repeatedTry(function () {\n              return t.isQueryAvailable(e, ENV.get(\"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION\"));\n            })];case 1:\n            return n.sent(), [2, this.getQueryTime(e, ENV.get(\"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION\"))];}\n      });\n    });\n  }, e.prototype.getQueryTime = function (e, t) {\n    if (0 === t) return null;if (2 === t) {\n      var n = this.gl;return n.getQueryParameter(e, n.QUERY_RESULT) / 1e6;\n    }var r = this.getQueryTimerExtensionWebGL1();return r.getQueryObjectEXT(e, r.QUERY_RESULT_EXT) / 1e6;\n  }, e.prototype.isQueryAvailable = function (e, t) {\n    if (0 === t) return !0;if (2 === t) {\n      var n = this.gl,\n          r = this.getQueryTimerExtensionWebGL2(),\n          o = n.getQueryParameter(e, n.QUERY_RESULT_AVAILABLE);return null == this.disjoint && (this.disjoint = this.gl.getParameter(r.GPU_DISJOINT_EXT)), o && !this.disjoint;\n    }o = (r = this.getQueryTimerExtensionWebGL1()).getQueryObjectEXT(e, r.QUERY_RESULT_AVAILABLE_EXT);return null == this.disjoint && (this.disjoint = this.gl.getParameter(r.GPU_DISJOINT_EXT)), o && !this.disjoint;\n  }, e.prototype.pollFence = function (e) {\n    var t = this;return new Promise(function (n) {\n      t.addItemToPoll(function () {\n        return e.isFencePassed();\n      }, function () {\n        return n();\n      });\n    });\n  }, e.prototype.pollItems = function () {\n    for (var e = binSearchLastTrue(this.itemsToPoll.map(function (e) {\n      return e.isDoneFn;\n    })), t = 0; t <= e; ++t) {\n      (0, this.itemsToPoll[t].resolveFn)();\n    }this.itemsToPoll = this.itemsToPoll.slice(e + 1);\n  }, e.prototype.addItemToPoll = function (e, t) {\n    var n = this;this.itemsToPoll.push({ isDoneFn: e, resolveFn: t }), this.itemsToPoll.length > 1 || repeatedTry(function () {\n      return n.pollItems(), 0 === n.itemsToPoll.length;\n    });\n  }, e.prototype.bindTextureToFrameBuffer = function (e) {\n    this.throwIfDisposed(), bindColorTextureToFramebuffer(this.gl, e, this.framebuffer), this.autoDebugValidate && validateFramebuffer(this.gl);\n  }, e.prototype.unbindTextureToFrameBuffer = function () {\n    null != this.outputTexture ? (bindColorTextureToFramebuffer(this.gl, this.outputTexture, this.framebuffer), this.autoDebugValidate && validateFramebuffer(this.gl)) : unbindColorTextureFromFramebuffer(this.gl, this.framebuffer);\n  }, e.prototype.downloadMatrixDriver = function (e, t) {\n    this.bindTextureToFrameBuffer(e);var n = t();return this.unbindTextureToFrameBuffer(), n;\n  }, e.prototype.setOutputMatrixTextureDriver = function (e, t, n) {\n    this.throwIfDisposed();var r = this.gl;bindColorTextureToFramebuffer(r, e, this.framebuffer), this.autoDebugValidate && validateFramebuffer(r), this.outputTexture = e, callAndCheck(r, function () {\n      return r.viewport(0, 0, t, n);\n    }), callAndCheck(r, function () {\n      return r.scissor(0, 0, t, n);\n    });\n  }, e.prototype.setOutputMatrixWriteRegionDriver = function (e, t, n, r) {\n    var o = this;this.throwIfDisposed(), callAndCheck(this.gl, function () {\n      return o.gl.scissor(e, t, n, r);\n    });\n  }, e.prototype.throwIfDisposed = function () {\n    if (this.disposed) throw new Error(\"Attempted to use disposed GPGPUContext.\");\n  }, e.prototype.throwIfNoProgram = function () {\n    if (null == this.program) throw new Error(\"No GPU program is currently set.\");\n  }, e;\n}();function binSearchLastTrue(e) {\n  for (var t = 0, n = e.length - 1, r = -1; t <= n;) {\n    var o = t + n >> 1;e[o]() ? (r = o, t = o + 1) : n = o - 1;\n  }return r;\n}function compileProgram(e, t, n, r) {\n  for (var o = t.userCode, a = n.map(function (e, n) {\n    var r = { logicalShape: e.shape, texShape: e.isUniform ? null : e.texData.texShape, isUniform: e.isUniform, isPacked: !e.isUniform && e.texData.usage === TextureUsage.PACK };return { name: t.variableNames[n], shapeInfo: r };\n  }), i = a.map(function (e) {\n    return e.shapeInfo;\n  }), s = { logicalShape: r.shape, texShape: r.texData.texShape, isUniform: !1, isPacked: r.texData.usage === TextureUsage.PACK }, u = makeShader(a, s, o, !0 === t.supportsBroadcasting), l = e.createProgram(u), c = {}, p = 0; p < t.variableNames.length; p++) {\n    var d = t.variableNames[p];c[d] = e.getUniformLocation(l, d, !1);\n  }return { program: t, source: u, webGLProgram: l, uniformLocations: c, gpgpu: e, inShapeInfos: i, outShapeInfo: s };\n}function validateBinaryAndProgram(e, t) {\n  if (e.length !== t.length) throw Error(\"Binary was compiled with \" + e.length + \" inputs, but was executed with \" + t.length + \" inputs\");e.forEach(function (e, n) {\n    var r = e.logicalShape,\n        o = t[n],\n        a = o.shape;if (!arraysEqual(r, a)) throw Error(\"Binary was compiled with different shapes than the current args. Shapes \" + r + \" and \" + a + \" must match\");if (!e.isUniform || !o.isUniform) {\n      var i = e.texShape,\n          s = o.isUniform ? null : o.texData.texShape;if (!arraysEqual(i, s)) throw Error(\"Binary was compiled with different texture shapes than the current args. Shape \" + i + \" and \" + s + \" must match\");\n    }\n  });\n}function runProgram(e, t, n, r) {\n  validateBinaryAndProgram(e.inShapeInfos, t), validateBinaryAndProgram([e.outShapeInfo], [n]);var o = n.texData.texture,\n      a = n.texData.texShape,\n      i = e.gpgpu;n.texData.usage === TextureUsage.PACK ? i.setOutputPackedMatrixTexture(o, a[0], a[1]) : i.setOutputMatrixTexture(o, a[0], a[1]), i.setProgram(e.webGLProgram), t.forEach(function (t, n) {\n    var r = e.program.variableNames[n],\n        o = e.uniformLocations[r];if (null != o) {\n      if (t.isUniform) {\n        if (1 === sizeFromShape(t.shape)) i.gl.uniform1f(o, t.uniformValues[0]);else {\n          var a = t.uniformValues;a instanceof Float32Array || (a = new Float32Array(a)), i.gl.uniform1fv(o, a);\n        }return;\n      }var s = t.texData.texture;i.setInputMatrixTexture(s, o, n);\n    }\n  }), null != r && r(i, e.webGLProgram), i.executeProgram();\n}function makeShaderKey(e, t, n) {\n  var r = \"\";t.concat(n).forEach(function (e) {\n    r += e.shape + \"_\" + (e.isUniform ? \"uniform\" : e.texData.texShape);\n  });var o = e.userCode,\n      a = (!0 === e.supportsBroadcasting).toString(),\n      i = e.constructor.name;return i += \"_\" + a + \"_\" + r + \"_\" + o;\n}var LRNProgram = function () {\n  return function (e, t, n, r, o) {\n    this.variableNames = [\"x\"], this.outputShape = [];var a,\n        i = t,\n        s = e[3] - 1;this.outputShape = e;var u = \"float(\" + n + \") + float(\" + r + \") * sum\";a = .5 === o ? \"inversesqrt(\" + u + \")\" : 1 === o ? \"1.0/(\" + u + \")\" : \"exp(log(\" + u + \") * float(-\" + o + \"));\", this.userCode = \"\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int b = coords[0];\\n        int r = coords[1];\\n        int c = coords[2];\\n        int d = coords[3];\\n        float x = getX(b, r, c, d);\\n        float sum = 0.0;\\n        for (int j = -\" + i + \"; j <= \" + i + \"; j++) {\\n          int idx = d + j;\\n          if (idx >= 0 && idx <=  \" + s + \") {\\n            float z = getX(b, r, c, idx);\\n            sum += z * z;\\n          }\\n        }\\n        float val = x * \" + a + \";\\n        setOutput(val);\\n      }\\n    \";\n  };\n}(),\n    LRNGradProgram = function () {\n  return function (e, t, n, r, o) {\n    this.variableNames = [\"inputImage\", \"outputImage\", \"dy\"], this.outputShape = [], this.outputShape = e, this.depth = e[3], this.depthRadius = t, this.bias = n, this.alpha = r, this.beta = o, this.userCode = \"\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int b = coords[0];\\n        int r = coords[1];\\n        int c = coords[2];\\n\\n        float result = 0.0;\\n        for (int d = 0; d < \" + this.depth + \"; ++d) {\\n          int depthBegin = int(max(0.0, float(d - \" + t + \")));\\n          int depthEnd = int(min(float(\" + this.depth + \"),\\n              float(d + \" + t + \" + 1)));\\n\\n          const int MIN_DEPTH_BEGIN = 0;\\n          const int MAX_DEPTH_END = \" + this.depth + \";\\n\\n          float norm = 0.0;\\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\\n            if (k < depthBegin){\\n              continue;\\n            }\\n            else if (k >= depthBegin && k < depthEnd) {\\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\\n            }\\n            else {\\n              break;\\n            }\\n          }\\n\\n          norm = float(\" + r + \") * norm + float(\" + n + \");\\n\\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\\n            if (k < depthBegin){\\n              continue;\\n            }\\n            else if (k >= depthBegin && k < depthEnd){\\n              float dyi = -2.0 * float(\" + r + \")\\n                * float(\" + o + \")\\n                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)\\n                / norm;\\n              if (k == d) {\\n                dyi += pow(norm, -1.0 * \" + o + \");\\n              }\\n              if (k == coords[3]) {\\n                dyi *= getDy(b, r, c, d);\\n                result += dyi;\\n              }\\n            }\\n            else {\\n              break;\\n            }\\n          }\\n      }\\n      setOutput(result);\\n      }\\n    \";\n  };\n}(),\n    MaxPool2DBackpropProgram = function () {\n  return function (e) {\n    this.variableNames = [\"dy\", \"maxPos\"], this.outputShape = e.inShape;var t = e.filterHeight,\n        n = e.filterWidth,\n        r = e.strideHeight,\n        o = e.strideWidth,\n        a = t - 1 - e.padInfo.top,\n        i = n - 1 - e.padInfo.left,\n        s = t * n - 1;this.userCode = \"\\n      const ivec2 pads = ivec2(\" + a + \", \" + i + \");\\n\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int b = coords[0];\\n        int d = coords[3];\\n\\n        ivec2 dyRCCorner = coords.yz - pads;\\n        int dyRCorner = dyRCCorner.x;\\n        int dyCCorner = dyRCCorner.y;\\n\\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\\n        // ? = to be determined. : = across all values in that axis.\\n        float dotProd = 0.0;\\n        for (int wR = 0; wR < \" + t + \"; wR++) {\\n          float dyR = float(dyRCorner + wR) / \" + r + \".0;\\n\\n          if (dyR < 0.0 || dyR >= \" + e.outHeight + \".0 || fract(dyR) > 0.0) {\\n            continue;\\n          }\\n          int idyR = int(dyR);\\n\\n          for (int wC = 0; wC < \" + n + \"; wC++) {\\n            float dyC = float(dyCCorner + wC) / \" + o + \".0;\\n\\n            if (dyC < 0.0 || dyC >= \" + e.outWidth + \".0 ||\\n                fract(dyC) > 0.0) {\\n              continue;\\n            }\\n            int idyC = int(dyC);\\n\\n            float dyValue = getDy(b, idyR, idyC, d);\\n            int maxPosValue = \" + s + \" - int(getMaxPos(b, idyR, idyC, d));\\n\\n            // Get the current value, check it against the value from the\\n            // position matrix.\\n            int curPosValue = wR * \" + n + \" + wC;\\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\\n\\n            dotProd += dyValue * mask;\\n          }\\n        }\\n        setOutput(dotProd);\\n      }\\n    \";\n  };\n}(),\n    MatMulProgram = function () {\n  return function (e, t, n, r) {\n    void 0 === n && (n = !1), void 0 === r && (r = !1), this.variableNames = [\"matrixA\", \"matrixB\"];var o = e[0],\n        a = n ? e[2] : e[1],\n        i = r ? t[1] : t[2],\n        s = n ? e[1] : e[2];this.outputShape = [o, a, i];var u = function (e, t) {\n      return n ? \"batch, \" + t + \" + \" + e + \", aRow\" : \"batch, aRow, \" + t + \" + \" + e;\n    },\n        l = function (e, t) {\n      return r ? \"batch, bCol, \" + t + \" + \" + e : \"batch, \" + t + \" + \" + e + \", bCol\";\n    },\n        c = 4 * Math.floor(s / 4),\n        p = s % 4;this.userCode = \" float dotARowBCol(int batch, int aRow, int bCol) {\\n      float result = 0.0;\\n      for (int i = 0; i < \" + c + \"; i += 4) {\\n        vec4 a = vec4(\\n          getMatrixA(\" + u(0, \"i\") + \"),\\n          getMatrixA(\" + u(1, \"i\") + \"),\\n          getMatrixA(\" + u(2, \"i\") + \"),\\n          getMatrixA(\" + u(3, \"i\") + \")\\n        );\\n        vec4 b = vec4(\\n          getMatrixB(\" + l(0, \"i\") + \"),\\n          getMatrixB(\" + l(1, \"i\") + \"),\\n          getMatrixB(\" + l(2, \"i\") + \"),\\n          getMatrixB(\" + l(3, \"i\") + \")\\n        );\\n\\n        result += dot(a, b);\\n      }\\n\\n      if (\" + (1 === p) + \") {\\n        result += getMatrixA(\" + u(0, c) + \") *\\n          getMatrixB(\" + l(0, c) + \");\\n      } else if (\" + (2 === p) + \") {\\n        vec2 a = vec2(\\n          getMatrixA(\" + u(0, c) + \"),\\n          getMatrixA(\" + u(1, c) + \")\\n        );\\n        vec2 b = vec2(\\n          getMatrixB(\" + l(0, c) + \"),\\n          getMatrixB(\" + l(1, c) + \")\\n        );\\n        result += dot(a, b);\\n      } else if (\" + (3 === p) + \") {\\n        vec3 a = vec3(\\n          getMatrixA(\" + u(0, c) + \"),\\n          getMatrixA(\" + u(1, c) + \"),\\n          getMatrixA(\" + u(2, c) + \")\\n        );\\n        vec3 b = vec3(\\n          getMatrixB(\" + l(0, c) + \"),\\n          getMatrixB(\" + l(1, c) + \"),\\n          getMatrixB(\" + l(2, c) + \")\\n        );\\n        result += dot(a, b);\\n      }\\n\\n      return result;\\n    }\\n\\n    void main() {\\n      ivec3 resBRC = getOutputCoords();\\n      setOutput(dotARowBCol(resBRC.x, resBRC.y, resBRC.z));\\n    }\\n    \";\n  };\n}(),\n    MatMulPackedProgram = function () {\n  return function (e, t, n, r, o) {\n    void 0 === r && (r = !1), void 0 === o && (o = !1), this.variableNames = [\"matrixA\", \"matrixB\"], this.outputShape = n;var a = r ? e[0] : e[1],\n        i = Math.ceil(a / 2),\n        s = r ? \"resultUV.t, center\" : \"center, resultUV.t\",\n        u = o ? \"center, resultUV.s\" : \"resultUV.s, center\",\n        l = r ? [\"a.xxyy\", \"a.zzww\"] : [\"a.xxzz\", \"a.yyww\"],\n        c = o ? [\"b.xzxz\", \"b.ywyw\"] : [\"b.xyxy\", \"b.zwzw\"];this.userCode = \"\\n      const float sharedDimension = \" + i + \".0;\\n\\n      vec4 dot2x2ARowBCol() {\\n        vec4 result = vec4(0);\\n        for (int ii = 0; ii < \" + i + \"; ii++) {\\n          float i = float(ii);\\n          float center = (i + 0.5) / sharedDimension;\\n          vec4 a = texture2D(matrixA, vec2(\" + s + \"));\\n          vec4 b = texture2D(matrixB, vec2(\" + u + \"));\\n\\n          result += (\" + l[0] + \" * \" + c[0] + \") + (\" + l[1] + \" * \" + c[1] + \");\\n        }\\n        return result;\\n      }\\n\\n      void main() {\\n        gl_FragColor = dot2x2ARowBCol();\\n      }\\n    \";\n  };\n}(),\n    MultinomialProgram = function () {\n  function e(e, t, n) {\n    this.variableNames = [\"probs\"], this.outputShape = [e, n], this.userCode = \"\\n      uniform float seed;\\n\\n      void main() {\\n        ivec2 coords = getOutputCoords();\\n        int batch = coords[0];\\n\\n        float r = random(seed);\\n        float cdf = 0.0;\\n\\n        for (int i = 0; i < \" + (t - 1) + \"; i++) {\\n          cdf += getProbs(batch, i);\\n\\n          if (r < cdf) {\\n            setOutput(float(i));\\n            return;\\n          }\\n        }\\n\\n        // If no other event happened, last event happened.\\n        setOutput(float(\" + (t - 1) + \"));\\n      }\\n    \";\n  }return e.prototype.getCustomSetupFunc = function (e) {\n    var t = this;return function (n, r) {\n      null == t.seedLoc && (t.seedLoc = n.getUniformLocation(r, \"seed\")), n.gl.uniform1f(t.seedLoc, e);\n    };\n  }, e;\n}(),\n    OneHotProgram = function () {\n  return function (e, t, n, r) {\n    this.variableNames = [\"indices\"], this.outputShape = [e, t], this.userCode = \"\\n      void main() {\\n        ivec2 coords = getOutputCoords();\\n        int index = round(getIndices(coords.x));\\n        setOutput(mix(float(\" + r + \"), float(\" + n + \"),\\n                      float(index == coords.y)));\\n      }\\n    \";\n  };\n}(),\n    PackProgram = function () {\n  return function (e) {\n    this.variableNames = [\"A\"], this.outputShape = e, this.userCode = \"\\n      void main() {\\n        ivec2 rc = getOutputCoords();\\n\\n        int r = rc.x;\\n        int c = rc.y;\\n        int rp1 = r + 1;\\n        int cp1 = c + 1;\\n\\n        bool cEdge = cp1 >= \" + e[1] + \";\\n        bool rEdge = rp1 >= \" + e[0] + \";\\n\\n        gl_FragColor = vec4(\\n            getA(r, c),\\n            cEdge ? 0. : getA(r, cp1),\\n            rEdge ? 0. : getA(rp1, c),\\n            rEdge || cEdge ? 0. : getA(rp1, cp1)\\n          );\\n      }\\n    \";\n  };\n}(),\n    PadProgram = function () {\n  return function (e, t, n) {\n    this.variableNames = [\"x\"], this.outputShape = t.map(function (t, n) {\n      return t[0] + e[n] + t[1];\n    });var r = e.length,\n        o = getCoordsDataType(r),\n        a = t.map(function (e) {\n      return e[0];\n    }).join(\",\"),\n        i = t.map(function (t, n) {\n      return t[0] + e[n];\n    }).join(\",\"),\n        s = [\"coords[0]\", \"coords[1]\", \"coords[2]\", \"coords[3]\"].slice(0, r);this.userCode = 1 !== r ? \"\\n      \" + o + \" start = \" + o + \"(\" + a + \");\\n      \" + o + \" end = \" + o + \"(\" + i + \");\\n\\n      void main() {\\n        \" + o + \" outC = getOutputCoords();\\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\\n          setOutput(float(\" + n + \"));\\n        } else {\\n          \" + o + \" coords = outC - start;\\n          setOutput(getX(\" + s + \"));\\n        }\\n      }\\n    \" : \"\\n        int start = \" + a + \";\\n        int end = \" + i + \";\\n\\n        void main() {\\n          int outC = getOutputCoords();\\n          if (outC < start || outC >= end) {\\n            setOutput(float(\" + n + \"));\\n          } else {\\n            setOutput(getX(outC - start));\\n          }\\n        }\\n      \";\n  };\n}(),\n    Pool2DProgram = function () {\n  return function (e, t, n) {\n    if (this.variableNames = [\"x\"], \"avg\" === t && n) throw new Error(\"Cannot compute positions for average pool.\");var r = e.filterHeight,\n        o = e.filterWidth,\n        a = e.strideHeight,\n        i = e.strideWidth,\n        s = e.padInfo.top,\n        u = e.padInfo.left;this.outputShape = e.outShape;var l = \"avg\" === t,\n        c = \"0.0\";if (l || (c = \"-1.0 / 0.0\"), n) this.userCode = \"\\n        const ivec2 strides = ivec2(\" + a + \", \" + i + \");\\n        const ivec2 pads = ivec2(\" + s + \", \" + u + \");\\n\\n        void main() {\\n          ivec4 coords = getOutputCoords();\\n          int batch = coords[0];\\n          int d = coords[3];\\n\\n          ivec2 xRCCorner = coords.yz * strides - pads;\\n          int xRCorner = xRCCorner.x;\\n          int xCCorner = xRCCorner.y;\\n\\n          // max/min x(?, ?, d) to get y(yR, yC, d).\\n          // ? = to be determined\\n          float minMaxValue = 0.0;\\n          float minMaxValueFound = 0.0;\\n          int minMaxPosition = 0;\\n          float avgValue = 0.0;\\n\\n          for (int wR = 0; wR < \" + r + \"; wR++) {\\n            int xR = xRCorner + wR;\\n\\n            if (xR < 0 || xR >= \" + e.inHeight + \") {\\n              continue;\\n            }\\n\\n            for (int wC = 0; wC < \" + o + \"; wC++) {\\n              int xC = xCCorner + wC;\\n\\n              if (xC < 0 || xC >= \" + e.inWidth + \") {\\n                continue;\\n              }\\n\\n              float value = getX(batch, xR, xC, d);\\n\\n              // If a min / max value has already been found, use it. If not,\\n              // use the current value.\\n              float currMinMaxValue = mix(\\n                  value, minMaxValue, minMaxValueFound);\\n              if (value >= currMinMaxValue) {\\n                minMaxValue = value;\\n                minMaxValueFound = 1.0;\\n                minMaxPosition = wR * \" + o + \" + wC;\\n              }\\n            }\\n          }\\n          setOutput(float(minMaxPosition));\\n        }\\n      \";else {\n      var p = t + \"(\" + t + \"(\" + t + \"(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])\";\"avg\" === t && (p = \"avgValue / count\");var d = 4 * Math.floor(o / 4),\n          h = o % 4,\n          f = \"\\n      if (\" + l + \") {\\n        avgValue += dot(values, ones);\\n      } else {\\n        minMaxValue = max(values, minMaxValue);\\n      }\\n    \";this.userCode = \"\\n      const ivec2 strides = ivec2(\" + a + \", \" + i + \");\\n      const ivec2 pads = ivec2(\" + s + \", \" + u + \");\\n      const float initializationValue = \" + c + \";\\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\\n\\n      float count = 0.0;\\n\\n      float getValue(int batch, int xR, int xC, int d) {\\n        if (xC < 0 || xC >= \" + e.inWidth + \") {\\n          return initializationValue;\\n        }\\n        count += 1.0;\\n        return getX(batch, xR, xC, d);\\n      }\\n\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int batch = coords[0];\\n        int d = coords[3];\\n\\n        ivec2 xRCCorner = coords.yz * strides - pads;\\n        int xRCorner = xRCCorner.x;\\n        int xCCorner = xRCCorner.y;\\n\\n        // max/min x(?, ?, d) to get y(yR, yC, d).\\n        // ? = to be determined\\n        vec4 minMaxValue = vec4(\" + c + \");\\n        float avgValue = 0.0;\\n        count = 0.0;\\n\\n        for (int wR = 0; wR < \" + r + \"; wR++) {\\n          int xR = xRCorner + wR;\\n\\n          if (xR < 0 || xR >= \" + e.inHeight + \") {\\n            continue;\\n          }\\n\\n          for (int wC = 0; wC < \" + d + \"; wC += 4) {\\n            int xC = xCCorner + wC;\\n\\n            vec4 values = vec4(\\n              getValue(batch, xR, xC, d),\\n              getValue(batch, xR, xC + 1, d),\\n              getValue(batch, xR, xC + 2, d),\\n              getValue(batch, xR, xC + 3, d)\\n            );\\n\\n            \" + f + \"\\n          }\\n\\n          int xC = xCCorner + \" + d + \";\\n          if (\" + (1 === h) + \") {\\n            vec4 values = vec4(\\n              getValue(batch, xR, xC, d),\\n              initializationValue,\\n              initializationValue,\\n              initializationValue\\n            );\\n\\n            \" + f + \"\\n          } else if (\" + (2 === h) + \") {\\n            vec4 values = vec4(\\n              getValue(batch, xR, xC, d),\\n              getValue(batch, xR, xC + 1, d),\\n              initializationValue,\\n              initializationValue\\n            );\\n\\n            \" + f + \"\\n          } else if (\" + (3 === h) + \") {\\n            vec4 values = vec4(\\n              getValue(batch, xR, xC, d),\\n              getValue(batch, xR, xC + 1, d),\\n              getValue(batch, xR, xC + 2, d),\\n              initializationValue\\n            );\\n\\n            \" + f + \"\\n          }\\n        }\\n        setOutput(\" + p + \");\\n      }\\n    \";\n    }\n  };\n}(),\n    ReduceProgram = function () {\n  return function (e, t) {\n    this.variableNames = [\"x\"];var n = e.windowSize,\n        r = e.batchSize,\n        o = e.inSize,\n        a = Math.ceil(o / n);this.outputShape = [r, a];var i = \"0.0\",\n        s = \"\";\"min\" === t ? (i = \"1.0 / 0.0\", s = \"min\") : \"max\" === t && (i = \"-1.0 / 0.0\", s = \"max\");var u = t + \"(\" + t + \"(\" + t + \"(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])\";\"sum\" === t ? u = \"sumValue\" : \"all\" === t ? u = \"allValue\" : \"any\" === t && (u = \"anyValue\");var l = 4 * Math.floor(n / 4),\n        c = n % 4,\n        p = \"\\n      if (\" + (\"sum\" === t) + \") {\\n        sumValue += dot(values, ones);\\n      } else {\\n        minMaxValue = \" + s + \"(values, minMaxValue);\\n      }\\n    \",\n        d = \"vec4\";\"all\" === t ? (i = \"1.0\", p = \"\\n        bool reducedAllValue = all(values);\\n        float floatedReducedAllValue = float(reducedAllValue);\\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\\n      \", d = \"bvec4\") : \"any\" === t && (i = \"0.0\", p = \"\\n        bool reducedAnyValue = any(values);\\n        float floatedReducedAnyValue = float(reducedAnyValue);\\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\\n      \", d = \"bvec4\");var h = \"\";o % n > 0 && (h = \"\\n        if (inIdx < 0 || inIdx >= \" + o + \") {\\n          return initializationValue;\\n        }\\n      \"), this.userCode = \"\\n      const float initializationValue = \" + i + \";\\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\\n\\n      float getValue(int batch, int inIdx) {\\n        \" + h + \"\\n        return getX(batch, inIdx);\\n      }\\n\\n      void main() {\\n        ivec2 coords = getOutputCoords();\\n        int batch = coords[0];\\n        int outIdx = coords[1];\\n        int inOffset = outIdx * \" + n + \";\\n\\n        vec4 minMaxValue = vec4(\" + i + \");\\n        float sumValue = 0.0;\\n        float allValue = 1.0;\\n        float anyValue = 0.0;\\n\\n        for (int i = 0; i < \" + l + \"; i += 4) {\\n          int inIdx = inOffset + i;\\n          \" + d + \" values = \" + d + \"(\\n            getValue(batch, inIdx),\\n            getValue(batch, inIdx + 1),\\n            getValue(batch, inIdx + 2),\\n            getValue(batch, inIdx + 3)\\n          );\\n\\n          \" + p + \"\\n        }\\n\\n        int inIdx = inOffset + \" + l + \";\\n        if (\" + (1 === c) + \") {\\n          \" + d + \" values = \" + d + \"(\\n            getValue(batch, inIdx),\\n            initializationValue,\\n            initializationValue,\\n            initializationValue\\n          );\\n\\n          \" + p + \"\\n        } else if (\" + (2 === c) + \") {\\n          \" + d + \" values = \" + d + \"(\\n            getValue(batch, inIdx),\\n            getValue(batch, inIdx + 1),\\n            initializationValue,\\n            initializationValue\\n          );\\n\\n          \" + p + \"\\n        } else if (\" + (3 === c) + \") {\\n          \" + d + \" values = \" + d + \"(\\n            getValue(batch, inIdx),\\n            getValue(batch, inIdx + 1),\\n            getValue(batch, inIdx + 2),\\n            initializationValue\\n          );\\n\\n          \" + p + \"\\n        }\\n        setOutput(\" + u + \");\\n      }\\n    \";\n  };\n}(),\n    ResizeBilinearBackpropProgram = function () {\n  return function (e, t, n) {\n    this.variableNames = [\"dy\"], this.outputShape = [], this.outputShape = t.shape;var r = t.shape,\n        o = r[1],\n        a = r[2],\n        i = e.shape,\n        s = i[1],\n        u = i[2],\n        l = [n && s > 1 ? o - 1 : o, n && u > 1 ? a - 1 : a],\n        c = [n && s > 1 ? s - 1 : s, n && u > 1 ? u - 1 : u],\n        p = l[0] / c[0],\n        d = l[1] / c[1],\n        h = 1 / p,\n        f = 1 / d,\n        m = 2 * Math.ceil(h) + 2,\n        g = 2 * Math.ceil(f) + 2;this.userCode = \"\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int b = coords[0];\\n        int d = coords[3];\\n        int r = coords[1];\\n        int c = coords[2];\\n\\n        float accumulator = 0.0;\\n\\n        const float heightScale = float(\" + p + \");\\n        const float widthScale = float(\" + d + \");\\n\\n        const float invHeightScale = float(\" + h + \");\\n        const float invWidthScale = float(\" + f + \");\\n\\n        const int winHeight = int(\" + m + \");\\n        const int winWidth = int(\" + g + \");\\n\\n        // Compute bounds for where in dy we will look\\n        float startRLerp = floor(float(r) * invHeightScale);\\n        int startDyR = int(startRLerp - float(winHeight / 2));\\n\\n        float startCLerp = floor(float(c) * invWidthScale);\\n        int startDyC = int(startCLerp - float(winWidth / 2));\\n\\n        // Loop over dy\\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\\n          int dyR = dyROffset + startDyR;\\n\\n          // Guard against the window exceeding the bounds of dy\\n          if (dyR < 0 || dyR >= \" + s + \") {\\n            continue;\\n          }\\n\\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\\n            int dyC = dyCOffset + startDyC;\\n\\n            // Guard against the window exceeding the bounds of dy\\n            if (dyC < 0 || dyC >= \" + u + \") {\\n              continue;\\n            }\\n\\n            float dxR = float(dyR) * heightScale;\\n            int topDxRIndex = int(floor(dxR));\\n            int bottomDxRIndex = int(min(ceil(dxR), \" + (o - 1) + \".0));\\n            float dxRLerp = dxR - float(topDxRIndex);\\n            float inverseDxRLerp = 1.0 - dxRLerp;\\n\\n            float dxC = float(dyC) * widthScale;\\n            int leftDxCIndex = int(floor(dxC));\\n            int rightDxCIndex = int(min(ceil(dxC), \" + (a - 1) + \".0));\\n            float dxCLerp = dxC - float(leftDxCIndex);\\n            float inverseDxCLerp = 1.0 - dxCLerp;\\n\\n            if (r == topDxRIndex && c == leftDxCIndex) {\\n              // topLeft\\n              accumulator +=\\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\\n            }\\n\\n            if (r == topDxRIndex && c == rightDxCIndex) {\\n              // topRight\\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\\n            }\\n\\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\\n              // bottomLeft\\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\\n            }\\n\\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\\n              // bottomRight\\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\\n            }\\n          }\\n        }\\n        // End loop over dy\\n\\n        setOutput(accumulator);\\n      }\\n    \";\n  };\n}(),\n    ResizeBilinearProgram = function () {\n  return function (e, t, n, r) {\n    this.variableNames = [\"A\"], this.outputShape = [];var o = e[0],\n        a = e[1],\n        i = e[2],\n        s = e[3];this.outputShape = [o, t, n, s];var u = [r && t > 1 ? a - 1 : a, r && n > 1 ? i - 1 : i],\n        l = [r && t > 1 ? t - 1 : t, r && n > 1 ? n - 1 : n];this.userCode = \"\\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\\n          \" + u[0] / l[0] + \",\\n          \" + u[1] / l[1] + \");\\n      const vec2 inputShapeRC = vec2(\" + a + \".0, \" + i + \".0);\\n\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int b = coords[0];\\n        int d = coords[3];\\n        ivec2 yRC = coords.yz;\\n\\n        // Fractional source index.\\n        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;\\n\\n        // Compute the four integer indices.\\n        ivec2 sourceFloorRC = ivec2(sourceFracIndexRC);\\n        ivec2 sourceCeilRC = ivec2(\\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\\n\\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\\n\\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\\n\\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\\n        float newValue = top + (bottom - top) * fracRC.x;\\n\\n        setOutput(newValue);\\n      }\\n    \";\n  };\n}(),\n    ResizeNearestNeigborBackpropProgram = function () {\n  return function (e, t, n) {\n    this.variableNames = [\"dy\"], this.outputShape = [], this.outputShape = t.shape;var r = t.shape,\n        o = r[1],\n        a = r[2],\n        i = e.shape,\n        s = i[1],\n        u = i[2],\n        l = [n && s > 1 ? o - 1 : o, n && u > 1 ? a - 1 : a],\n        c = [n && s > 1 ? s - 1 : s, n && u > 1 ? u - 1 : u],\n        p = l[0] / c[0],\n        d = l[1] / c[1],\n        h = 1 / p,\n        f = 1 / d,\n        m = 2 * Math.ceil(h) + 2,\n        g = 2 * Math.ceil(f) + 2;this.userCode = \"\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int b = coords[0];\\n        int d = coords[3];\\n        int r = coords[1];\\n        int c = coords[2];\\n\\n        float accumulator = 0.0;\\n\\n        const float heightScale = float(\" + p + \");\\n        const float widthScale = float(\" + d + \");\\n\\n        const float invHeightScale = float(\" + h + \");\\n        const float invWidthScale = float(\" + f + \");\\n\\n        const int winHeight = int(\" + m + \");\\n        const int winWidth = int(\" + g + \");\\n\\n        // Compute bounds for where in dy we will look\\n        float startRLerp = floor(float(r) * invHeightScale);\\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\\n\\n        float startCLerp = floor(float(c) * invWidthScale);\\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\\n\\n        // Loop over dy\\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\\n          int dyR = dyROffset + startDyR;\\n\\n          // Guard against the window exceeding the bounds of dy\\n          if (dyR < 0 || dyR >= \" + s + \") {\\n            continue;\\n          }\\n\\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\\n            int dyC = dyCOffset + startDyC;\\n\\n            // Guard against the window exceeding the bounds of dy\\n            if (dyC < 0 || dyC >= \" + u + \") {\\n              continue;\\n            }\\n\\n            float sourceFracRow =\\n              float(\" + l[0] + \") *\\n                (float(dyR) / float(\" + c[0] + \"));\\n\\n            float sourceFracCol =\\n                float(\" + l[1] + \") *\\n                  (float(dyC) / float(\" + c[1] + \"));\\n\\n            int sourceNearestRow = int(min(\\n                float(int(\" + o + \") - 1),\\n                \" + n + \" ? float(round(sourceFracRow)) :\\n                                  float(floor(sourceFracRow))));\\n\\n            int sourceNearestCol = int(min(\\n                float(int(\" + a + \") - 1),\\n                \" + n + \" ? float(round(sourceFracCol)) :\\n                                  float(floor(sourceFracCol))));\\n\\n            if (r == sourceNearestRow && c == sourceNearestCol) {\\n              accumulator += getDy(b, dyR, dyC, d);\\n            }\\n          }\\n        }\\n        // End loop over dy\\n\\n        setOutput(accumulator);\\n      }\\n    \";\n  };\n}(),\n    ResizeNearestNeighborProgram = function () {\n  return function (e, t, n, r) {\n    this.variableNames = [\"A\"], this.outputShape = [];var o = e[0],\n        a = e[1],\n        i = e[2],\n        s = e[3];this.outputShape = [o, t, n, s];var u = [r && t > 1 ? a - 1 : a, r && n > 1 ? i - 1 : i],\n        l = [r && t > 1 ? t - 1 : t, r && n > 1 ? n - 1 : n],\n        c = r ? \"0.5\" : \"0.0\";this.userCode = \"\\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\\n          \" + u[0] / l[0] + \",\\n          \" + u[1] / l[1] + \");\\n      const vec2 inputShapeRC = vec2(\" + a + \".0, \" + i + \".0);\\n\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int b = coords[0];\\n        int d = coords[3];\\n        ivec2 yRC = coords.yz;\\n\\n        // Fractional source index.\\n        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;\\n\\n        // Compute the coordinators of nearest neighbor point.\\n        ivec2 sourceNearestRC = ivec2(\\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + \" + c + \")));\\n\\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\\n\\n        setOutput(newValue);\\n      }\\n    \";\n  };\n}(),\n    ReverseProgram = function () {\n  return function (e, t) {\n    this.variableNames = [\"x\"];var n = e.length;if (n > 4) throw new Error(\"WebGL backend: Reverse of rank-\" + n + \" tensor is not yet supported\");if (this.outputShape = e, 1 !== n) {\n      var r = e.map(function (n, r) {\n        return function (n) {\n          return -1 !== t.indexOf(n) && 1 !== e[n] ? e[n] + \" - coords[\" + n + \"] - 1\" : \"coords[\" + n + \"]\";\n        }(r);\n      }).join(\",\"),\n          o = getCoordsDataType(n);this.userCode = \"\\n      void main() {\\n        \" + o + \" coords = getOutputCoords();\\n        setOutput(getX(\" + r + \"));\\n      }\\n    \";\n    } else this.userCode = \"\\n        void main() {\\n          int coord = getOutputCoords();\\n          setOutput(getX(\" + e[0] + \" - coord - 1));\\n        }\\n      \";\n  };\n}(),\n    SegmentOpProgram = function () {\n  return function (e, t) {\n    this.variableNames = [\"x\", \"segmentIds\"];var n = e.windowSize,\n        r = e.batchSize,\n        o = e.inSize,\n        a = e.numSegments,\n        i = a * Math.ceil(o / n);this.outputShape = [r, i];var s = 4 * Math.floor(n / 4),\n        u = n % 4,\n        l = \"\\n        sumValue += dot(values, filter);\\n    \",\n        c = \"\";o % n > 0 && (c = \"\\n        if (inIdx < 0 || inIdx >= \" + o + \") {\\n          return initializationValue;\\n        }\\n      \");var p = \"\";o % n > 0 && (p = \"\\n        if (inIdx < 0 || inIdx >= \" + o + \") {\\n          return -1.0;\\n        }\\n      \"), this.userCode = \"\\n      const float initializationValue = 0.0;\\n\\n      float getValue(int batch, int inIdx) {\\n        \" + c + \"\\n        return getX(batch, inIdx);\\n      }\\n\\n      float getSegmentIdAtIndex(int inIdx) {\\n        \" + p + \"\\n        return getSegmentIds(inIdx);\\n      }\\n\\n      void main() {\\n        ivec2 coords = getOutputCoords();\\n        int batch = coords[0];\\n        int outIdx = coords[1];\\n        int inOffset = int(floor(float(outIdx) / float(\\n          \" + a + \")) * float(\" + n + \"));\\n        int currentSeg = int(mod(float(outIdx), float(\" + a + \")));\\n\\n        float sumValue = 0.0;\\n\\n        for (int i = 0; i < \" + s + \"; i += 4) {\\n          int inIdx = inOffset + i;\\n          vec4 values = vec4(\\n            getValue(batch, inIdx),\\n            getValue(batch, inIdx + 1),\\n            getValue(batch, inIdx + 2),\\n            getValue(batch, inIdx + 3)\\n          );\\n\\n          vec4 filter = vec4(\\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\\n          );\\n\\n          \" + l + \"\\n        }\\n\\n        int inIdx = inOffset + \" + s + \";\\n        if (\" + (1 === u) + \") {\\n          vec4 values = vec4(\\n            getValue(batch, inIdx),\\n            initializationValue,\\n            initializationValue,\\n            initializationValue\\n          );\\n\\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\\n\\n          vec4 filter = vec4(\\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\\n            0,\\n            0,\\n            0\\n          );\\n\\n          \" + l + \"\\n        } else if (\" + (2 === u) + \") {\\n          vec4 values = vec4(\\n            getValue(batch, inIdx),\\n            getValue(batch, inIdx + 1),\\n            initializationValue,\\n            initializationValue\\n          );\\n\\n          vec4 filter = vec4(\\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\\n              0,\\n              0\\n          );\\n\\n          \" + l + \"\\n        } else if (\" + (3 === u) + \") {\\n          vec4 values = vec4(\\n            getValue(batch, inIdx),\\n            getValue(batch, inIdx + 1),\\n            getValue(batch, inIdx + 2),\\n            initializationValue\\n          );\\n\\n          vec4 filter = vec4(\\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\\n            0\\n          );\\n\\n          \" + l + \"\\n        }\\n        setOutput(sumValue);\\n      }\\n    \";\n  };\n}(),\n    SelectProgram = function () {\n  return function (e, t, n) {\n    var r, o;if (this.variableNames = [\"c\", \"a\", \"b\"], this.outputShape = t, n > 4) throw Error(\"Where for rank \" + n + \" is not yet supported\");if (1 === n) o = \"resRC\", r = \"resRC\";else {\n      for (var a = [\"resRC.x\", \"resRC.y\", \"resRC.z\", \"resRC.w\"], i = [], s = [], u = 0; u < t.length; u++) s.push(\"\" + a[u]), u < e && i.push(\"\" + a[u]);r = i.join(), o = s.join();\n    }var l = getCoordsDataType(n);this.userCode = \"\\n      void main() {\\n        \" + l + \" resRC = getOutputCoords();\\n        float cVal = getC(\" + r + \");\\n        if (cVal >= 1.0) {\\n          setOutput(getA(\" + o + \"));\\n        } else {\\n          setOutput(getB(\" + o + \"));\\n        }\\n      }\\n    \";\n  };\n}(),\n    SliceProgram = function () {\n  function e(e) {\n    this.variableNames = [\"source\"], this.outputShape = e, this.rank = e.length;var t = getCoordsDataType(this.rank),\n        n = getCoords$1(this.rank);this.userCode = \"\\n      uniform \" + t + \" start;\\n\\n      void main() {\\n        \" + t + \" sourceLoc = start + getOutputCoords();\\n        setOutput(getSource(\" + n + \"));\\n      }\\n    \";\n  }return e.prototype.getCustomSetupFunc = function (e) {\n    var t = this;if (e.length !== this.rank) throw Error(\"The rank (\" + this.rank + \") of the program must match the length of start (\" + e.length + \")\");return function (n, r) {\n      if (null != t.startLoc || (t.startLoc = n.getUniformLocationNoThrow(r, \"start\"), null != t.startLoc)) if (1 === t.rank) n.gl.uniform1i(t.startLoc, e[0]);else if (2 === t.rank) n.gl.uniform2i(t.startLoc, e[0], e[1]);else if (3 === t.rank) n.gl.uniform3i(t.startLoc, e[0], e[1], e[2]);else {\n        if (4 !== t.rank) throw Error(\"Slicing for rank \" + t.rank + \" is not yet supported\");n.gl.uniform4i(t.startLoc, e[0], e[1], e[2], e[3]);\n      }\n    };\n  }, e;\n}();function getCoords$1(e) {\n  if (1 === e) return \"sourceLoc\";if (2 === e) return \"sourceLoc.x, sourceLoc.y\";if (3 === e) return \"sourceLoc.x, sourceLoc.y, sourceLoc.z\";if (4 === e) return \"sourceLoc.x, sourceLoc.y, sourceLoc.z, sourceLoc.w\";throw Error(\"Slicing for rank \" + e + \" is not yet supported\");\n}var StridedSliceProgram = function () {\n  return function (e, t, n, r) {\n    this.variableNames = [\"x\"];var o = n.filter(function (e, t) {\n      return -1 === r.indexOf(t);\n    });this.outputShape = o;var a = n.length,\n        i = getCoordsDataType(n.length),\n        s = getCoordsDataType(o.length),\n        u = \"\";if (1 === a) u = \"coords * strides + begin\";else {\n      var l = 0;u = n.map(function (e, t) {\n        return -1 === r.indexOf(t) ? (l++, 1 === o.length ? \"coords * strides[\" + t + \"] + begin[\" + t + \"]\" : \"coords[\" + (l - 1) + \"] * strides[\" + t + \"] + begin[\" + t + \"]\") : \"begin[\" + t + \"]\";\n      }).join(\",\");\n    }this.userCode = \"\\n      \" + i + \" begin = \" + i + \"(\" + e + \");\\n      \" + i + \" strides = \" + i + \"(\" + t + \");\\n\\n      void main() {\\n        \" + s + \" coords = getOutputCoords();\\n        setOutput(getX(\" + u + \"));\\n      }\\n    \";\n  };\n}(),\n    TextureManager = function () {\n  function e(e) {\n    this.gpgpu = e, this.numUsedTextures = 0, this.numFreeTextures = 0, this.freeTextures = {}, this.logEnabled = !1, this.usedTextures = {};\n  }return e.prototype.acquireTexture = function (e, t) {\n    var n,\n        r = getPhysicalFromLogicalTextureType(t),\n        o = getKeyFromTextureShape(e, r);if (o in this.freeTextures || (this.freeTextures[o] = []), o in this.usedTextures || (this.usedTextures[o] = []), this.freeTextures[o].length > 0) {\n      this.numFreeTextures--, this.numUsedTextures++, this.log();var a = this.freeTextures[o].shift();return this.usedTextures[o].push(a), a;\n    }return this.numUsedTextures++, this.log(), r === PhysicalTextureType.PACKED_2X2_FLOAT32 ? n = this.gpgpu.createPackedMatrixTexture(e[0], e[1]) : r === PhysicalTextureType.UNPACKED_FLOAT32 ? n = this.gpgpu.createFloat32MatrixTexture(e[0], e[1]) : r === PhysicalTextureType.UNPACKED_FLOAT16 ? n = this.gpgpu.createFloat16MatrixTexture(e[0], e[1]) : r === PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE && (n = this.gpgpu.createUnsignedBytesMatrixTexture(e[0], e[1])), this.usedTextures[o].push(n), n;\n  }, e.prototype.releaseTexture = function (e, t, n) {\n    var r = getKeyFromTextureShape(t, getPhysicalFromLogicalTextureType(n));r in this.freeTextures || (this.freeTextures[r] = []), this.freeTextures[r].push(e), this.numFreeTextures++, this.numUsedTextures--;var o = this.usedTextures[r],\n        a = o.indexOf(e);if (a < 0) throw new Error(\"Cannot release a texture that was never provided by this texture manager\");o.splice(a, 1), this.log();\n  }, e.prototype.log = function () {\n    if (this.logEnabled) {\n      var e = this.numFreeTextures + this.numUsedTextures;console.log(\"Free/Used\", this.numFreeTextures + \" / \" + this.numUsedTextures, \"(\" + e + \")\");\n    }\n  }, e.prototype.getNumUsedTextures = function () {\n    return this.numUsedTextures;\n  }, e.prototype.getNumFreeTextures = function () {\n    return this.numFreeTextures;\n  }, e.prototype.dispose = function () {\n    var e = this;if (null != this.freeTextures) {\n      for (var t in this.freeTextures) this.freeTextures[t].forEach(function (t) {\n        e.gpgpu.deleteMatrixTexture(t);\n      });for (var t in this.usedTextures) this.usedTextures[t].forEach(function (t) {\n        e.gpgpu.deleteMatrixTexture(t);\n      });this.freeTextures = null, this.usedTextures = null, this.numUsedTextures = 0, this.numFreeTextures = 0;\n    }\n  }, e;\n}();function getPhysicalFromLogicalTextureType(e) {\n  if (e === TextureUsage.DOWNLOAD || e === TextureUsage.PIXELS) return PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE;if (e === TextureUsage.UPLOAD) return PhysicalTextureType.UNPACKED_FLOAT32;if (e === TextureUsage.RENDER) return ENV.get(\"WEBGL_RENDER_FLOAT32_ENABLED\") ? PhysicalTextureType.UNPACKED_FLOAT32 : PhysicalTextureType.UNPACKED_FLOAT16;if (e === TextureUsage.PACK) return PhysicalTextureType.PACKED_2X2_FLOAT32;throw new Error(\"Unknown logical texture type \" + e);\n}function getKeyFromTextureShape(e, t) {\n  return e[0] + \"_\" + e[1] + \"_\" + t;\n}var TileProgram = function () {\n  return function (e, t) {\n    this.variableNames = [\"A\"];for (var n = new Array(e.length), r = 0; r < n.length; r++) n[r] = e[r] * t[r];this.outputShape = n, this.rank = n.length;var o = getCoordsDataType(this.rank),\n        a = getSourceCoords$1(e);this.userCode = \"\\n      void main() {\\n        \" + o + \" resRC = getOutputCoords();\\n        setOutput(getA(\" + a + \"));\\n      }\\n    \";\n  };\n}();function getSourceCoords$1(e) {\n  var t = e.length;if (t > 5) throw Error(\"Tile for rank \" + t + \" is not yet supported\");if (1 === t) return \"imod(resRC, \" + e[0] + \")\";for (var n = [\"resRC.x\", \"resRC.y\", \"resRC.z\", \"resRC.w\", \"resRC.u\"], r = [], o = 0; o < e.length; o++) r.push(\"imod(\" + n[o] + \", \" + e[o] + \")\");return r.join();\n}var TransposeProgram = function () {\n  return function (e, t) {\n    this.variableNames = [\"A\"];for (var n = new Array(e.length), r = 0; r < n.length; r++) n[r] = e[t[r]];this.outputShape = n, this.rank = n.length;var o = getCoordsDataType(this.rank),\n        a = getSwitchedCoords(t);this.userCode = \"\\n    void main() {\\n      \" + o + \" resRC = getOutputCoords();\\n      setOutput(getA(\" + a + \"));\\n    }\\n    \";\n  };\n}();function getSwitchedCoords(e) {\n  var t = e.length;if (t > 6) throw Error(\"Transpose for rank \" + t + \" is not yet supported\");for (var n = [\"resRC.x\", \"resRC.y\", \"resRC.z\", \"resRC.w\", \"resRC.u\", \"resRC.v\"], r = new Array(t), o = 0; o < e.length; o++) r[e[o]] = n[o];return r.join();\n}var ERF_P = .3275911,\n    ERF_A1 = .254829592,\n    ERF_A2 = -.284496736,\n    ERF_A3 = 1.421413741,\n    ERF_A4 = -1.453152027,\n    ERF_A5 = 1.061405429,\n    SELU_SCALEALPHA = 1.7580993408473768,\n    SELU_SCALE = 1.0507009873554805,\n    UnaryOpProgram = function () {\n  function e(e, t) {\n    this.variableNames = [\"A\"], this.outputShape = e, this.userCode = \"\\n      uniform float NAN;\\n      float unaryOperation(float x) {\\n        \" + t + \"\\n      }\\n\\n      void main() {\\n        float x = getAAtOutCoords();\\n        float y = unaryOperation(x);\\n\\n        setOutput(y);\\n      }\\n    \";\n  }return e.prototype.getCustomSetupFunc = function () {\n    var e = this;return function (t, n) {\n      null == e.startLoc && (e.startLoc = t.getUniformLocationNoThrow(n, \"NAN\"), null == e.startLoc) || t.gl.uniform1f(e.startLoc, NaN);\n    };\n  }, e;\n}(),\n    CHECK_NAN_SNIPPET$1 = \"if (isNaN(x)) return x;\",\n    ABS = \"return abs(x);\",\n    RELU = CHECK_NAN_SNIPPET$1 + \"\\n  return (x < 0.0) ? 0.0 : x;\\n\",\n    ELU = \"return (x >= 0.0) ? x : (exp(x) - 1.0);\",\n    SELU = \"\\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\\n  // see: https://arxiv.org/abs/1706.02515\\n  float scaleAlpha = \" + SELU_SCALEALPHA + \";\\n  float scale = \" + SELU_SCALE + \";\\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\\n\";function STEP(e) {\n  return void 0 === e && (e = 0), CHECK_NAN_SNIPPET$1 + \"\\n    return x > 0.0 ? 1.0 : float(\" + e + \");\\n  \";\n}var NEG = \"return -x;\",\n    CEIL = \"return ceil(x);\",\n    FLOOR = \"return floor(x);\",\n    SIGN = \"\\n  if (isNaN(x)) { return 0.0; }\\n  return sign(x);\\n\",\n    ROUND = \"\\n  // OpenGL ES does not support round function.\\n  // The algorithm is based on banker's rounding.\\n  float base = floor(x);\\n  if ((x - base) < 0.5) {\\n    return floor(x);\\n  } else if ((x - base) > 0.5) {\\n    return ceil(x);\\n  } else {\\n    if (mod(base, 2.0) == 0.0) {\\n      return base;\\n    } else {\\n      return base + 1.0;\\n    }\\n  }\\n\",\n    EXP = \"return exp(x);\",\n    EXPM1 = \"return exp(x) - 1.0;\",\n    LOG = \"if (x < 0.0) return NAN;\\n  return log(x);\",\n    LOG1P = \"return log(1.0 + x);\",\n    SQRT = \"return sqrt(x);\",\n    RSQRT = \"return inversesqrt(x);\",\n    SIGMOID = \"return 1.0 / (1.0 + exp(-1.0 * x));\",\n    SOFTPLUS = \"\\n  float epsilon = 1.1920928955078125e-7;\\n  float threshold = log(epsilon) + 2.0;\\n\\n  bool too_large = x > -threshold;\\n  bool too_small = x < threshold;\\n\\n  float result;\\n  float exp_x = exp(x);\\n\\n  if (too_large){\\n    result = x;\\n  }\\n  else if (too_small){\\n    result = exp_x;\\n  }\\n  else{\\n    result = log(exp_x + 1.0);\\n  }\\n  return result;\\n\",\n    SIN = CHECK_NAN_SNIPPET$1 + \"\\n  return sin(x);\\n\",\n    COS = CHECK_NAN_SNIPPET$1 + \"\\n  return cos(x);\\n\",\n    TAN = \"return tan(x);\",\n    ASIN = \"return asin(x);\",\n    ACOS = \"return acos(x);\",\n    ATAN = CHECK_NAN_SNIPPET$1 + \"\\n  return atan(x);\\n\",\n    SINH = \"\\n  float e2x = exp(x);\\n  return (e2x - 1.0 / e2x) / 2.0;\\n\",\n    COSH = \"\\n  float e2x = exp(-x);\\n  return (e2x + 1.0 / e2x) / 2.0;\\n\",\n    TANH = \"\\n  float e2x = exp(-2.0 * abs(x));\\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\\n\",\n    ASINH = \"return log(x + sqrt(x * x + 1.0));\",\n    ACOSH = CHECK_NAN_SNIPPET$1 + \"\\n  if (x < 1.0) return NAN;\\n  return log(x + sqrt(x * x - 1.0));\",\n    ATANH = CHECK_NAN_SNIPPET$1 + \"\\n  if ((x < -1.0) || (x > 1.0)) return NAN;\\n  return (log(1.0 + x) - log(1.0 - x)) / 2.0;\",\n    ERF = '\\n  // Error function is calculated approximately with elementary function.\\n  // See \"Handbook of Mathematical Functions with Formulas,\\n  // Graphs, and Mathematical Tables\", Abramowitz and Stegun.\\n  float p = ' + ERF_P + \";\\n  float a1 = \" + ERF_A1 + \";\\n  float a2 = \" + ERF_A2 + \";\\n  float a3 = \" + ERF_A3 + \";\\n  float a4 = \" + ERF_A4 + \";\\n  float a5 = \" + ERF_A5 + \";\\n\\n  float t = 1.0 / (1.0 + p * x);\\n  return 1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x);\\n\",\n    SQUARE = \"return x * x;\",\n    RECIPROCAL = \"return 1.0 / x;\",\n    LOGICAL_NOT = \"return float(!(x >= 1.0));\",\n    TO_INT = \"return float(int(x));\",\n    UnpackProgram = function () {\n  return function (e) {\n    this.variableNames = [\"A\"], this.outputShape = e, this.userCode = \"\\n      const vec2 onePixel = 1. / vec2(\" + e[1] + \", \" + e[0] + \");\\n\\n      void main() {\\n        ivec2 rc = getOutputCoords();\\n        vec2 modCoord = mod(vec2(rc.y, rc.x), 2.);\\n\\n        vec4 packedInput = texture2D(A,\\n          resultUV - step(1., modCoord) * onePixel);\\n\\n        setOutput(\\n          modCoord.x == 0. ?\\n            (modCoord.y == 0. ? packedInput.r : packedInput.b) :\\n            (modCoord.y == 0. ? packedInput.g : packedInput.a)\\n        );\\n      }\\n    \";\n  };\n}();function concat1d_(e) {\n  return concat(e, 0);\n}function concat2d_(e, t) {\n  return concat(e, t);\n}function concat3d_(e, t) {\n  return concat(e, t);\n}function concat4d_(e, t) {\n  return concat(e, t);\n}function concat_(e, t) {\n  void 0 === t && (t = 0), assert(e.length >= 1, \"Pass at least one tensor to concat\");var n = convertToTensorArray(e, \"tensors\", \"concat\");t = parseAxisParam(t, n[0].shape)[0];var r = computeOutShape(n.map(function (e) {\n    return e.shape;\n  }), t);if (0 === sizeFromShape(r)) return tensor([], r);if (1 === (n = n.filter(function (e) {\n    return e.size > 0;\n  })).length) return n[0];var o = n.map(function (e) {\n    return e.shape;\n  });assertParamsConsistent(o, t);var a = n;return ENV.engine.runKernel(function (e) {\n    return e.concat(n, t);\n  }, a, function (e) {\n    var n = o.map(function (e) {\n      return e[t];\n    });return split$1(e, n, t).map(function (e) {\n      return function () {\n        return e;\n      };\n    });\n  });\n}function split_(e, t, n) {\n  void 0 === n && (n = 0);var r,\n      o = convertToTensor(e, \"x\", \"split\");n = parseAxisParam(n, o.shape)[0], \"number\" == typeof t ? (assert(o.shape[n] % t == 0, \"Number of splits must evenly divide the axis.\"), r = Array(t).fill(o.shape[n] / t)) : (assert(o.shape[n] === t.reduce(function (e, t) {\n    return e + t;\n  }), \"The sum of sizes must match the size of the axis dimension.\"), r = t);return ENV.engine.runKernel(function (e) {\n    return e.split(o, r, n);\n  }, { $x: o }, function (e) {\n    return { $x: function () {\n        return concat(e, n);\n      } };\n  });\n}var concat = op({ concat_: concat_ }),\n    concat1d = op({ concat1d_: concat1d_ }),\n    concat2d = op({ concat2d_: concat2d_ }),\n    concat3d = op({ concat3d_: concat3d_ }),\n    concat4d = op({ concat4d_: concat4d_ }),\n    split$1 = op({ split_: split_ }),\n    commonjsGlobal = \"undefined\" != typeof window ? window : \"undefined\" != typeof global ? global : \"undefined\" != typeof self ? self : {};function createCommonjsModule(e, t) {\n  return e(t = { exports: {} }, t.exports), t.exports;\n}var alea = createCommonjsModule(function (e) {\n  !function (e, t, n) {\n    function r(e, t) {\n      return t.c = e.c, t.s0 = e.s0, t.s1 = e.s1, t.s2 = e.s2, t;\n    }function o(e, t) {\n      var n = new function (e) {\n        var t,\n            n = this,\n            r = (t = 4022871197, function (e) {\n          e = e.toString();for (var n = 0; n < e.length; n++) {\n            var r = .02519603282416938 * (t += e.charCodeAt(n));r -= t = r >>> 0, t = (r *= t) >>> 0, t += 4294967296 * (r -= t);\n          }return 2.3283064365386963e-10 * (t >>> 0);\n        });n.next = function () {\n          var e = 2091639 * n.s0 + 2.3283064365386963e-10 * n.c;return n.s0 = n.s1, n.s1 = n.s2, n.s2 = e - (n.c = 0 | e);\n        }, n.c = 1, n.s0 = r(\" \"), n.s1 = r(\" \"), n.s2 = r(\" \"), n.s0 -= r(e), n.s0 < 0 && (n.s0 += 1), n.s1 -= r(e), n.s1 < 0 && (n.s1 += 1), n.s2 -= r(e), n.s2 < 0 && (n.s2 += 1), r = null;\n      }(e),\n          o = t && t.state,\n          a = n.next;return a.int32 = function () {\n        return 4294967296 * n.next() | 0;\n      }, a.double = function () {\n        return a() + 1.1102230246251565e-16 * (2097152 * a() | 0);\n      }, a.quick = a, o && (\"object\" == typeof o && r(o, n), a.state = function () {\n        return r(n, {});\n      }), a;\n    }t && t.exports ? t.exports = o : n && n.amd ? n(function () {\n      return o;\n    }) : this.alea = o;\n  }(0, e, !1);\n}),\n    xor128 = createCommonjsModule(function (e) {\n  !function (e, t, n) {\n    function r(e, t) {\n      return t.x = e.x, t.y = e.y, t.z = e.z, t.w = e.w, t;\n    }function o(e, t) {\n      var n = new function (e) {\n        var t = this,\n            n = \"\";t.x = 0, t.y = 0, t.z = 0, t.w = 0, t.next = function () {\n          var e = t.x ^ t.x << 11;return t.x = t.y, t.y = t.z, t.z = t.w, t.w ^= t.w >>> 19 ^ e ^ e >>> 8;\n        }, e === (0 | e) ? t.x = e : n += e;for (var r = 0; r < n.length + 64; r++) t.x ^= 0 | n.charCodeAt(r), t.next();\n      }(e),\n          o = t && t.state,\n          a = function () {\n        return (n.next() >>> 0) / 4294967296;\n      };return a.double = function () {\n        do {\n          var e = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21);\n        } while (0 === e);return e;\n      }, a.int32 = n.next, a.quick = a, o && (\"object\" == typeof o && r(o, n), a.state = function () {\n        return r(n, {});\n      }), a;\n    }t && t.exports ? t.exports = o : n && n.amd ? n(function () {\n      return o;\n    }) : this.xor128 = o;\n  }(0, e, !1);\n}),\n    xorwow = createCommonjsModule(function (e) {\n  !function (e, t, n) {\n    function r(e, t) {\n      return t.x = e.x, t.y = e.y, t.z = e.z, t.w = e.w, t.v = e.v, t.d = e.d, t;\n    }function o(e, t) {\n      var n = new function (e) {\n        var t = this,\n            n = \"\";t.next = function () {\n          var e = t.x ^ t.x >>> 2;return t.x = t.y, t.y = t.z, t.z = t.w, t.w = t.v, (t.d = t.d + 362437 | 0) + (t.v = t.v ^ t.v << 4 ^ e ^ e << 1) | 0;\n        }, t.x = 0, t.y = 0, t.z = 0, t.w = 0, t.v = 0, e === (0 | e) ? t.x = e : n += e;for (var r = 0; r < n.length + 64; r++) t.x ^= 0 | n.charCodeAt(r), r == n.length && (t.d = t.x << 10 ^ t.x >>> 4), t.next();\n      }(e),\n          o = t && t.state,\n          a = function () {\n        return (n.next() >>> 0) / 4294967296;\n      };return a.double = function () {\n        do {\n          var e = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21);\n        } while (0 === e);return e;\n      }, a.int32 = n.next, a.quick = a, o && (\"object\" == typeof o && r(o, n), a.state = function () {\n        return r(n, {});\n      }), a;\n    }t && t.exports ? t.exports = o : n && n.amd ? n(function () {\n      return o;\n    }) : this.xorwow = o;\n  }(0, e, !1);\n}),\n    xorshift7 = createCommonjsModule(function (e) {\n  !function (e, t, n) {\n    function r(e, t) {\n      return t.x = e.x.slice(), t.i = e.i, t;\n    }function o(e, t) {\n      null == e && (e = +new Date());var n = new function (e) {\n        var t = this;t.next = function () {\n          var e,\n              n,\n              r = t.x,\n              o = t.i;return e = r[o], n = (e ^= e >>> 7) ^ e << 24, n ^= (e = r[o + 1 & 7]) ^ e >>> 10, n ^= (e = r[o + 3 & 7]) ^ e >>> 3, n ^= (e = r[o + 4 & 7]) ^ e << 7, e = r[o + 7 & 7], n ^= (e ^= e << 13) ^ e << 9, r[o] = n, t.i = o + 1 & 7, n;\n        }, function (e, t) {\n          var n,\n              r = [];if (t === (0 | t)) r[0] = t;else for (t = \"\" + t, n = 0; n < t.length; ++n) r[7 & n] = r[7 & n] << 15 ^ t.charCodeAt(n) + r[n + 1 & 7] << 13;for (; r.length < 8;) r.push(0);for (n = 0; n < 8 && 0 === r[n]; ++n);for (8 == n ? r[7] = -1 : r[n], e.x = r, e.i = 0, n = 256; n > 0; --n) e.next();\n        }(t, e);\n      }(e),\n          o = t && t.state,\n          a = function () {\n        return (n.next() >>> 0) / 4294967296;\n      };return a.double = function () {\n        do {\n          var e = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21);\n        } while (0 === e);return e;\n      }, a.int32 = n.next, a.quick = a, o && (o.x && r(o, n), a.state = function () {\n        return r(n, {});\n      }), a;\n    }t && t.exports ? t.exports = o : n && n.amd ? n(function () {\n      return o;\n    }) : this.xorshift7 = o;\n  }(0, e, !1);\n}),\n    xor4096 = createCommonjsModule(function (e) {\n  !function (e, t, n) {\n    function r(e, t) {\n      return t.i = e.i, t.w = e.w, t.X = e.X.slice(), t;\n    }function o(e, t) {\n      null == e && (e = +new Date());var n = new function (e) {\n        var t = this;t.next = function () {\n          var e,\n              n,\n              r = t.w,\n              o = t.X,\n              a = t.i;return t.w = r = r + 1640531527 | 0, n = o[a + 34 & 127], e = o[a = a + 1 & 127], n ^= n << 13, e ^= e << 17, n ^= n >>> 15, e ^= e >>> 12, n = o[a] = n ^ e, t.i = a, n + (r ^ r >>> 16) | 0;\n        }, function (e, t) {\n          var n,\n              r,\n              o,\n              a,\n              i,\n              s = [],\n              u = 128;for (t === (0 | t) ? (r = t, t = null) : (t += \"\\0\", r = 0, u = Math.max(u, t.length)), o = 0, a = -32; a < u; ++a) t && (r ^= t.charCodeAt((a + 32) % t.length)), 0 === a && (i = r), r ^= r << 10, r ^= r >>> 15, r ^= r << 4, r ^= r >>> 13, a >= 0 && (i = i + 1640531527 | 0, o = 0 == (n = s[127 & a] ^= r + i) ? o + 1 : 0);for (o >= 128 && (s[127 & (t && t.length || 0)] = -1), o = 127, a = 512; a > 0; --a) r = s[o + 34 & 127], n = s[o = o + 1 & 127], r ^= r << 13, n ^= n << 17, r ^= r >>> 15, n ^= n >>> 12, s[o] = r ^ n;e.w = i, e.X = s, e.i = o;\n        }(t, e);\n      }(e),\n          o = t && t.state,\n          a = function () {\n        return (n.next() >>> 0) / 4294967296;\n      };return a.double = function () {\n        do {\n          var e = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21);\n        } while (0 === e);return e;\n      }, a.int32 = n.next, a.quick = a, o && (o.X && r(o, n), a.state = function () {\n        return r(n, {});\n      }), a;\n    }t && t.exports ? t.exports = o : n && n.amd ? n(function () {\n      return o;\n    }) : this.xor4096 = o;\n  }(0, e, !1);\n}),\n    tychei = createCommonjsModule(function (e) {\n  !function (e, t, n) {\n    function r(e, t) {\n      return t.a = e.a, t.b = e.b, t.c = e.c, t.d = e.d, t;\n    }function o(e, t) {\n      var n = new function (e) {\n        var t = this,\n            n = \"\";t.next = function () {\n          var e = t.b,\n              n = t.c,\n              r = t.d,\n              o = t.a;return e = e << 25 ^ e >>> 7 ^ n, n = n - r | 0, r = r << 24 ^ r >>> 8 ^ o, o = o - e | 0, t.b = e = e << 20 ^ e >>> 12 ^ n, t.c = n = n - r | 0, t.d = r << 16 ^ n >>> 16 ^ o, t.a = o - e | 0;\n        }, t.a = 0, t.b = 0, t.c = -1640531527, t.d = 1367130551, e === Math.floor(e) ? (t.a = e / 4294967296 | 0, t.b = 0 | e) : n += e;for (var r = 0; r < n.length + 20; r++) t.b ^= 0 | n.charCodeAt(r), t.next();\n      }(e),\n          o = t && t.state,\n          a = function () {\n        return (n.next() >>> 0) / 4294967296;\n      };return a.double = function () {\n        do {\n          var e = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21);\n        } while (0 === e);return e;\n      }, a.int32 = n.next, a.quick = a, o && (\"object\" == typeof o && r(o, n), a.state = function () {\n        return r(n, {});\n      }), a;\n    }t && t.exports ? t.exports = o : n && n.amd ? n(function () {\n      return o;\n    }) : this.tychei = o;\n  }(0, e, !1);\n}),\n    seedrandom = createCommonjsModule(function (e) {\n  !function (t, n) {\n    var r,\n        o = this,\n        a = 256,\n        i = 6,\n        s = \"random\",\n        u = n.pow(a, i),\n        l = n.pow(2, 52),\n        c = 2 * l,\n        p = a - 1;function d(e, d, g) {\n      var v = [],\n          x = f(function e(t, n) {\n        var r,\n            o = [],\n            a = typeof t;if (n && \"object\" == a) for (r in t) try {\n          o.push(e(t[r], n - 1));\n        } catch (e) {}return o.length ? o : \"string\" == a ? t : t + \"\\0\";\n      }((d = 1 == d ? { entropy: !0 } : d || {}).entropy ? [e, m(t)] : null == e ? function () {\n        try {\n          var e;return r && (e = r.randomBytes) ? e = e(a) : (e = new Uint8Array(a), (o.crypto || o.msCrypto).getRandomValues(e)), m(e);\n        } catch (e) {\n          var n = o.navigator,\n              i = n && n.plugins;return [+new Date(), o, i, o.screen, m(t)];\n        }\n      }() : e, 3), v),\n          y = new function (e) {\n        var t,\n            n = e.length,\n            r = this,\n            o = 0,\n            i = r.i = r.j = 0,\n            s = r.S = [];n || (e = [n++]);for (; o < a;) s[o] = o++;for (o = 0; o < a; o++) s[o] = s[i = p & i + e[o % n] + (t = s[o])], s[i] = t;(r.g = function (e) {\n          for (var t, n = 0, o = r.i, i = r.j, s = r.S; e--;) t = s[o = p & o + 1], n = n * a + s[p & (s[o] = s[i = p & i + t]) + (s[i] = t)];return r.i = o, r.j = i, n;\n        })(a);\n      }(v),\n          T = function () {\n        for (var e = y.g(i), t = u, n = 0; e < l;) e = (e + n) * a, t *= a, n = y.g(1);for (; e >= c;) e /= 2, t /= 2, n >>>= 1;return (e + n) / t;\n      };return T.int32 = function () {\n        return 0 | y.g(4);\n      }, T.quick = function () {\n        return y.g(4) / 4294967296;\n      }, T.double = T, f(m(y.S), t), (d.pass || g || function (e, t, r, o) {\n        return o && (o.S && h(o, y), e.state = function () {\n          return h(y, {});\n        }), r ? (n[s] = e, t) : e;\n      })(T, x, \"global\" in d ? d.global : this == n, d.state);\n    }function h(e, t) {\n      return t.i = e.i, t.j = e.j, t.S = e.S.slice(), t;\n    }function f(e, t) {\n      for (var n, r = e + \"\", o = 0; o < r.length;) t[p & o] = p & (n ^= 19 * t[p & o]) + r.charCodeAt(o++);return m(t);\n    }function m(e) {\n      return String.fromCharCode.apply(0, e);\n    }if (n[\"seed\" + s] = d, f(n.random(), t), e.exports) {\n      e.exports = d;try {\n        r = require(\"crypto\");\n      } catch (e) {}\n    } else 0;\n  }([], Math);\n});seedrandom.alea = alea, seedrandom.xor128 = xor128, seedrandom.xorwow = xorwow, seedrandom.xorshift7 = xorshift7, seedrandom.xor4096 = xor4096, seedrandom.tychei = tychei;var seedrandom$1 = seedrandom,\n    seedrandom_1 = seedrandom$1.alea,\n    MPRandGauss = function () {\n  function e(e, t, n, r, o) {\n    this.mean = e, this.stdDev = t, this.dtype = n, this.nextVal = NaN, this.truncated = r, this.truncated && (this.upper = this.mean + 2 * this.stdDev, this.lower = this.mean - 2 * this.stdDev);var a = o || Math.random();this.random = seedrandom_1(a.toString());\n  }return e.prototype.nextValue = function () {\n    if (!isNaN(this.nextVal)) {\n      var e = this.nextVal;return this.nextVal = NaN, e;\n    }for (var t, n, r = !1; !r;) {\n      var o = void 0,\n          a = void 0,\n          i = void 0;do {\n        i = (o = 2 * this.random() - 1) * o + (a = 2 * this.random() - 1) * a;\n      } while (i >= 1 || 0 === i);var s = Math.sqrt(-2 * Math.log(i) / i);t = this.mean + this.stdDev * o * s, n = this.mean + this.stdDev * a * s, this.truncated && !this.isValidTruncated(t) || (r = !0);\n    }return this.truncated && !this.isValidTruncated(n) || (this.nextVal = this.convertValue(n)), this.convertValue(t);\n  }, e.prototype.convertValue = function (e) {\n    return null == this.dtype || \"float32\" === this.dtype ? e : Math.round(e);\n  }, e.prototype.isValidTruncated = function (e) {\n    return e <= this.upper && e >= this.lower;\n  }, e;\n}();function clone_(e) {\n  var t = convertToTensor(e, \"x\", \"clone\");return ENV.engine.runKernel(function (e) {\n    return Tensor.make(t.shape, { dataId: t.dataId }, t.dtype);\n  }, { $x: t }, function (e) {\n    return { $x: function () {\n        return e.toFloat();\n      } };\n  });\n}function eye_(e, t, n, r) {\n  void 0 === r && (r = \"float32\"), null == t && (t = e);for (var o = buffer([e, t], r), a = e <= t ? e : t, i = 0; i < a; ++i) o.set(1, i, i);var s = o.toTensor().as2D(e, t);if (null == n) return s;if (1 === n.length) return tile(expandDims(s, 0), [n[0], 1, 1]);if (2 === n.length) return tile(expandDims(expandDims(s, 0), 0), [n[0], n[1], 1, 1]);if (3 === n.length) return tile(expandDims(expandDims(expandDims(s, 0), 0), 0), [n[0], n[1], n[2], 1, 1]);throw new Error(\"eye() currently supports only 1D and 2D batchShapes, but received \" + n.length + \"D.\");\n}function randomNormal_(e, t, n, r, o) {\n  if (void 0 === t && (t = 0), void 0 === n && (n = 1), null != r && \"bool\" === r) throw new Error(\"Unsupported data type \" + r);for (var a = new MPRandGauss(t, n, r, !1, o), i = buffer(e, r), s = 0; s < i.values.length; s++) i.values[s] = a.nextValue();return i.toTensor();\n}function truncatedNormal_(e, t, n, r, o) {\n  if (void 0 === t && (t = 0), void 0 === n && (n = 1), null != r && \"bool\" === r) throw new Error(\"Unsupported data type \" + r);for (var a = new MPRandGauss(t, n, r, !0, o), i = buffer(e, r), s = 0; s < i.values.length; s++) i.values[s] = a.nextValue();return i.toTensor();\n}function randomUniform_(e, t, n, r) {\n  void 0 === t && (t = 0), void 0 === n && (n = 1), void 0 === r && (r = \"float32\");for (var o = buffer(e, r), a = 0; a < o.values.length; a++) o.values[a] = randUniform(t, n);return o.toTensor();\n}function rand_(e, t, n) {\n  var r = sizeFromShape(e),\n      o = null;if (null == n || \"float32\" === n) o = new Float32Array(r);else if (\"int32\" === n) o = new Int32Array(r);else {\n    if (\"bool\" !== n) throw new Error(\"Unknown data type \" + n);o = new Uint8Array(r);\n  }for (var a = 0; a < r; a++) o[a] = t();return Tensor.make(e, { values: o }, n);\n}function multinomial_(e, t, n, r) {\n  void 0 === r && (r = !1);var o = convertToTensor(e, \"logits\", \"multinomial\"),\n      a = o.size,\n      i = o.rank;if (a < 2) throw new Error(\"Error in multinomial: you need at least 2 outcomes, but got \" + a + \".\");if (i > 2) throw new Error(\"Rank of probabilities must be 1 or 2, but is \" + i);n = n || Math.random();var s = 1 === i ? o.as2D(1, -1) : o,\n      u = ENV.engine.runKernel(function (e) {\n    return e.multinomial(s, r, t, n);\n  }, { logits2D: s });return 1 === i ? u.as1D() : u;\n}function oneHot_(e, t, n, r) {\n  void 0 === n && (n = 1), void 0 === r && (r = 0);var o = convertToTensor(e, \"indices\", \"oneHot\", \"int32\");if (assert(\"int32\" === o.dtype, \"Indices must be of dtype `int32`\"), t < 2) throw new Error(\"Error in oneHot: depth must be >=2, but it is \" + t);return ENV.engine.runKernel(function (e) {\n    return e.oneHot(o, t, n, r);\n  }, { $indices: o }, function (e) {\n    return { $indices: function () {\n        return zerosLike(o);\n      } };\n  });\n}function fromPixels_(e, t) {\n  if (void 0 === t && (t = 3), t > 4) throw new Error(\"Cannot construct Tensor with more than 4 channels from pixels.\");return ENV.engine.fromPixels(e, t);\n}function toPixels(e, t) {\n  return __awaiter(this, void 0, void 0, function () {\n    var n, r, o, a, i, s, u, l, c, p, d, h, f, m, g, v, x, y, T, b;return __generator(this, function (S) {\n      switch (S.label) {case 0:\n          if (2 !== (n = convertToTensor(e, \"img\", \"toPixels\", \"int32\")).rank && 3 !== n.rank) throw new Error(\"toPixels only supports rank 2 or 3 tensors, got rank \" + n.rank + \".\");if (r = n.shape.slice(0, 2), o = r[0], a = r[1], (i = 2 === n.rank ? 1 : n.shape[2]) > 4 || 2 === i) throw new Error(\"toPixels only supports depth of size 1, 3 or 4 but got \" + i);return s = n.min(), u = n.max(), [4, s.data()];case 1:\n          return l = S.sent()[0], [4, u.data()];case 2:\n          if (c = S.sent()[0], s.dispose(), u.dispose(), \"float32\" === n.dtype) {\n            if (l < 0 || c > 1) throw new Error(\"Tensor values for a float32 Tensor must be in the range [0 - 1] but got range [\" + l + \" - \" + c + \"].\");\n          } else {\n            if (\"int32\" !== n.dtype) throw new Error(\"Unsupported type for toPixels: \" + n.dtype + \". Please use float32 or int32 tensors.\");if (l < 0 || c > 255) throw new Error(\"Tensor values for a int32 Tensor must be in the range [0 - 255] but got range [\" + l + \" - \" + c + \"].\");\n          }return [4, n.data()];case 3:\n          for (p = S.sent(), d = \"float32\" === n.dtype ? 255 : 1, h = new Uint8ClampedArray(a * o * 4), f = 0; f < o * a; ++f) m = void 0, g = void 0, v = void 0, x = void 0, 1 === i ? (m = p[f] * d, g = p[f] * d, v = p[f] * d, x = 255) : 3 === i ? (m = p[3 * f] * d, g = p[3 * f + 1] * d, v = p[3 * f + 2] * d, x = 255) : 4 === i && (m = p[4 * f] * d, g = p[4 * f + 1] * d, v = p[4 * f + 2] * d, x = p[4 * f + 3] * d), h[(y = 4 * f) + 0] = Math.round(m), h[y + 1] = Math.round(g), h[y + 2] = Math.round(v), h[y + 3] = Math.round(x);return null != t && (t.width = a, t.height = o, T = t.getContext(\"2d\"), b = new ImageData(h, a, o), T.putImageData(b, 0, 0)), n !== e && n.dispose(), [2, h];}\n    });\n  });\n}function reshape_(e, t) {\n  var n = convertToTensor(e, \"x\", \"reshape\");t = inferFromImplicitShape(t, n.size), assert(n.size === sizeFromShape(t), \"new shape and old shape must have the same number of elements.\");return ENV.engine.runKernel(function (e) {\n    return e.reshape(n, t);\n  }, { $x: n }, function (e) {\n    return { $x: function () {\n        return e.reshape(n.shape);\n      } };\n  });\n}function squeeze_(e, t) {\n  var n = convertToTensor(e, \"x\", \"squeeze\");return reshape(n, squeezeShape(n.shape, t).newShape);\n}function cast_(e, t) {\n  var n = convertToTensor(e, \"x\", \"cast\");return ENV.engine.runKernel(function (e) {\n    return e.cast(n, t);\n  }, { $x: n }, function (e) {\n    return { $x: function () {\n        return e.clone();\n      } };\n  });\n}function tile_(e, t) {\n  var n = convertToTensor(e, \"x\", \"tile\");assert(n.rank === t.length, \"Error in transpose: rank of input \" + n.rank + \" must match length of reps \" + t + \".\");return ENV.engine.runKernel(function (e) {\n    return e.tile(n, t);\n  }, { $x: n }, function (e) {\n    return { $x: function () {\n        var r = zerosLike(n);if (1 === n.rank) for (var o = 0; o < t[0]; ++o) r = r.add(e.slice([o * n.shape[0]], [n.shape[0]]));else if (2 === n.rank) for (o = 0; o < t[0]; ++o) for (var a = 0; a < t[1]; ++a) r = r.add(e.slice([o * n.shape[0], a * n.shape[1]], [n.shape[0], n.shape[1]]));else if (3 === n.rank) for (o = 0; o < t[0]; ++o) for (a = 0; a < t[1]; ++a) for (var i = 0; i < t[2]; ++i) r = r.add(e.slice([o * n.shape[0], a * n.shape[1], i * n.shape[2]], [n.shape[0], n.shape[1], n.shape[2]]));else {\n          if (4 !== n.rank) throw new Error(\"Gradient for tile operation is not implemented for rank-\" + n.rank + \" tensors yet.\");for (o = 0; o < t[0]; ++o) for (a = 0; a < t[1]; ++a) for (i = 0; i < t[2]; ++i) for (var s = 0; s < t[3]; ++s) r = r.add(e.slice([o * n.shape[0], a * n.shape[1], i * n.shape[2], s * n.shape[3]], [n.shape[0], n.shape[1], n.shape[2], n.shape[3]]));\n        }return r;\n      } };\n  });\n}function pad1d_(e, t, n) {\n  return void 0 === n && (n = 0), assert(2 === t.length, \"Invalid number of paddings. Must be length of 2.\"), pad(e, [t], n);\n}function pad2d_(e, t, n) {\n  return void 0 === n && (n = 0), assert(2 === t.length && 2 === t[0].length && 2 === t[1].length, \"Invalid number of paddings. Must be length of 2 each.\"), pad(e, t, n);\n}function pad3d_(e, t, n) {\n  return void 0 === n && (n = 0), assert(3 === t.length && 2 === t[0].length && 2 === t[1].length && 2 === t[2].length, \"Invalid number of paddings. Must be length of 2 each.\"), pad(e, t, n);\n}function pad4d_(e, t, n) {\n  return void 0 === n && (n = 0), assert(4 === t.length && 2 === t[0].length && 2 === t[1].length && 2 === t[2].length && 2 === t[3].length, \"Invalid number of paddings. Must be length of 2 each.\"), pad(e, t, n);\n}function pad_(e, t, n) {\n  void 0 === n && (n = 0);var r = convertToTensor(e, \"x\", \"pad\");if (0 === r.rank) throw new Error(\"pad(scalar) is not defined. Pass non-scalar to pad\");var o = t.map(function (e) {\n    return e[0];\n  });return ENV.engine.runKernel(function (e) {\n    return e.pad(r, t, n);\n  }, { $x: r }, function (e) {\n    return { $x: function () {\n        return e.slice(o, r.shape);\n      } };\n  });\n}function stack_(e, t) {\n  void 0 === t && (t = 0);var n = convertToTensorArray(e, \"tensors\", \"stack\");if (assert(n.length >= 1, \"Pass at least one tensor to tf.stack\"), 1 === n.length) return n[0].expandDims(t);var r = n[0].rank,\n      o = n[0].shape,\n      a = n[0].dtype;assert(t <= r, \"Axis must be <= rank of the tensor\"), n.forEach(function (e) {\n    assertShapesMatch(o, e.shape, \"All tensors passed to stack must have matching shapes\");\n  }), n.forEach(function (e) {\n    assert(a === e.dtype, \"All tensors passed to stack must have matching dtypes\");\n  });var i = n.map(function (e) {\n    return e.expandDims(t);\n  });return concat(i, t);\n}function batchToSpaceND_(e, t, n) {\n  var r = convertToTensor(e, \"x\", \"batchToSpaceND\"),\n      o = t.reduce(function (e, t) {\n    return e * t;\n  });assert(r.rank >= 1 + t.length, \"input rank should be > than [blockShape] but got \" + r.rank), assert(n.length === t.length, \"crops.shape[0] must be equal to [blockShape] but got \" + n.length), assert(r.shape[0] % o == 0, \"input tensor batch must be divisible by prod( blockShape )\");return ENV.engine.runKernel(function (e) {\n    return e.batchToSpaceND(r, t, n);\n  }, { $x: r }, function (e) {\n    return { $x: function () {\n        return e.spaceToBatchND(t, n);\n      } };\n  });\n}function spaceToBatchND_(e, t, n) {\n  var r = convertToTensor(e, \"x\", \"spaceToBatchND\");assert(r.rank >= 1 + t.length, \"input rank \" + r.rank + \" should be > than [blockShape] \" + t.length), assert(n.length === t.length, \"paddings.shape[0] \" + n.length + \" must be equal to [blockShape] \" + t.length), assert(r.shape.reduce(function (e, r, o) {\n    return o > 0 && o <= t.length ? e && (r + n[o - 1][0] + n[o - 1][1]) % t[o - 1] == 0 : e;\n  }, !0), \"input spatial dimensions \" + r.shape.slice(1) + \" with paddings \" + n.toString() + \" must be divisible by blockShapes \" + t.toString());return ENV.engine.runKernel(function (e) {\n    return e.spaceToBatchND(r, t, n);\n  }, { $x: r }, function (e) {\n    return { $x: function () {\n        return e.batchToSpaceND(t, n);\n      } };\n  });\n}function unstack_(e, t) {\n  void 0 === t && (t = 0);for (var n, r = convertToTensor(e, \"x\", \"unstack\"), o = r.shape[t], a = Array(r.rank - 1).fill(0), i = 0, s = 0; s < r.rank; s++) s !== t && (a[i] = r.shape[s], i++);n = Array(o).fill(1);var u = Array(r.rank).fill(0),\n      l = r.shape.slice();return n.map(function (e) {\n    l[t] = e;var n = r.slice(u, l);return u[t] += e, n.reshape(a);\n  });\n}function cumsum_(e, t, n, r) {\n  void 0 === t && (t = 0), void 0 === n && (n = !1), void 0 === r && (r = !1);var o = convertToTensor(e, \"x\", \"cumsum\"),\n      a = getAxesPermutation([t |= 0], o.rank),\n      i = o;null != a && (i = o.transpose(a));var s = getInnerMostAxes(1, o.rank)[0],\n      u = ENV.engine.runKernel(function (e) {\n    return e.cumsum(i, s, n, r);\n  }, { permutedX: i }, function (e) {\n    return { permutedX: function () {\n        return e.cumsum(t, n, !r);\n      } };\n  });return null != a && (u = u.transpose(a)), u;\n}function expandDims_(e, t) {\n  void 0 === t && (t = 0);var n = convertToTensor(e, \"x\", \"expandDims\");assert(t <= n.rank, \"Axis must be <= rank of the tensor\");var r = n.shape.slice();return t < 0 && (assert(-(n.rank + 1) <= t, \"Axis must be in the interval [\" + -(n.rank + 1) + \", \" + n.rank + \"]\"), t = n.rank + t + 1), r.splice(t, 0, 1), reshape(n, r);\n}function depthToSpace_(e, t, n) {\n  void 0 === n && (n = \"NHWC\");var r = convertToTensor(e, \"x\", \"depthToSpace\"),\n      o = \"NHWC\" === n ? r.shape[1] : r.shape[2],\n      a = \"NHWC\" === n ? r.shape[2] : r.shape[3],\n      i = \"NHWC\" === n ? r.shape[3] : r.shape[1];return assert(o * t >= 0, \"Negative dimension size caused by overflow when multiplying\\n      \" + o + \" and \" + t + \"  for depthToSpace with input shape\\n      \" + r.shape), assert(a * t >= 0, \"Negative dimension size caused by overflow when multiplying\\n      \" + a + \" and \" + t + \" for depthToSpace with input shape\\n          \" + r.shape), assert(i % (t * t) == 0, \"Dimension size must be evenly divisible by \" + t * t + \" but is \" + i + \" for depthToSpace with input shape \" + r.shape), ENV.engine.runKernel(function (e) {\n    return e.depthToSpace(r, t, n);\n  }, { $x: r });\n}function buffer(e, t, n) {\n  return void 0 === t && (t = \"float32\"), new TensorBuffer(e, t, n);\n}function print(e, t) {\n  void 0 === t && (t = !1), console.log(e.toString(t));\n}var batchToSpaceND = op({ batchToSpaceND_: batchToSpaceND_ }),\n    cast = op({ cast_: cast_ }),\n    clone = op({ clone_: clone_ }),\n    cumsum = op({ cumsum_: cumsum_ }),\n    depthToSpace = op({ depthToSpace_: depthToSpace_ }),\n    expandDims = op({ expandDims_: expandDims_ }),\n    eye = op({ eye_: eye_ }),\n    fromPixels = op({ fromPixels_: fromPixels_ }),\n    multinomial = op({ multinomial_: multinomial_ }),\n    oneHot = op({ oneHot_: oneHot_ }),\n    pad = op({ pad_: pad_ }),\n    pad1d = op({ pad1d_: pad1d_ }),\n    pad2d = op({ pad2d_: pad2d_ }),\n    pad3d = op({ pad3d_: pad3d_ }),\n    pad4d = op({ pad4d_: pad4d_ }),\n    rand = op({ rand_: rand_ }),\n    randomNormal = op({ randomNormal_: randomNormal_ }),\n    randomUniform = op({ randomUniform_: randomUniform_ }),\n    reshape = op({ reshape_: reshape_ }),\n    spaceToBatchND = op({ spaceToBatchND_: spaceToBatchND_ }),\n    squeeze = op({ squeeze_: squeeze_ }),\n    stack = op({ stack_: stack_ }),\n    tile = op({ tile_: tile_ }),\n    truncatedNormal = op({ truncatedNormal_: truncatedNormal_ }),\n    unstack = op({ unstack_: unstack_ });function whereImpl(e, t) {\n  for (var n = [], r = 0; r < t.length; r++) t[r] && n.push(r);var o = buffer(e, \"int32\"),\n      a = buffer([n.length, e.length], \"int32\");for (r = 0; r < n.length; r++) {\n    var i = o.indexToLoc(n[r]),\n        s = r * e.length;a.values.set(i, s);\n  }return a.toTensor();\n}var BEFORE_PAGING_CONSTANT = 300,\n    SIZE_UPLOAD_UNIFORM = 32,\n    MathBackendWebGL = function () {\n  function e(e, t) {\n    if (void 0 === t && (t = !0), this.gpgpu = e, this.delayedStorage = t, this.texData = new WeakMap(), this.pendingRead = new WeakMap(), this.pendingDisposal = new WeakSet(), this.lruDataGPU = [], this.numBytesInGPU = 0, this.uploadWaitMs = 0, this.downloadWaitMs = 0, this.binaryCache = {}, this.disposed = !1, ENV.get(\"WEBGL_VERSION\") < 1) throw new Error(\"WebGL is not supported on this device\");ENV.get(\"IS_BROWSER\") && (this.canvas = document.createElement(\"canvas\")), null == e ? (this.gpgpu = new GPGPUContext(createWebGLContext(this.canvas)), this.gpgpuCreatedLocally = !0) : this.gpgpuCreatedLocally = !1, this.NUM_BYTES_BEFORE_PAGING = window.screen.height * window.screen.width * window.devicePixelRatio * BEFORE_PAGING_CONSTANT, this.textureManager = new TextureManager(this.gpgpu);\n  }return e.prototype.register = function (e, t, n) {\n    if (this.texData.has(e)) throw new Error(\"Data buffer is already registered\");this.texData.set(e, { shape: t, dtype: n, values: null, texture: null, complexTensors: null, texShape: null, usage: TextureUsage.RENDER });\n  }, e.prototype.fromPixels = function (e, t) {\n    if (null == e) throw new Error(\"pixels passed to tf.fromPixels() can not be null\");var n = [e.height, e.width],\n        r = [e.height, e.width, t];if (!(e instanceof HTMLVideoElement || e instanceof HTMLImageElement || e instanceof HTMLCanvasElement || e instanceof ImageData)) throw new Error(\"pixels passed to tf.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement or ImageData, but was \" + e.constructor.name);if (e instanceof HTMLVideoElement) {\n      if (null == this.fromPixelsCanvas) {\n        if (!ENV.get(\"IS_BROWSER\")) throw new Error(\"Can't read pixels from HTMLImageElement outside the browser.\");if (\"complete\" !== document.readyState) throw new Error(\"The DOM is not ready yet. Please call tf.fromPixels() once the DOM is ready. One way to do that is to add an event listener for `DOMContentLoaded` on the document object\");this.fromPixelsCanvas = document.createElement(\"canvas\");\n      }this.fromPixelsCanvas.width = e.width, this.fromPixelsCanvas.height = e.height, this.fromPixelsCanvas.getContext(\"2d\").drawImage(e, 0, 0, e.width, e.height), e = this.fromPixelsCanvas;\n    }var o = Tensor.make(n, {}, \"int32\");this.texData.get(o.dataId).usage = TextureUsage.PIXELS, this.gpgpu.uploadPixelDataToTexture(this.getTexture(o.dataId), e);var a = new FromPixelsProgram(r),\n        i = this.compileAndRun(a, [o]);return o.dispose(), i;\n  }, e.prototype.write = function (e, t) {\n    if (null == t) throw new Error(\"MathBackendWebGL.write(): values can not be null\");this.throwIfNoData(e);var n = this.texData.get(e),\n        r = n.texture,\n        o = n.texShape,\n        a = n.usage;if (\"complex64\" === n.dtype) throw new Error(\"Cannot write to a complex64 dtype. Please use tf.complex(real, imag).\");null != r && (this.releaseTexture(e, r, o, a), n.texture = null, n.texShape = null), n.usage = TextureUsage.UPLOAD, n.values = t, this.delayedStorage || this.uploadToGPU(e);\n  }, e.prototype.readSync = function (e) {\n    this.throwIfNoData(e);var t = this.texData.get(e),\n        n = t.shape,\n        r = t.texture,\n        o = t.values,\n        a = t.texShape,\n        i = t.dtype,\n        s = t.complexTensors;if (null != o) return this.cacheOnCPU(e), o;var u,\n        l,\n        c = null != this.activeTimers;(c && (u = performance.now()), \"complex64\" === i) ? l = mergeRealAndImagArrays(s.real.dataSync(), s.imag.dataSync()) : l = this.getValuesFromTexture(r, e, i, a, n);return c && (this.downloadWaitMs += performance.now() - u), this.cacheOnCPU(e, l), t.values;\n  }, e.prototype.read = function (e) {\n    return __awaiter(this, void 0, void 0, function () {\n      var t, n, r, o, a, i, s, u, l, c;return __generator(this, function (p) {\n        switch (p.label) {case 0:\n            if (this.pendingRead.has(e)) return t = this.pendingRead.get(e), [2, new Promise(function (e) {\n              return t.push(e);\n            })];if (this.throwIfNoData(e), n = this.texData.get(e), r = n.shape, o = n.texture, a = n.values, i = n.texShape, s = n.dtype, null != a) return this.cacheOnCPU(e), [2, a];if (this.pendingRead.set(e, []), !ENV.get(\"WEBGL_DOWNLOAD_FLOAT_ENABLED\") && 2 === ENV.get(\"WEBGL_VERSION\")) throw new Error(\"tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.\");return u = this.gpgpu.maybeCreateBufferFromTexture(o, i[0], i[1]), [4, this.gpgpu.createAndWaitForFence()];case 1:\n            return p.sent(), l = u instanceof WebGLTexture ? this.getValuesFromTexture(o, e, s, i, r) : this.gpgpu.downloadFloat32MatrixFromBuffer(u, i[0], i[1]), this.cacheOnCPU(e, l), c = this.pendingRead.get(e), this.pendingRead.delete(e), c.forEach(function (e) {\n              return e(l);\n            }), this.pendingDisposal.has(e) && (this.pendingDisposal.delete(e), this.disposeData(e)), [2, l];}\n      });\n    });\n  }, e.prototype.getValuesFromTexture = function (e, t, n, r, o) {\n    if (ENV.get(\"WEBGL_DOWNLOAD_FLOAT_ENABLED\")) return this.texData.get(t).usage === TextureUsage.PACK ? this.gpgpu.downloadMatrixFromPackedTexture(e, r[0], r[1]) : this.gpgpu.downloadFloat32MatrixFromOutputTexture(e, r[0], r[1]);var a = Tensor.make(o, {});this.texData.get(a.dataId).usage = TextureUsage.DOWNLOAD;var i = Tensor.make(o, { dataId: t }, n),\n        s = new EncodeFloatProgram(o);this.compileAndRun(s, [i], a, null, !1);var u = this.texData.get(a.dataId),\n        l = this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(u.texture, u.texShape[0], u.texShape[1]);return i.dispose(), a.dispose(), l;\n  }, e.prototype.time = function (e) {\n    return __awaiter(this, void 0, void 0, function () {\n      var t, n, r, o, a, i;return __generator(this, function (s) {\n        switch (s.label) {case 0:\n            return t = this.activeTimers, n = [], r = !1, null == this.programTimersStack ? (this.programTimersStack = n, r = !0) : this.activeTimers.push(n), this.activeTimers = n, e(), o = flatten(this.activeTimers), this.activeTimers = t, r && (this.programTimersStack = null), [4, Promise.all(o).then(function (e) {\n              var t = 0;return e.forEach(function (e) {\n                return t += e;\n              }), t;\n            })];case 1:\n            return a = s.sent(), i = { uploadWaitMs: this.uploadWaitMs, downloadWaitMs: this.downloadWaitMs, kernelMs: a, wallMs: null }, this.uploadWaitMs = 0, this.downloadWaitMs = 0, [2, i];}\n      });\n    });\n  }, e.prototype.memory = function () {\n    return { unreliable: !1, numBytesInGPU: this.numBytesInGPU };\n  }, e.prototype.startTimer = function () {\n    return ENV.get(\"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION\") > 0 ? this.gpgpu.beginQuery() : { startMs: performance.now(), endMs: null };\n  }, e.prototype.endTimer = function (e) {\n    return ENV.get(\"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION\") > 0 ? (this.gpgpu.endQuery(), e) : (e.endMs = performance.now(), e);\n  }, e.prototype.getQueryTime = function (e) {\n    return __awaiter(this, void 0, void 0, function () {\n      var t;return __generator(this, function (n) {\n        return ENV.get(\"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION\") > 0 ? [2, this.gpgpu.waitForQueryAndGetTime(e)] : [2, (t = e).endMs - t.startMs];\n      });\n    });\n  }, e.prototype.disposeData = function (e) {\n    if (!this.pendingDisposal.has(e)) if (this.pendingRead.has(e)) this.pendingDisposal.add(e);else if (this.texData.has(e)) {\n      var t = this.texData.get(e),\n          n = t.texture,\n          r = t.texShape,\n          o = t.usage,\n          a = t.complexTensors;null != n && this.releaseTexture(e, n, r, o), null != a && (a.real.dispose(), a.imag.dispose()), this.texData.delete(e);\n    }\n  }, e.prototype.getTexture = function (e) {\n    return this.uploadToGPU(e), this.texData.get(e).texture;\n  }, e.prototype.getGPGPUContext = function () {\n    return this.gpgpu;\n  }, e.prototype.getCanvas = function () {\n    return this.canvas;\n  }, e.prototype.complex = function (e, t) {\n    var n = Tensor.make(e.shape, {}, \"complex64\");return this.texData.get(n.dataId).complexTensors = { real: ENV.engine.keep(e.clone()), imag: ENV.engine.keep(t.clone()) }, n;\n  }, e.prototype.real = function (e) {\n    return this.texData.get(e.dataId).complexTensors.real.clone();\n  }, e.prototype.imag = function (e) {\n    return this.texData.get(e.dataId).complexTensors.imag.clone();\n  }, e.prototype.slice = function (e, t, n) {\n    var r = new SliceProgram(n),\n        o = r.getCustomSetupFunc(t);return this.compileAndRun(r, [e], null, o);\n  }, e.prototype.stridedSlice = function (e, t, n, r, o, a, i, s, u) {\n    var l = getStridedSlicedInfo(e.shape, t, n, r, o, a, i, s, u),\n        c = l[0],\n        p = l[1],\n        d = l[2],\n        h = p.filter(function (e, t) {\n      return -1 === d.indexOf(t);\n    });if (h.some(function (e) {\n      return 0 === e;\n    })) return tensor([], h);var f = new StridedSliceProgram(c, r, p, d);return this.compileAndRun(f, [e]);\n  }, e.prototype.reverse = function (e, t) {\n    var n = new ReverseProgram(e.shape, t);return this.compileAndRun(n, [e]);\n  }, e.prototype.concat2Tensors = function (e, t, n) {\n    var r = computeOutShape([e.shape, t.shape], n),\n        o = e.as2D(-1, sizeFromShape(e.shape.slice(n))),\n        a = t.as2D(-1, sizeFromShape(t.shape.slice(n))),\n        i = new ConcatProgram(o.shape, a.shape);return this.compileAndRun(i, [o, a]).reshape(r);\n  }, e.prototype.concat = function (e, t) {\n    if (1 === e.length) return e[0];for (var n = e[0], r = 1; r < e.length; ++r) n = this.concat2Tensors(n, e[r], t);return n;\n  }, e.prototype.neg = function (e) {\n    var t = new UnaryOpProgram(e.shape, NEG);return this.compileAndRun(t, [e]);\n  }, e.prototype.batchMatMul = function (e, t, n, r) {\n    var o = n ? e.shape[2] : e.shape[1],\n        a = r ? t.shape[1] : t.shape[2];if (ENV.get(\"WEBGL_RENDER_FLOAT32_ENABLED\") && 1 === e.shape[0] && 1 === t.shape[0] && arraysEqual(getTextureShapeFromLogicalShape(this.gpgpu.gl, [o, a]), [o, a])) {\n      var i = e.as2D(e.shape[1], e.shape[2]),\n          s = t.as2D(t.shape[1], t.shape[2]),\n          u = new PackProgram(i.shape),\n          l = Tensor.make(i.shape, {});this.texData.get(l.dataId).usage = TextureUsage.PACK;var c = this.compileAndRun(u, [i], l),\n          p = new PackProgram(s.shape),\n          d = Tensor.make(s.shape, {});this.texData.get(d.dataId).usage = TextureUsage.PACK;var h = this.compileAndRun(p, [s], d),\n          f = new MatMulPackedProgram(c.shape, h.shape, [o, a], n, r),\n          m = Tensor.make(f.outputShape, {});this.texData.get(m.dataId).usage = TextureUsage.PACK;var g = this.compileAndRun(f, [c, h], m),\n          v = new UnpackProgram(g.shape),\n          x = this.compileAndRun(v, [g]);return l.dispose(), d.dispose(), m.dispose(), x.reshape([1, g.shape[0], g.shape[1]]);\n    }return this.compileAndRun(new MatMulProgram(e.shape, t.shape, n, r), [e, t]);\n  }, e.prototype.multiply = function (e, t) {\n    if (\"complex64\" === e.dtype) {\n      var n = this.texData.get(e.dataId),\n          r = this.texData.get(t.dataId),\n          o = new BinaryOpComplexProgram(COMPLEX_MULTIPLY.REAL, e.shape, t.shape),\n          a = new BinaryOpComplexProgram(COMPLEX_MULTIPLY.IMAG, e.shape, t.shape),\n          i = [this.makeComplexComponentTensorHandle(e, n.complexTensors.real), this.makeComplexComponentTensorHandle(e, n.complexTensors.imag), this.makeComplexComponentTensorHandle(t, r.complexTensors.real), this.makeComplexComponentTensorHandle(t, r.complexTensors.imag)],\n          s = this.compileAndRun(o, i),\n          u = this.compileAndRun(a, i),\n          l = this.complex(s, u);return s.dispose(), u.dispose(), l;\n    }var c = new BinaryOpProgram(MUL, e.shape, t.shape),\n        p = this.makeOutputArray(c.outputShape, e.dtype);return this.compileAndRun(c, [e, t], p);\n  }, e.prototype.batchNormalization = function (e, t, n, r, o, a) {\n    var i = [e, t, n],\n        s = null;null != a && (s = a.shape, i.push(a));var u = null;null != o && (u = o.shape, i.push(o));var l = new BatchNormProgram(e.shape, t.shape, n.shape, s, u, r);return this.compileAndRun(l, i);\n  }, e.prototype.localResponseNormalization4D = function (e, t, n, r, o) {\n    var a = new LRNProgram(e.shape, t, n, r, o);return this.compileAndRun(a, [e]);\n  }, e.prototype.LRNGrad = function (e, t, n, r, o, a, i) {\n    var s = new LRNGradProgram(t.shape, r, o, a, i);return this.compileAndRun(s, [t, n, e]);\n  }, e.prototype.tile = function (e, t) {\n    var n = new TileProgram(e.shape, t);return this.compileAndRun(n, [e]);\n  }, e.prototype.pad = function (e, t, n) {\n    var r = new PadProgram(e.shape, t, n);return this.compileAndRun(r, [e]);\n  }, e.prototype.transpose = function (e, t) {\n    var n = new TransposeProgram(e.shape, t);return this.compileAndRun(n, [e]);\n  }, e.prototype.gather = function (e, t, n) {\n    var r = new GatherProgram(e.shape, t.size, n);return this.compileAndRun(r, [e, t]);\n  }, e.prototype.batchToSpaceND = function (e, t, n) {\n    assert(e.rank <= 4, \"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet\");var r = t.reduce(function (e, t) {\n      return e * t;\n    }),\n        o = getReshaped(e.shape, t, r),\n        a = getPermuted(o.length, t.length),\n        i = getReshapedPermuted(e.shape, t, r),\n        s = getSliceBeginCoords(n, t.length),\n        u = getSliceSize(i, n, t.length);return e.reshape(o).transpose(a).reshape(i).slice(s, u);\n  }, e.prototype.spaceToBatchND = function (e, t, n) {\n    assert(e.rank <= 4, \"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet\");var r = t.reduce(function (e, t) {\n      return e * t;\n    }),\n        o = [[0, 0]];o.push.apply(o, n);for (var a = 1 + t.length; a < e.shape.length; ++a) o.push([0, 0]);var i = e.pad(o),\n        s = getReshaped(i.shape, t, r, !1),\n        u = getPermuted(s.length, t.length, !1),\n        l = getReshapedPermuted(i.shape, t, r, !1);return i.reshape(s).transpose(u).reshape(l);\n  }, e.prototype.reduce = function (e, t, n) {\n    var r = e.shape[0],\n        o = e.shape[1],\n        a = computeOptimalWindowSize(o),\n        i = new ReduceProgram({ windowSize: a, inSize: o, batchSize: r }, t),\n        s = i.outputShape,\n        u = s[0],\n        l = s[1],\n        c = this.makeOutputArray([u, l], n);return this.compileAndRun(i, [e], c), 1 === c.shape[1] ? c : this.reduce(c, t, n);\n  }, e.prototype.argReduce = function (e, t, n) {\n    void 0 === n && (n = null);var r = e.shape[0],\n        o = e.shape[1];null != n && (r = n.shape[0], o = n.shape[1]);var a = computeOptimalWindowSize(o),\n        i = new ArgMinMaxProgram({ windowSize: a, inSize: o, batchSize: r }, t, null == n),\n        s = i.outputShape,\n        u = s[0],\n        l = s[1],\n        c = this.makeOutputArray([u, l], \"int32\"),\n        p = [e];return null != n && p.push(n), this.compileAndRun(i, p, c), 1 === c.shape[1] ? c : this.argReduce(e, t, c);\n  }, e.prototype.sum = function (e, t) {\n    assertAxesAreInnerMostDims(\"sum\", t, e.rank);var n = computeOutAndReduceShapes(e.shape, t),\n        r = n[0],\n        o = sizeFromShape(n[1]),\n        a = e.as2D(-1, o),\n        i = sumOutType(e.dtype);return this.reduce(a, \"sum\", i).reshape(r);\n  }, e.prototype.unsortedSegmentSum = function (e, t, n) {\n    var r = 0,\n        o = getAxesPermutation([r], e.rank),\n        a = e;null != o && (a = e.transpose(o), r = getInnerMostAxes(1, e.rank)[0]);var i = computeOutShape$1(a.shape, r, n),\n        s = sizeFromShape([a.shape[r]]),\n        u = a.as2D(-1, s),\n        l = sumOutType(e.dtype),\n        c = this.segOpCompute(u, \"unsortedSegmentSum\", t, l, n).reshape(i);return null != o && (c = c.transpose(getUndoAxesPermutation(o))), c;\n  }, e.prototype.segOpCompute = function (e, t, n, r, o) {\n    var a = e.shape[0],\n        i = e.shape[1],\n        s = segOpComputeOptimalWindowSize(i, o),\n        u = new SegmentOpProgram({ windowSize: s, inSize: i, batchSize: a, numSegments: o }, t),\n        l = u.outputShape,\n        c = l[0],\n        p = l[1],\n        d = this.makeOutputArray([c, p], r);return this.compileAndRun(u, [e, n], d), d.shape[1] === o ? d : (n = range(0, o).tile([i / s]), this.segOpCompute(d, t, n, r, o));\n  }, e.prototype.argMin = function (e, t) {\n    var n = [t];assertAxesAreInnerMostDims(\"argMin\", n, e.rank);var r = computeOutAndReduceShapes(e.shape, n),\n        o = r[0],\n        a = sizeFromShape(r[1]),\n        i = e.as2D(-1, a);return this.argReduce(i, \"min\").reshape(o);\n  }, e.prototype.argMax = function (e, t) {\n    var n = [t];assertAxesAreInnerMostDims(\"argMax\", n, e.rank);var r = computeOutAndReduceShapes(e.shape, n),\n        o = r[0],\n        a = sizeFromShape(r[1]),\n        i = e.as2D(-1, a);return this.argReduce(i, \"max\").reshape(o);\n  }, e.prototype.cumsum = function (e, t, n, r) {\n    if (t !== e.rank - 1) throw new Error(\"WebGL cumsum shader expects an inner-most axis=\" + (e.rank - 1) + \" but got axis=\" + t);var o = new CumSumProgram(e.shape, n, r);return this.compileAndRun(o, [e]);\n  }, e.prototype.equal = function (e, t) {\n    var n = new BinaryOpProgram(EQUAL, e.shape, t.shape),\n        r = this.makeOutputArray(n.outputShape, \"bool\");return this.compileAndRun(n, [e, t], r);\n  }, e.prototype.notEqual = function (e, t) {\n    var n = new BinaryOpProgram(NOT_EQUAL, e.shape, t.shape),\n        r = this.makeOutputArray(n.outputShape, \"bool\");return this.compileAndRun(n, [e, t], r);\n  }, e.prototype.less = function (e, t) {\n    var n = new BinaryOpProgram(LESS, e.shape, t.shape),\n        r = this.makeOutputArray(n.outputShape, \"bool\");return this.compileAndRun(n, [e, t], r);\n  }, e.prototype.lessEqual = function (e, t) {\n    var n = new BinaryOpProgram(LESS_EQUAL, e.shape, t.shape),\n        r = this.makeOutputArray(n.outputShape, \"bool\");return this.compileAndRun(n, [e, t], r);\n  }, e.prototype.greater = function (e, t) {\n    var n = new BinaryOpProgram(GREATER, e.shape, t.shape),\n        r = this.makeOutputArray(n.outputShape, \"bool\");return this.compileAndRun(n, [e, t], r);\n  }, e.prototype.greaterEqual = function (e, t) {\n    var n = new BinaryOpProgram(GREATER_EQUAL, e.shape, t.shape),\n        r = this.makeOutputArray(n.outputShape, \"bool\");return this.compileAndRun(n, [e, t], r);\n  }, e.prototype.logicalNot = function (e) {\n    var t = new UnaryOpProgram(e.shape, LOGICAL_NOT);return this.compileAndRun(t, [e]);\n  }, e.prototype.logicalAnd = function (e, t) {\n    var n = new BinaryOpProgram(LOGICAL_AND, e.shape, t.shape),\n        r = this.makeOutputArray(n.outputShape, \"bool\");return this.compileAndRun(n, [e, t], r);\n  }, e.prototype.logicalOr = function (e, t) {\n    var n = new BinaryOpProgram(LOGICAL_OR, e.shape, t.shape),\n        r = this.makeOutputArray(n.outputShape, \"bool\");return this.compileAndRun(n, [e, t], r);\n  }, e.prototype.select = function (e, t, n) {\n    var r = new SelectProgram(e.rank, t.shape, t.rank),\n        o = this.makeOutputArray(r.outputShape, upcastType(t.dtype, n.dtype));return this.compileAndRun(r, [e, t, n], o);\n  }, e.prototype.where = function (e) {\n    warn(\"tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead\");var t = e.dataSync();return whereImpl(e.shape, t);\n  }, e.prototype.topk = function (e, t, n) {\n    return topkImpl(e.dataSync(), e.shape, e.dtype, t, n);\n  }, e.prototype.min = function (e, t) {\n    assertAxesAreInnerMostDims(\"min\", t, e.rank);var n = computeOutAndReduceShapes(e.shape, t),\n        r = n[0],\n        o = sizeFromShape(n[1]),\n        a = e.as2D(-1, o);return this.reduce(a, \"min\", a.dtype).reshape(r);\n  }, e.prototype.minimum = function (e, t) {\n    var n = new BinaryOpProgram(MIN, e.shape, t.shape);return this.compileAndRun(n, [e, t]);\n  }, e.prototype.mod = function (e, t) {\n    var n = new BinaryOpProgram(MOD, e.shape, t.shape),\n        r = n.getCustomSetupFunc();return this.compileAndRun(n, [e, t], null, r);\n  }, e.prototype.max = function (e, t) {\n    assertAxesAreInnerMostDims(\"max\", t, e.rank);var n = computeOutAndReduceShapes(e.shape, t),\n        r = n[0],\n        o = sizeFromShape(n[1]),\n        a = e.as2D(-1, o);return this.reduce(a, \"max\", a.dtype).reshape(r);\n  }, e.prototype.maximum = function (e, t) {\n    var n = new BinaryOpProgram(MAX, e.shape, t.shape);return this.compileAndRun(n, [e, t]);\n  }, e.prototype.all = function (e, t) {\n    assertAxesAreInnerMostDims(\"all\", t, e.rank);var n = computeOutAndReduceShapes(e.shape, t),\n        r = n[0],\n        o = sizeFromShape(n[1]),\n        a = e.as2D(-1, o);return this.reduce(a, \"all\", a.dtype).reshape(r);\n  }, e.prototype.any = function (e, t) {\n    assertAxesAreInnerMostDims(\"any\", t, e.rank);var n = computeOutAndReduceShapes(e.shape, t),\n        r = n[0],\n        o = sizeFromShape(n[1]),\n        a = e.as2D(-1, o);return this.reduce(a, \"any\", a.dtype).reshape(r);\n  }, e.prototype.squaredDifference = function (e, t) {\n    var n = new BinaryOpProgram(SQUARED_DIFFERENCE, e.shape, t.shape);return this.compileAndRun(n, [e, t]);\n  }, e.prototype.realDivide = function (e, t) {\n    var n = new BinaryOpProgram(DIV, e.shape, t.shape),\n        r = this.makeOutputArray(n.outputShape, \"float32\");return this.compileAndRun(n, [e, t], r);\n  }, e.prototype.floorDiv = function (e, t) {\n    var n = new BinaryOpProgram(INT_DIV, e.shape, t.shape),\n        r = this.makeOutputArray(n.outputShape, \"int32\");return this.compileAndRun(n, [e, t], r);\n  }, e.prototype.add = function (e, t) {\n    if (\"complex64\" === e.dtype && \"complex64\" === t.dtype) return this.complexSeparableBinaryOp(e, t, ADD);var n = new BinaryOpProgram(ADD, e.shape, t.shape),\n        r = this.makeOutputArray(n.outputShape, upcastType(e.dtype, t.dtype));return this.compileAndRun(n, [e, t], r);\n  }, e.prototype.complexSeparableBinaryOp = function (e, t, n) {\n    var r = this,\n        o = this.texData.get(e.dataId),\n        a = this.texData.get(t.dataId),\n        i = [[o.complexTensors.real, a.complexTensors.real], [o.complexTensors.imag, a.complexTensors.imag]].map(function (o) {\n      var a = o[0],\n          i = o[1],\n          s = new BinaryOpProgram(n, e.shape, t.shape),\n          u = r.makeOutputArray(s.outputShape, upcastType(a.dtype, i.dtype)),\n          l = r.makeComplexComponentTensorHandle(e, a),\n          c = r.makeComplexComponentTensorHandle(t, i);return r.compileAndRun(s, [l, c], u);\n    }),\n        s = i[0],\n        u = i[1],\n        l = this.complex(s, u);return s.dispose(), u.dispose(), l;\n  }, e.prototype.makeComplexComponentTensorHandle = function (e, t) {\n    return { dataId: t.dataId, dtype: t.dtype, shape: e.shape };\n  }, e.prototype.addN = function (e) {\n    for (var t = e[0], n = 1; n < e.length; n++) t = this.add(t, e[n]);return t;\n  }, e.prototype.subtract = function (e, t) {\n    if (\"complex64\" === e.dtype && \"complex64\" === t.dtype) return this.complexSeparableBinaryOp(e, t, SUB);var n = new BinaryOpProgram(SUB, e.shape, t.shape),\n        r = this.makeOutputArray(n.outputShape, upcastType(e.dtype, t.dtype));return this.compileAndRun(n, [e, t], r);\n  }, e.prototype.pow = function (e, t) {\n    var n = new BinaryOpProgram(POW, e.shape, t.shape),\n        r = n.getCustomSetupFunc(),\n        o = this.makeOutputArray(n.outputShape, upcastType(e.dtype, t.dtype));return this.compileAndRun(n, [e, t], o, r);\n  }, e.prototype.ceil = function (e) {\n    var t = new UnaryOpProgram(e.shape, CEIL);return this.compileAndRun(t, [e]);\n  }, e.prototype.floor = function (e) {\n    var t = new UnaryOpProgram(e.shape, FLOOR);return this.compileAndRun(t, [e]);\n  }, e.prototype.sign = function (e) {\n    var t = new UnaryOpProgram(e.shape, SIGN);return this.compileAndRun(t, [e]);\n  }, e.prototype.round = function (e) {\n    var t = new UnaryOpProgram(e.shape, ROUND);return this.compileAndRun(t, [e]);\n  }, e.prototype.exp = function (e) {\n    var t = new UnaryOpProgram(e.shape, EXP);return this.compileAndRun(t, [e]);\n  }, e.prototype.expm1 = function (e) {\n    var t = new UnaryOpProgram(e.shape, EXPM1);return this.compileAndRun(t, [e]);\n  }, e.prototype.log = function (e) {\n    var t = new UnaryOpProgram(e.shape, LOG),\n        n = t.getCustomSetupFunc();return this.compileAndRun(t, [e], null, n);\n  }, e.prototype.log1p = function (e) {\n    var t = new UnaryOpProgram(e.shape, LOG1P);return this.compileAndRun(t, [e]);\n  }, e.prototype.sqrt = function (e) {\n    var t = new UnaryOpProgram(e.shape, SQRT);return this.compileAndRun(t, [e]);\n  }, e.prototype.rsqrt = function (e) {\n    var t = new UnaryOpProgram(e.shape, RSQRT);return this.compileAndRun(t, [e]);\n  }, e.prototype.square = function (e) {\n    var t = new UnaryOpProgram(e.shape, SQUARE);return this.compileAndRun(t, [e]);\n  }, e.prototype.reciprocal = function (e) {\n    var t = new UnaryOpProgram(e.shape, RECIPROCAL);return this.compileAndRun(t, [e]);\n  }, e.prototype.relu = function (e) {\n    var t = new UnaryOpProgram(e.shape, RELU);return this.compileAndRun(t, [e]);\n  }, e.prototype.elu = function (e) {\n    var t = new UnaryOpProgram(e.shape, ELU);return this.compileAndRun(t, [e]);\n  }, e.prototype.eluDer = function (e, t) {\n    var n = new BinaryOpProgram(ELU_DER, e.shape, t.shape);return this.compileAndRun(n, [e, t]);\n  }, e.prototype.selu = function (e) {\n    var t = new UnaryOpProgram(e.shape, SELU);return this.compileAndRun(t, [e]);\n  }, e.prototype.int = function (e) {\n    var t = new UnaryOpProgram(e.shape, TO_INT),\n        n = this.makeOutputArray(t.outputShape, \"int32\");return this.compileAndRun(t, [e], n);\n  }, e.prototype.clip = function (e, t, n) {\n    var r = new ClipProgram(e.shape, t, n);return this.compileAndRun(r, [e]);\n  }, e.prototype.abs = function (e) {\n    var t = new UnaryOpProgram(e.shape, ABS);return this.compileAndRun(t, [e]);\n  }, e.prototype.sigmoid = function (e) {\n    var t = new UnaryOpProgram(e.shape, SIGMOID);return this.compileAndRun(t, [e]);\n  }, e.prototype.softplus = function (e) {\n    var t = new UnaryOpProgram(e.shape, SOFTPLUS);return this.compileAndRun(t, [e]);\n  }, e.prototype.sin = function (e) {\n    var t = new UnaryOpProgram(e.shape, SIN);return this.compileAndRun(t, [e]);\n  }, e.prototype.cos = function (e) {\n    var t = new UnaryOpProgram(e.shape, COS);return this.compileAndRun(t, [e]);\n  }, e.prototype.tan = function (e) {\n    var t = new UnaryOpProgram(e.shape, TAN);return this.compileAndRun(t, [e]);\n  }, e.prototype.asin = function (e) {\n    var t = new UnaryOpProgram(e.shape, ASIN);return this.compileAndRun(t, [e]);\n  }, e.prototype.acos = function (e) {\n    var t = new UnaryOpProgram(e.shape, ACOS);return this.compileAndRun(t, [e]);\n  }, e.prototype.atan = function (e) {\n    var t = new UnaryOpProgram(e.shape, ATAN);return this.compileAndRun(t, [e]);\n  }, e.prototype.atan2 = function (e, t) {\n    var n = new BinaryOpProgram(ATAN2, e.shape, t.shape);return this.compileAndRun(n, [e, t]);\n  }, e.prototype.sinh = function (e) {\n    var t = new UnaryOpProgram(e.shape, SINH);return this.compileAndRun(t, [e]);\n  }, e.prototype.cosh = function (e) {\n    var t = new UnaryOpProgram(e.shape, COSH);return this.compileAndRun(t, [e]);\n  }, e.prototype.tanh = function (e) {\n    var t = new UnaryOpProgram(e.shape, TANH);return this.compileAndRun(t, [e]);\n  }, e.prototype.asinh = function (e) {\n    var t = new UnaryOpProgram(e.shape, ASINH);return this.compileAndRun(t, [e]);\n  }, e.prototype.acosh = function (e) {\n    var t = new UnaryOpProgram(e.shape, ACOSH),\n        n = t.getCustomSetupFunc();return this.compileAndRun(t, [e], null, n);\n  }, e.prototype.atanh = function (e) {\n    var t = new UnaryOpProgram(e.shape, ATANH),\n        n = t.getCustomSetupFunc();return this.compileAndRun(t, [e], null, n);\n  }, e.prototype.erf = function (e) {\n    var t = new UnaryOpProgram(e.shape, ERF);return this.compileAndRun(t, [e]);\n  }, e.prototype.step = function (e, t) {\n    var n = new UnaryOpProgram(e.shape, STEP(t));return this.compileAndRun(n, [e]);\n  }, e.prototype.conv2d = function (e, t, n) {\n    var r = new Conv2DProgram(n);return this.compileAndRun(r, [e, t]);\n  }, e.prototype.conv2dDerInput = function (e, t, n) {\n    var r = new Conv2DDerInputProgram(n);return this.compileAndRun(r, [e, t]);\n  }, e.prototype.conv2dDerFilter = function (e, t, n) {\n    var r = new Conv2DDerFilterProgram(n);return this.compileAndRun(r, [e, t]);\n  }, e.prototype.depthwiseConv2D = function (e, t, n) {\n    var r = new DepthwiseConv2DProgram(n);return this.compileAndRun(r, [e, t]);\n  }, e.prototype.depthwiseConv2DDerInput = function (e, t, n) {\n    var r = new DepthwiseConv2DDerInputProgram(n);return this.compileAndRun(r, [e, t]);\n  }, e.prototype.depthwiseConv2DDerFilter = function (e, t, n) {\n    var r = new DepthwiseConv2DDerFilterProgram(n);return this.compileAndRun(r, [e, t]);\n  }, e.prototype.maxPool = function (e, t) {\n    var n = new Pool2DProgram(t, \"max\", !1),\n        r = this.makeOutputArray(n.outputShape, e.dtype);return this.compileAndRun(n, [e], r);\n  }, e.prototype.avgPool = function (e, t) {\n    var n = new Pool2DProgram(t, \"avg\", !1),\n        r = this.makeOutputArray(n.outputShape, \"float32\");return this.compileAndRun(n, [e], r);\n  }, e.prototype.maxPoolBackprop = function (e, t, n, r) {\n    var o = new Pool2DProgram(r, \"max\", !0),\n        a = this.compileAndRun(o, [t]),\n        i = new MaxPool2DBackpropProgram(r),\n        s = this.makeOutputArray(i.outputShape, t.dtype),\n        u = this.compileAndRun(i, [e, a], s);return a.dispose(), u;\n  }, e.prototype.avgPoolBackprop = function (e, t, n) {\n    var r = new AvgPool2DBackpropProgram(n),\n        o = this.makeOutputArray(r.outputShape, t.dtype);return this.compileAndRun(r, [e], o);\n  }, e.prototype.cast = function (e, t) {\n    return castTensor(e, t, this);\n  }, e.prototype.reshape = function (e, t) {\n    return reshapeTensor(e, t);\n  }, e.prototype.resizeBilinear = function (e, t, n, r) {\n    var o = new ResizeBilinearProgram(e.shape, t, n, r);return this.compileAndRun(o, [e]);\n  }, e.prototype.resizeBilinearBackprop = function (e, t, n) {\n    var r = new ResizeBilinearBackpropProgram(e, t, n);return this.compileAndRun(r, [e]);\n  }, e.prototype.resizeNearestNeighbor = function (e, t, n, r) {\n    var o = new ResizeNearestNeighborProgram(e.shape, t, n, r);return this.compileAndRun(o, [e]);\n  }, e.prototype.resizeNearestNeighborBackprop = function (e, t, n) {\n    var r = new ResizeNearestNeigborBackpropProgram(e, t, n);return this.compileAndRun(r, [e]);\n  }, e.prototype.multinomial = function (e, t, n, r) {\n    var o = t ? e : softmax(e),\n        a = o.shape[0],\n        i = o.shape[1],\n        s = new MultinomialProgram(a, i, n),\n        u = this.makeOutputArray(s.outputShape, \"int32\"),\n        l = s.getCustomSetupFunc(r);return this.compileAndRun(s, [o], u, l);\n  }, e.prototype.oneHot = function (e, t, n, r) {\n    var o = new OneHotProgram(e.size, t, n, r);return this.compileAndRun(o, [e]);\n  }, e.prototype.nonMaxSuppression = function (e, t, n, r, o) {\n    return warn(\"tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead\"), nonMaxSuppressionImpl(e.dataSync(), t.dataSync(), n, r, o);\n  }, e.prototype.cropAndResize = function (e, t, n, r, o, a) {\n    var i = new CropAndResizeProgram(e.shape, t.shape, r, o, a);return this.compileAndRun(i, [e, t, n]);\n  }, e.prototype.depthToSpace = function (e, t, n) {\n    assert(t > 1, \"blockSize should be > 1 for depthToSpace, but was: \" + t);var r = e.shape[0],\n        o = (\"NHWC\" === n ? e.shape[1] : e.shape[2]) * t,\n        a = (\"NHWC\" === n ? e.shape[2] : e.shape[3]) * t,\n        i = (\"NHWC\" === n ? e.shape[3] : e.shape[1]) / (t * t),\n        s = new DepthToSpaceProgram(\"NHWC\" === n ? [r, o, a, i] : [r, i, o, a], t, n);return this.compileAndRun(s, [e]);\n  }, e.prototype.split = function (e, t, n) {\n    return split(e, t, n);\n  }, e.prototype.makeOutputArray = function (e, t) {\n    return Tensor.make(e, {}, t);\n  }, e.prototype.compileAndRun = function (e, t, n, r, o) {\n    var a = this;if (void 0 === o && (o = !0), null == n && (n = this.makeOutputArray(e.outputShape, t[0].dtype)), 0 === n.size) return this.texData.get(n.dataId).values = getTypedArrayFromDType(n.dtype, 0), n;var i = t.map(function (e) {\n      if (\"complex64\" === e.dtype) throw new Error(\"GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.\");var t = a.texData.get(e.dataId);return null == t.texture && sizeFromShape(e.shape) <= SIZE_UPLOAD_UNIFORM ? { shape: e.shape, texData: null, isUniform: !0, uniformValues: a.readSync(e.dataId) } : (a.uploadToGPU(e.dataId), { shape: e.shape, texData: t, isUniform: !1 });\n    });this.uploadToGPU(n.dataId);var s,\n        u = { shape: n.shape, texData: this.texData.get(n.dataId), isUniform: !1 },\n        l = makeShaderKey(e, i, u),\n        c = this.getAndSaveBinary(l, function () {\n      return compileProgram(a.gpgpu, e, i, u);\n    }),\n        p = null != this.activeTimers;if (p && (s = this.startTimer()), runProgram(c, i, u, r), o && this.numBytesInGPU > this.NUM_BYTES_BEFORE_PAGING) for (var d = this.numBytesInGPU - this.NUM_BYTES_BEFORE_PAGING; d > 0 && this.lruDataGPU.length > 0;) {\n      var h = this.lruDataGPU.shift(),\n          f = this.texData.get(h),\n          m = f.shape,\n          g = f.dtype;d -= this.computeBytes(m, g), this.read(h);\n    }return p && (s = this.endTimer(s), this.activeTimers.push(this.getQueryTime(s))), n;\n  }, e.prototype.getAndSaveBinary = function (e, t) {\n    return e in this.binaryCache || (this.binaryCache[e] = t()), this.binaryCache[e];\n  }, e.prototype.getTextureManager = function () {\n    return this.textureManager;\n  }, e.prototype.dispose = function () {\n    if (!this.disposed) {\n      for (var e in this.binaryCache) this.gpgpu.deleteProgram(this.binaryCache[e].webGLProgram);this.textureManager.dispose(), this.canvas.remove(), null != this.fromPixelsCanvas && this.fromPixelsCanvas.remove(), this.gpgpuCreatedLocally && this.gpgpu.dispose(), this.disposed = !0;\n    }\n  }, e.prototype.floatPrecision = function () {\n    var e = this;return tidy(function () {\n      return e.abs(scalar(1e-8)).get() > 0 ? 32 : 16;\n    });\n  }, e.prototype.throwIfNoData = function (e) {\n    if (!this.texData.has(e)) throw new Error(\"WebGL backend: No data found for this tensor. Did you change your backend in the middle of the program? New backends can't use Tensors created with previous backends\");\n  }, e.prototype.uploadToGPU = function (e) {\n    this.throwIfNoData(e);var t = this.texData.get(e),\n        n = t.shape,\n        r = t.values,\n        o = t.texture,\n        a = t.dtype,\n        i = t.usage;if (null == o) {\n      var s,\n          u = null != this.activeTimers;u && (s = performance.now());var l = getTextureShapeFromLogicalShape(this.gpgpu.gl, n);t.texShape = l;var c = this.acquireTexture(e, l, i);t.texture = c, null != r && (this.gpgpu.uploadMatrixToTexture(c, l[0], l[1], typedArrayToFloat32(r, a)), t.values = null, u && (this.uploadWaitMs += performance.now() - s));\n    } else {\n      this.lruDataGPU.indexOf(e) >= 0 && (this.lruDataGPU.splice(this.lruDataGPU.indexOf(e), 1), this.lruDataGPU.push(e));\n    }\n  }, e.prototype.cacheOnCPU = function (e, t) {\n    var n = this.delayedStorage,\n        r = this.texData.get(e),\n        o = r.texture,\n        a = r.texShape,\n        i = r.dtype,\n        s = r.usage;n && null != o && (this.releaseTexture(e, o, a, s), r.texture = null, r.texShape = null), r.usage = TextureUsage.UPLOAD, null != t && (r.values = float32ToTypedArray(t, i));\n  }, e.prototype.releaseTexture = function (e, t, n, r) {\n    var o = this.texData.get(e),\n        a = o.shape,\n        i = o.dtype,\n        s = this.lruDataGPU.indexOf(e);s >= 0 && this.lruDataGPU.splice(s, 1), this.numBytesInGPU -= this.computeBytes(a, i), this.textureManager.releaseTexture(t, n, r);\n  }, e.prototype.acquireTexture = function (e, t, n) {\n    var r = this.texData.get(e),\n        o = r.shape,\n        a = r.dtype;return this.lruDataGPU.push(e), this.numBytesInGPU += this.computeBytes(o, a), this.textureManager.acquireTexture(t, n);\n  }, e.prototype.computeBytes = function (e, t) {\n    return sizeFromShape(e) * bytesPerElement(t);\n  }, e;\n}();function float32ToTypedArray(e, t) {\n  if (\"float32\" === t || \"complex64\" === t) return e;if (\"int32\" === t || \"bool\" === t) {\n    for (var n = \"int32\" === t ? new Int32Array(e.length) : new Uint8Array(e.length), r = 0; r < n.length; ++r) n[r] = Math.round(e[r]);return n;\n  }throw new Error(\"Unknown dtype \" + t);\n}function typedArrayToFloat32(e, t) {\n  return e instanceof Float32Array ? e : new Float32Array(e);\n}function neg_(e) {\n  var t = convertToTensor(e, \"x\", \"neg\");return ENV.engine.runKernel(function (e) {\n    return e.neg(t);\n  }, { $x: t }, function (e) {\n    return { $x: function () {\n        return e.neg();\n      } };\n  });\n}function ceil_(e) {\n  var t = convertToTensor(e, \"x\", \"ceil\");return ENV.engine.runKernel(function (e) {\n    return e.ceil(t);\n  }, { $x: t }, function (e) {\n    return { $x: function () {\n        return zerosLike(e);\n      } };\n  });\n}function floor_(e) {\n  var t = convertToTensor(e, \"x\", \"floor\");return ENV.engine.runKernel(function (e) {\n    return e.floor(t);\n  }, { $x: t }, function (e) {\n    return { $x: function () {\n        return zerosLike(e);\n      } };\n  });\n}function sign_(e) {\n  var t = convertToTensor(e, \"x\", \"sign\");return ENV.engine.runKernel(function (e) {\n    return e.sign(t);\n  }, { $x: t }, function (e) {\n    return { $x: function () {\n        return zerosLike(e);\n      } };\n  });\n}function round_(e) {\n  var t = convertToTensor(e, \"x\", \"round\");return ENV.engine.runKernel(function (e) {\n    return e.round(t);\n  }, { $x: t }, function (e) {\n    return { $x: function () {\n        return zerosLike(e);\n      } };\n  });\n}function exp_(e) {\n  var t = convertToTensor(e, \"x\", \"exp\");return ENV.engine.runKernel(function (e, n) {\n    return n(e.exp(t));\n  }, { $x: t }, function (e, t) {\n    var n = t[0];return { $x: function () {\n        return e.mulStrict(n);\n      } };\n  });\n}function expm1_(e) {\n  var t = convertToTensor(e, \"x\", \"expm1\");return ENV.engine.runKernel(function (e) {\n    return e.expm1(t);\n  }, { $x: t }, function (e) {\n    return { $x: function () {\n        return e.mulStrict(t.exp());\n      } };\n  });\n}function log_(e) {\n  var t = convertToTensor(e, \"x\", \"log\");return ENV.engine.runKernel(function (e) {\n    return e.log(t);\n  }, { $x: t }, function (e) {\n    return { $x: function () {\n        return e.divStrict(t.toFloat());\n      } };\n  });\n}function log1p_(e) {\n  var t = convertToTensor(e, \"x\", \"log1p\");return ENV.engine.runKernel(function (e) {\n    return e.log1p(t);\n  }, { $x: t }, function (e) {\n    return { $x: function () {\n        return e.divStrict(t.add(scalar(1)));\n      } };\n  });\n}function sqrt_(e) {\n  var t = convertToTensor(e, \"x\", \"sqrt\");return ENV.engine.runKernel(function (e) {\n    return e.sqrt(t);\n  }, { $x: t }, function (e) {\n    return { $x: function () {\n        return e.divStrict(t.toFloat().sqrt().mul(scalar(2)));\n      } };\n  });\n}function rsqrt_(e) {\n  var t = convertToTensor(e, \"x\", \"rsqrt\");return ENV.engine.runKernel(function (e) {\n    return e.rsqrt(t);\n  }, { $x: t }, function (e) {\n    return { $x: function () {\n        return e.divStrict(t.pow(scalar(1.5)).mul(scalar(2))).neg();\n      } };\n  });\n}function square_(e) {\n  var t = convertToTensor(e, \"x\", \"square\");return ENV.engine.runKernel(function (e) {\n    return e.square(t);\n  }, { $x: t }, function (e) {\n    return { $x: function () {\n        return e.mulStrict(t.toFloat().mul(scalar(2)));\n      } };\n  });\n}function reciprocal_(e) {\n  var t = convertToTensor(e, \"x\", \"reciprocal\");return ENV.engine.runKernel(function (e) {\n    return e.reciprocal(t);\n  }, { $x: t }, function (e) {\n    return { $x: function () {\n        return e.divStrict(t.square().neg());\n      } };\n  });\n}function abs_(e) {\n  var t = convertToTensor(e, \"x\", \"abs\");return ENV.engine.runKernel(function (e) {\n    return e.abs(t);\n  }, { $x: t }, function (e) {\n    return { $x: function () {\n        return e.mulStrict(t.toFloat().step(-1));\n      } };\n  });\n}function clipByValue_(e, t, n) {\n  var r = convertToTensor(e, \"x\", \"clipByValue\");assert(t <= n, \"Error in clip: min (\" + t + \") must be less than or equal to max (\" + n + \").\");return ENV.engine.runKernel(function (e) {\n    return e.clip(r, t, n);\n  }, { $x: r }, function (e) {\n    return { $x: function () {\n        return e.where(r.greaterEqual(scalar(t)).logicalAnd(r.lessEqual(scalar(n))), zerosLike(e));\n      } };\n  });\n}function sigmoid_(e) {\n  var t = convertToTensor(e, \"x\", \"sigmoid\");return ENV.engine.runKernel(function (e, n) {\n    return n(e.sigmoid(t));\n  }, { $x: t }, function (e, t) {\n    var n = t[0];return { $x: function () {\n        return e.mulStrict(n.mul(scalar(1).sub(n)));\n      } };\n  });\n}function logSigmoid_(e) {\n  var t = convertToTensor(e, \"x\", \"logSigmoid\");return ENV.engine.runKernel(function (e) {\n    return e.softplus(t.neg()).neg();\n  }, { $x: t }, function (e) {\n    return { $x: function () {\n        return e.mulStrict(t.neg().sigmoid());\n      } };\n  });\n}function softplus_(e) {\n  var t = convertToTensor(e, \"x\", \"softplus\");return ENV.engine.runKernel(function (e) {\n    return e.softplus(t);\n  }, { $x: t }, function (e) {\n    return { $x: function () {\n        return e.mulStrict(t.sigmoid());\n      } };\n  });\n}function sin_(e) {\n  var t = convertToTensor(e, \"x\", \"sin\");return ENV.engine.runKernel(function (e) {\n    return e.sin(t);\n  }, { $x: t }, function (e) {\n    return { $x: function () {\n        return t.toFloat().cos().mulStrict(e);\n      } };\n  });\n}function cos_(e) {\n  var t = convertToTensor(e, \"x\", \"cos\");return ENV.engine.runKernel(function (e) {\n    return e.cos(t);\n  }, { $x: t }, function (e) {\n    return { $x: function () {\n        return t.toFloat().sin().neg().mulStrict(e);\n      } };\n  });\n}function tan_(e) {\n  var t = convertToTensor(e, \"x\", \"tan\");return ENV.engine.runKernel(function (e) {\n    return e.tan(t);\n  }, { $x: t }, function (e) {\n    return { $x: function () {\n        return e.divStrict(t.cos().square());\n      } };\n  });\n}function asin_(e) {\n  var t = convertToTensor(e, \"x\", \"asin\");return ENV.engine.runKernel(function (e) {\n    return e.asin(t);\n  }, { $x: t }, function (e) {\n    return { $x: function () {\n        return e.divStrict(scalar(1).sub(t.toFloat().square()).sqrt());\n      } };\n  });\n}function acos_(e) {\n  var t = convertToTensor(e, \"x\", \"acos\");return ENV.engine.runKernel(function (e) {\n    return e.acos(t);\n  }, { $x: t }, function (e) {\n    return { $x: function () {\n        return e.divStrict(scalar(1).sub(t.toFloat().square()).sqrt()).neg();\n      } };\n  });\n}function atan_(e) {\n  var t = convertToTensor(e, \"x\", \"atan\");return ENV.engine.runKernel(function (e) {\n    return e.atan(t);\n  }, { $x: t }, function (e) {\n    return { $x: function () {\n        return e.divStrict(scalar(1).add(t.toFloat().square()));\n      } };\n  });\n}function sinh_(e) {\n  var t = convertToTensor(e, \"x\", \"sinh\");return ENV.engine.runKernel(function (e) {\n    return e.sinh(t);\n  }, { $x: t }, function (e) {\n    return { $x: function () {\n        return t.toFloat().cosh().mulStrict(e);\n      } };\n  });\n}function cosh_(e) {\n  var t = convertToTensor(e, \"x\", \"cosh\");return ENV.engine.runKernel(function (e) {\n    return e.cosh(t);\n  }, { $x: t }, function (e) {\n    return { $x: function () {\n        return t.toFloat().sinh().mulStrict(e);\n      } };\n  });\n}function tanh_(e) {\n  var t = convertToTensor(e, \"x\", \"tanh\");return ENV.engine.runKernel(function (e, n) {\n    return n(e.tanh(t));\n  }, { $x: t }, function (e, t) {\n    var n = t[0];return { $x: function () {\n        return scalar(1).sub(n.square()).mulStrict(e);\n      } };\n  });\n}function asinh_(e) {\n  var t = convertToTensor(e, \"x\", \"asinh\");return ENV.engine.runKernel(function (e) {\n    return e.asinh(t);\n  }, { $x: t }, function (e) {\n    return { $x: function () {\n        return e.divStrict(scalar(1).add(t.toFloat().square()).sqrt());\n      } };\n  });\n}function acosh_(e) {\n  var t = convertToTensor(e, \"x\", \"acosh\");return ENV.engine.runKernel(function (e) {\n    return e.acosh(t);\n  }, { $x: t }, function (e) {\n    return { $x: function () {\n        return e.divStrict(t.toFloat().square().sub(scalar(1)).sqrt());\n      } };\n  });\n}function atanh_(e) {\n  var t = convertToTensor(e, \"x\", \"atanh\");return ENV.engine.runKernel(function (e) {\n    return e.atanh(t);\n  }, { $x: t }, function (e) {\n    return { $x: function () {\n        return e.divStrict(scalar(1).sub(t.toFloat().square()));\n      } };\n  });\n}function erf_(e) {\n  var t = convertToTensor(e, \"x\", \"erf\");assert(\"int32\" === t.dtype || \"float32\" === t.dtype, \"Input dtype must be `int32` or `float32`.\"), \"int32\" === t.dtype && (t = t.toFloat());return ENV.engine.runKernel(function (e) {\n    return e.erf(t);\n  }, { $x: t }, function (e) {\n    return { $x: function () {\n        return e.mulStrict(scalar(2 / Math.sqrt(Math.PI)).mul(t.square().neg().exp()));\n      } };\n  });\n}function step_(e, t) {\n  void 0 === t && (t = 0);var n = convertToTensor(e, \"x\", \"step\");return ENV.engine.runKernel(function (e) {\n    return e.step(n, t);\n  }, { $x: n }, function (e) {\n    return { $x: function () {\n        return zerosLike(e);\n      } };\n  });\n}ENV.get(\"IS_BROWSER\") && ENV.registerBackend(\"webgl\", function () {\n  return new MathBackendWebGL();\n}, 2, setTensorTracker);var abs = op({ abs_: abs_ }),\n    acos = op({ acos_: acos_ }),\n    acosh = op({ acosh_: acosh_ }),\n    asin = op({ asin_: asin_ }),\n    asinh = op({ asinh_: asinh_ }),\n    atan = op({ atan_: atan_ }),\n    atanh = op({ atanh_: atanh_ }),\n    ceil = op({ ceil_: ceil_ }),\n    clipByValue = op({ clipByValue_: clipByValue_ }),\n    cos = op({ cos_: cos_ }),\n    cosh = op({ cosh_: cosh_ }),\n    erf = op({ erf_: erf_ }),\n    exp = op({ exp_: exp_ }),\n    expm1 = op({ expm1_: expm1_ }),\n    floor = op({ floor_: floor_ }),\n    log$1 = op({ log_: log_ }),\n    log1p = op({ log1p_: log1p_ }),\n    logSigmoid = op({ logSigmoid_: logSigmoid_ }),\n    neg = op({ neg_: neg_ }),\n    reciprocal = op({ reciprocal_: reciprocal_ }),\n    round = op({ round_: round_ }),\n    rsqrt = op({ rsqrt_: rsqrt_ }),\n    sigmoid = op({ sigmoid_: sigmoid_ }),\n    sign = op({ sign_: sign_ }),\n    sin = op({ sin_: sin_ }),\n    sinh = op({ sinh_: sinh_ }),\n    softplus = op({ softplus_: softplus_ }),\n    sqrt = op({ sqrt_: sqrt_ }),\n    square = op({ square_: square_ }),\n    step = op({ step_: step_ }),\n    tan = op({ tan_: tan_ }),\n    tanh$1 = op({ tanh_: tanh_ });function batchNormalization2d_(e, t, n, r, o, a) {\n  void 0 === r && (r = .001);var i,\n      s,\n      u = convertToTensor(e, \"x\", \"batchNormalization\"),\n      l = convertToTensor(t, \"mean\", \"batchNormalization\"),\n      c = convertToTensor(n, \"variance\", \"batchNormalization\");return null != o && (i = convertToTensor(o, \"scale\", \"batchNormalization\")), null != a && (s = convertToTensor(a, \"offset\", \"batchNormalization\")), assert(2 === u.rank, \"Error in batchNormalization3D: x must be rank 3 but got rank \" + u.rank + \".\"), assert(2 === l.rank || 1 === l.rank, \"Error in batchNormalization2D: mean must be rank 2 or rank 1 but got rank \" + l.rank + \".\"), assert(2 === c.rank || 1 === c.rank, \"Error in batchNormalization2D: variance must be rank 2 or rank 1 but got rank \" + c.rank + \".\"), null != i && assert(2 === i.rank || 1 === i.rank, \"Error in batchNormalization2D: scale must be rank 2 or rank 1 but got rank \" + i.rank + \".\"), null != s && assert(2 === s.rank || 1 === s.rank, \"Error in batchNormalization2D: offset must be rank 2 or rank 1 but got rank \" + s.rank + \".\"), batchNormalization(u, l, c, r, i, s);\n}function batchNormalization3d_(e, t, n, r, o, a) {\n  void 0 === r && (r = .001);var i,\n      s,\n      u = convertToTensor(e, \"x\", \"batchNormalization\"),\n      l = convertToTensor(t, \"mean\", \"batchNormalization\"),\n      c = convertToTensor(n, \"variance\", \"batchNormalization\");return null != o && (i = convertToTensor(o, \"scale\", \"batchNormalization\")), null != a && (s = convertToTensor(a, \"offset\", \"batchNormalization\")), assert(3 === u.rank, \"Error in batchNormalization3D: x must be rank 3 but got rank \" + u.rank + \".\"), assert(3 === l.rank || 1 === l.rank, \"Error in batchNormalization3D: mean must be rank 3 or rank 1 but got rank \" + l.rank + \".\"), assert(3 === c.rank || 1 === c.rank, \"Error in batchNormalization3D: variance must be rank 3 or rank 1 but got rank \" + c.rank + \".\"), null != i && assert(3 === i.rank || 1 === i.rank, \"Error in batchNormalization3D: scale must be rank 3 or rank 1 but got rank \" + i.rank + \".\"), null != s && assert(3 === s.rank || 1 === s.rank, \"Error in batchNormalization3D: offset must be rank 3 or rank 1 but got rank \" + s.rank + \".\"), batchNormalization(u, l, c, r, i, s);\n}function batchNormalization4d_(e, t, n, r, o, a) {\n  void 0 === r && (r = .001);var i,\n      s,\n      u = convertToTensor(e, \"x\", \"batchNormalization\"),\n      l = convertToTensor(t, \"mean\", \"batchNormalization\"),\n      c = convertToTensor(n, \"variance\", \"batchNormalization\");return null != o && (i = convertToTensor(o, \"scale\", \"batchNormalization\")), null != a && (s = convertToTensor(a, \"offset\", \"batchNormalization\")), assert(4 === u.rank, \"Error in batchNormalization4D: x must be rank 4 but got rank \" + u.rank + \".\"), assert(4 === l.rank || 1 === l.rank, \"Error in batchNormalization4D: mean must be rank 4 or rank 1 but got rank \" + l.rank + \".\"), assert(4 === c.rank || 1 === c.rank, \"Error in batchNormalization4D: variance must be rank 4 or rank 1 but got rank \" + c.rank + \".\"), null != i && assert(4 === i.rank || 1 === i.rank, \"Error in batchNormalization4D: scale must be rank 4 or rank 1 but got rank \" + i.rank + \".\"), null != s && assert(4 === s.rank || 1 === s.rank, \"Error in batchNormalization4D: offset must be rank 4 or rank 1 but got rank \" + s.rank + \".\"), batchNormalization(u, l, c, r, i, s);\n}function batchNormalization_(e, t, n, r, o, a) {\n  void 0 === r && (r = .001);var i,\n      s,\n      u,\n      l = convertToTensor(e, \"x\", \"batchNormalization\"),\n      c = convertToTensor(t, \"mean\", \"batchNormalization\"),\n      p = convertToTensor(n, \"variance\", \"batchNormalization\");null != o && (i = convertToTensor(o, \"scale\", \"batchNormalization\")), null != a && (s = convertToTensor(a, \"offset\", \"batchNormalization\")), assert(c.rank === p.rank, \"Batch normalization gradient requires mean and variance to have equal ranks.\"), assert(null == s || c.rank === s.rank, \"Batch normalization gradient requires mean and offset to have equal ranks.\"), assert(null == i || c.rank === i.rank, \"Batch normalization gradient requires mean and scale to have equal ranks.\"), u = 0 === l.rank || 1 === l.rank ? l.as4D(1, 1, 1, l.size) : 2 === l.rank ? l.as4D(1, 1, l.shape[0], l.shape[1]) : 3 === l.rank ? l.as4D(1, l.shape[0], l.shape[1], l.shape[2]) : l;return ENV.engine.runKernel(function (e) {\n    return e.batchNormalization(u, batchnormReshape4D(c), batchnormReshape4D(p), r, batchnormReshape4D(i), batchnormReshape4D(s));\n  }, { $x: l, $mean: c, $variance: p, $scale: i, $offset: s }, function (e) {\n    var t = null == i ? scalar(1) : i,\n        n = getReductionAxes(c.shape, u.shape),\n        o = [];if (1 === c.rank) {\n      for (var a = 0; a < u.shape.length - 1; ++a) o.push(u.shape[a]);o.push(1);\n    }var s = l.sub(c),\n        d = e.mul(t),\n        h = rsqrt(p.add(scalar(r))),\n        f = h.mul(h).mul(h).mul(scalar(-.5));return { $x: function () {\n        return 1 === c.rank ? e.mul(tile(h.as4D(1, 1, 1, c.shape[0]), o)).mul(t).reshape(l.shape) : e.mul(h).mul(t).reshape(l.shape);\n      }, $mean: function () {\n        var e = h.mul(scalar(-1)).mul(d);return 1 === c.rank && (e = e.sum(n)), e.reshape(c.shape);\n      }, $variance: function () {\n        var e = f.mul(s).mul(d);return 1 === c.rank && (e = e.sum(n)), e.reshape(c.shape);\n      }, $scale: function () {\n        var t = s.mul(h),\n            r = e.mul(t);return 1 === c.rank && (r = r.sum(n)), r.reshape(c.shape);\n      }, $offset: function () {\n        var t = e;return 1 === c.rank && (t = t.sum(n)), t.reshape(c.shape);\n      } };\n  }).reshape(l.shape);\n}function batchnormReshape4D(e) {\n  return null == e ? null : 0 === e.rank ? e.as1D() : 1 === e.rank ? e : 2 === e.rank ? e.as4D(1, 1, e.shape[0], e.shape[1]) : 3 === e.rank ? e.as4D(1, e.shape[0], e.shape[1], e.shape[2]) : e;\n}var batchNormalization2d = op({ batchNormalization2d_: batchNormalization2d_ }),\n    batchNormalization3d = op({ batchNormalization3d_: batchNormalization3d_ }),\n    batchNormalization4d = op({ batchNormalization4d_: batchNormalization4d_ }),\n    batchNormalization = op({ batchNormalization_: batchNormalization_ });function computePool2DInfo(e, t, n, r, o, a) {\n  void 0 === a && (a = \"channelsLast\");var i,\n      s = parseTupleParam(t),\n      u = s[0],\n      l = s[1];if (\"channelsLast\" === a) i = [u, l, e[3], e[3]];else {\n    if (\"channelsFirst\" !== a) throw new Error(\"Unknown dataFormat \" + a);i = [u, l, e[1], e[1]];\n  }return computeConv2DInfo(e, i, n, 1, r, o, !1, a);\n}function computeConv2DInfo(e, t, n, r, o, a, i, s) {\n  void 0 === i && (i = !1), void 0 === s && (s = \"channelsLast\");var u = [-1, -1, -1, -1],\n      l = u[0],\n      c = u[1],\n      p = u[2],\n      d = u[3];if (\"channelsLast\" === s) l = e[0], c = e[1], p = e[2], d = e[3];else {\n    if (\"channelsFirst\" !== s) throw new Error(\"Unknown dataFormat \" + s);l = e[0], d = e[1], c = e[2], p = e[3];\n  }var h,\n      f = t[0],\n      m = t[1],\n      g = t[3],\n      v = parseTupleParam(n),\n      x = v[0],\n      y = v[1],\n      T = parseTupleParam(r),\n      b = T[0],\n      S = T[1],\n      E = getPadAndOutInfo(o, c, p, x, y, getEffectiveFilterSize(f, b), getEffectiveFilterSize(m, S), a),\n      w = E.padInfo,\n      C = E.outHeight,\n      A = E.outWidth,\n      _ = i ? g * d : g;return \"channelsFirst\" === s ? h = [l, _, C, A] : \"channelsLast\" === s && (h = [l, C, A, _]), { batchSize: l, dataFormat: s, inHeight: c, inWidth: p, inChannels: d, outHeight: C, outWidth: A, outChannels: _, padInfo: w, strideHeight: x, strideWidth: y, filterHeight: f, filterWidth: m, dilationHeight: b, dilationWidth: S, inShape: e, outShape: h, filterShape: t };\n}function computeOutputShape3D(e, t, n, r, o, a) {\n  null == o && (o = computeDefaultPad(e, t, r));var i = e[0],\n      s = e[1],\n      u = conditionalRound((i - t + 2 * o) / r + 1, a);assert(isInt(u), \"The output # of rows (\" + u + \") must be an integer. Change the stride and/or zero pad parameters\");var l = conditionalRound((s - t + 2 * o) / r + 1, a);return assert(isInt(l), \"The output # of columns (\" + l + \") must be an integer. Change the stride and/or zero pad parameters\"), [u, l, n];\n}function computeDefaultPad(e, t, n, r) {\n  void 0 === r && (r = 1);var o = getEffectiveFilterSize(t, r);return Math.floor((e[0] * (n - 1) - n + o) / 2);\n}function parseTupleParam(e) {\n  return \"number\" == typeof e ? [e, e] : e;\n}function getEffectiveFilterSize(e, t) {\n  return t <= 1 ? e : e + (e - 1) * (t - 1);\n}function getPadAndOutInfo(e, t, n, r, o, a, i, s) {\n  var u, l, c;if (\"number\" == typeof e) {\n    u = { top: e, bottom: e, left: e, right: e, type: 0 === e ? \"VALID\" : \"NUMBER\" };var p = computeOutputShape3D([t, n, 1], a, 1, r, e, s);l = p[0], c = p[1];\n  } else if (\"same\" === e) {\n    var d = ((l = Math.ceil(t / r)) - 1) * r + a - t,\n        h = ((c = Math.ceil(n / o)) - 1) * o + i - n,\n        f = Math.floor(d / 2),\n        m = d - f,\n        g = Math.floor(h / 2);u = { top: f, bottom: m, left: g, right: h - g, type: \"SAME\" };\n  } else {\n    if (\"valid\" !== e) throw Error(\"Unknown padding parameter: \" + e);u = { top: 0, bottom: 0, left: 0, right: 0, type: \"VALID\" }, l = Math.ceil((t - a + 1) / r), c = Math.ceil((n - i + 1) / o);\n  }return { padInfo: u, outHeight: l, outWidth: c };\n}function conditionalRound(e, t) {\n  if (!t) return e;switch (t) {case \"round\":\n      return Math.round(e);case \"ceil\":\n      return Math.ceil(e);case \"floor\":\n      return Math.floor(e);default:\n      throw new Error(\"Unknown roundingMode \" + t);}\n}function matMul_(e, t, n, r) {\n  void 0 === n && (n = !1), void 0 === r && (r = !1);var o = convertToTensor(e, \"a\", \"matMul\"),\n      a = convertToTensor(t, \"b\", \"matMul\"),\n      i = n ? o.shape[o.rank - 2] : o.shape[o.rank - 1],\n      s = r ? a.shape[a.rank - 1] : a.shape[a.rank - 2],\n      u = n ? o.shape[o.rank - 1] : o.shape[o.rank - 2],\n      l = r ? a.shape[a.rank - 2] : a.shape[a.rank - 1],\n      c = o.shape.slice(0, -2),\n      p = a.shape.slice(0, -2),\n      d = sizeFromShape(c),\n      h = sizeFromShape(p);assert(o.rank >= 2 && a.rank >= 2 && o.rank === a.rank, \"Error in matMul: inputs must have the same rank of at least 2, got ranks \" + o.rank + \" and \" + a.rank + \".\"), assert(arraysEqual(c, p), \"Error in matMul: outer dimensions (\" + c + \") and (\" + p + \") of Tensors with shapes \" + o.shape + \" and \" + a.shape + \" must match.\"), assert(i === s, \"Error in matMul: inner shapes (\" + i + \") and (\" + s + \") of Tensors with shapes \" + o.shape + \" and \" + a.shape + \" and transposeA=\" + n + \" and transposeB=\" + r + \" must match.\");var f = o.shape.slice(0, -2).concat([u, l]),\n      m = n ? o.as3D(d, i, u) : o.as3D(d, u, i),\n      g = r ? a.as3D(h, l, s) : a.as3D(h, s, l);return ENV.engine.runKernel(function (e) {\n    return e.batchMatMul(m, g, n, r);\n  }, { $a: m, $b: g }, function (e) {\n    return n || r ? !n && r ? { $a: function () {\n        return e.matMul(g.toFloat(), !1, !1);\n      }, $b: function () {\n        return e.matMul(m.toFloat(), !0, !1);\n      } } : n && !r ? { $a: function () {\n        return g.toFloat().matMul(e, !1, !0);\n      }, $b: function () {\n        return m.toFloat().matMul(e, !1, !1);\n      } } : { $a: function () {\n        return g.toFloat().matMul(e, !0, !0);\n      }, $b: function () {\n        return e.matMul(m.toFloat(), !0, !0);\n      } } : { $a: function () {\n        return e.matMul(g.toFloat(), !1, !0);\n      }, $b: function () {\n        return m.toFloat().matMul(e, !0, !1);\n      } };\n  }).reshape(f);\n}function outerProduct_(e, t) {\n  var n = convertToTensor(e, \"v1\", \"outerProduct\"),\n      r = convertToTensor(t, \"v2\", \"outerProduct\");return assert(1 === n.rank && 1 === r.rank, \"Error in outerProduct: inputs must be rank 1, but got ranks \" + n.rank + \" and \" + r.rank + \".\"), n.as2D(-1, 1).matMul(r.as2D(1, -1));\n}function dot_(e, t) {\n  var n = convertToTensor(e, \"t1\", \"dot\"),\n      r = convertToTensor(t, \"t2\", \"dot\");assert(!(1 !== n.rank && 2 !== n.rank || 1 !== r.rank && 2 !== r.rank), \"Error in dot: inputs must all be rank 1 or 2, but got ranks \" + n.rank + \" and \" + r.rank + \".\");var o = 1 === n.rank ? n.size : n.shape[1],\n      a = 1 === r.rank ? r.size : r.shape[0];return assert(o === a, \"Error in dot: inner dimensions of inputs must match, but got \" + o + \" and \" + a + \".\"), 1 === n.rank && 1 === r.rank ? n.as2D(1, -1).matMul(r.as2D(-1, 1)).asScalar() : 1 === n.rank && 2 === r.rank ? n.as2D(1, -1).matMul(r.as2D(r.shape[0], r.shape[1])).as1D() : 2 === n.rank && 1 === r.rank ? n.matMul(r.as2D(-1, 1)).as1D() : n.matMul(r.as2D(r.shape[0], r.shape[1]));\n}var matMul = op({ matMul_: matMul_ }),\n    dot = op({ dot_: dot_ }),\n    outerProduct = op({ outerProduct_: outerProduct_ });function conv1d_(e, t, n, r, o, a, i) {\n  void 0 === o && (o = \"NWC\"), void 0 === a && (a = 1);var s = convertToTensor(e, \"x\", \"conv1d\"),\n      u = convertToTensor(t, \"filter\", \"conv1d\"),\n      l = s,\n      c = !1;2 === s.rank && (c = !0, l = s.as3D(1, s.shape[0], s.shape[1])), assert(3 === l.rank, \"Error in conv1d: input must be rank 3, but got rank \" + l.rank + \".\"), assert(3 === u.rank, \"Error in conv1d: filter must be rank 3, but got rank \" + u.rank + \".\"), null != i && assert(isInt(r), \"Error in conv1d: pad must be an integer when using, dimRoundingMode \" + i + \" but got pad \" + r + \".\"), assert(l.shape[2] === u.shape[1], \"Error in conv1d: depth of input (\" + l.shape[2] + \") must match input depth for filter \" + u.shape[1] + \".\"), assert(eitherStridesOrDilationsAreOne(n, a), \"Error in conv1D: Either stride or dilation must be 1. Got stride \" + n + \" and dilation '\" + a + \"'\"), assert(\"NWC\" === o, \"Error in conv1d: got dataFormat of \" + o + \" but only NWC is currently supported.\");var p = u.as4D(1, u.shape[0], u.shape[1], u.shape[2]),\n      d = l.as4D(l.shape[0], 1, l.shape[1], l.shape[2]),\n      h = conv2d(d, p, [1, n], r, \"NHWC\", [1, a], i);return c ? h.as2D(h.shape[2], h.shape[3]) : h.as3D(h.shape[0], h.shape[2], h.shape[3]);\n}function conv2d_(e, t, n, r, o, a, i) {\n  void 0 === o && (o = \"NHWC\"), void 0 === a && (a = [1, 1]);var s = convertToTensor(e, \"x\", \"conv2d\"),\n      u = convertToTensor(t, \"filter\", \"conv2d\"),\n      l = s,\n      c = !1;3 === s.rank && (c = !0, l = s.as4D(1, s.shape[0], s.shape[1], s.shape[2])), assert(4 === l.rank, \"Error in conv2d: input must be rank 4, but got rank \" + l.rank + \".\"), assert(4 === u.rank, \"Error in conv2d: filter must be rank 4, but got rank \" + u.rank + \".\"), null != i && assert(isInt(r), \"Error in conv2d: pad must be an integer when using, dimRoundingMode \" + i + \" but got pad \" + r + \".\"), assert(l.shape[3] === u.shape[2], \"Error in conv2d: depth of input (\" + l.shape[3] + \") must match input depth for filter \" + u.shape[2] + \".\"), assert(eitherStridesOrDilationsAreOne(n, a), \"Error in conv2D: Either strides or dilations must be 1. Got strides \" + n + \" and dilations '\" + a + \"'\"), assert(\"NHWC\" === o, \"Error in conv2d: got dataFormat of \" + o + \" but only NHWC is currently supported.\");var p,\n      d = computeConv2DInfo(l.shape, u.shape, n, a, r, i);if (1 === d.filterHeight && 1 === d.filterWidth && 1 === d.dilationHeight && 1 === d.dilationWidth && 1 === d.strideHeight && 1 === d.strideWidth && \"SAME\" === d.padInfo.type) {\n    var h = l.reshape([-1, d.inChannels]),\n        f = u.reshape([d.inChannels, d.outChannels]);p = matMul(h, f).reshape(d.outShape);\n  } else {\n    p = ENV.engine.runKernel(function (e) {\n      return e.conv2d(l, u, d);\n    }, { x: l, $filter: u }, function (e) {\n      return assert(tupleValuesAreOne(a), \"Error in gradient of conv2D: dilation rates greater than 1 are notyet supported in gradients. Got dilations '\" + a + \"'\"), { x: function () {\n          return conv2dDerInput_(l.shape, e, u, n, r);\n        }, $filter: function () {\n          return conv2dDerFilter_(l, e, u.shape, n, r);\n        } };\n    });\n  }return c ? p.as3D(p.shape[1], p.shape[2], p.shape[3]) : p;\n}function conv2dDerInput_(e, t, n, r, o, a) {\n  assert(e.length === t.rank, \"Length of inShape (\" + e.length + \") and rank of dy (\" + t.rank + \") must match\");var i = e,\n      s = t,\n      u = !1;3 === t.rank && (u = !0, s = t.as4D(1, t.shape[0], t.shape[1], t.shape[2]), i = [1, e[0], e[1], e[2]]);var l = i[3],\n      c = s.shape[3];assert(4 === i.length, \"Error in conv2dDerInput: inShape must be length 4, but got length \" + i.length + \".\"), assert(4 === s.rank, \"Error in conv2dDerInput: dy must be rank 4, but got rank \" + s.rank), assert(4 === n.rank, \"Error in conv2dDerInput: filter must be rank 4, but got rank \" + n.rank), assert(l === n.shape[2], \"Error in conv2dDerInput: depth of input (\" + l + \") must match input depth for filter \" + n.shape[2] + \".\"), assert(c === n.shape[3], \"Error in conv2dDerInput: depth of output (\" + c + \") must match output depth for filter \" + n.shape[3] + \".\"), null != a && assert(isInt(o), \"Error in conv2dDerInput: pad must be an integer when using, dimRoundingMode \" + a + \" but got pad \" + o + \".\");var p = computeConv2DInfo(i, n.shape, r, 1, o, a),\n      d = ENV.engine.runKernel(function (e) {\n    return e.conv2dDerInput(s, n, p);\n  }, { dy4D: s });return u ? d.as3D(d.shape[1], d.shape[2], d.shape[3]) : d;\n}function conv2dDerFilter_(e, t, n, r, o, a) {\n  var i = e;3 === e.rank && (i = e.as4D(1, e.shape[0], e.shape[1], e.shape[2]));var s = t;3 === s.rank && (s = t.as4D(1, t.shape[0], t.shape[1], t.shape[2])), assert(4 === i.rank, \"Error in conv2dDerFilter: input must be rank 4, but got shape \" + i.shape + \".\"), assert(4 === s.rank, \"Error in conv2dDerFilter: dy must be rank 4, but got shape \" + s.shape + \".\"), assert(4 === n.length, \"Error in conv2dDerFilter: filterShape must be length 4, but got \" + n + \".\"), assert(i.shape[3] === n[2], \"Error in conv2dDerFilter: depth of input \" + i.shape[3] + \") must match input depth in filter (\" + n[2] + \".\"), assert(s.shape[3] === n[3], \"Error in conv2dDerFilter: depth of dy (\" + s.shape[3] + \") must match output depth for filter (\" + n[3] + \").\"), null != a && assert(isInt(o), \"Error in conv2dDerFilter: pad must be an integer when using, dimRoundingMode \" + a + \" but got pad \" + o + \".\");var u = computeConv2DInfo(i.shape, n, r, 1, o, a);return ENV.engine.runKernel(function (e) {\n    return e.conv2dDerFilter(i, s, u);\n  }, { x4D: i, dy4D: s });\n}function conv2dTranspose_(e, t, n, r, o, a) {\n  return conv2dDerInput_(n, convertToTensor(e, \"x\", \"conv2dTranspose\"), convertToTensor(t, \"filter\", \"conv2dTranspose\"), r, o, a);\n}function depthwiseConv2d_(e, t, n, r, o, a, i) {\n  void 0 === o && (o = \"NHWC\"), void 0 === a && (a = [1, 1]);var s = convertToTensor(e, \"x\", \"depthwiseConv2d\"),\n      u = convertToTensor(t, \"filter\", \"depthwiseConv2d\"),\n      l = s,\n      c = !1;3 === s.rank && (c = !0, l = s.as4D(1, s.shape[0], s.shape[1], s.shape[2])), assert(4 === l.rank, \"Error in depthwiseConv2d: input must be rank 4, but got rank \" + l.rank + \".\"), assert(4 === u.rank, \"Error in depthwiseConv2d: filter must be rank 4, but got rank \" + u.rank + \".\"), assert(l.shape[3] === u.shape[2], \"Error in depthwiseConv2d: number of input channels (\" + l.shape[3] + \") must match the inChannels dimension in filter \" + u.shape[2] + \".\"), null == a && (a = [1, 1]), assert(eitherStridesOrDilationsAreOne(n, a), \"Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides \" + n + \" and dilations '\" + a + \"'\"), null != i && assert(isInt(r), \"Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode \" + i + \" but got pad \" + r + \".\");var p = computeConv2DInfo(l.shape, u.shape, n, a, r, i, !0),\n      d = ENV.engine.runKernel(function (e) {\n    return e.depthwiseConv2D(l, u, p);\n  }, { x: l, $filter: u }, function (e) {\n    return assert(tupleValuesAreOne(a), \"Error in gradient of depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '\" + a + \"'\"), { x: function () {\n        return depthwiseConv2dDerInput(l.shape, e, u, p);\n      }, $filter: function () {\n        return depthwiseConv2dDerFilter(l, e, u.shape, p);\n      } };\n  });return c ? d.as3D(d.shape[1], d.shape[2], d.shape[3]) : d;\n}function separableConv2d_(e, t, n, r, o, a, i) {\n  void 0 === a && (a = [1, 1]), void 0 === i && (i = \"NHWC\");var s = convertToTensor(e, \"x\", \"separableConv2d\"),\n      u = convertToTensor(t, \"depthwiseFilter\", \"separableConv2d\"),\n      l = convertToTensor(n, \"pointwiseFilter\", \"separableConv2d\"),\n      c = s,\n      p = !1;if (3 === s.rank && (p = !0, c = s.as4D(1, s.shape[0], s.shape[1], s.shape[2])), \"NCHW\" === i) throw new Error(\"separableConv2d currently does not support dataFormat NCHW; only NHWC is supported\");assert(4 === c.rank, \"Error in separableConv2d: input must be rank 4, but got rank \" + c.rank + \".\"), assert(4 === u.rank, \"Error in separableConv2d: depthwise filter must be rank 4, but got rank \" + u.rank + \".\"), assert(4 === l.rank, \"Error in separableConv2d: pointwise filter must be rank 4, but got rank \" + u.rank + \".\"), assert(1 === l.shape[0], \"Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got \" + l.shape[0] + \".\"), assert(1 === l.shape[1], \"Error in separableConv2d: the second dimension of pointwise filter  must be 1, but got \" + l.shape[1] + \".\");var d = u.shape[2],\n      h = u.shape[3];assert(l.shape[2] === d * h, \"Error in separableConv2d: the third dimension of pointwise filter must be \" + d * h + \", but got \" + l.shape[2] + \".\");var f = depthwiseConv2d(c, u, r, o, i, a),\n      m = conv2d(f, l, 1, \"valid\", i);return p ? m.as3D(m.shape[1], m.shape[2], m.shape[3]) : m;\n}function parseTupleParam$1(e) {\n  return \"number\" == typeof e ? [e, e] : e;\n}function tupleValuesAreOne(e) {\n  var t = parseTupleParam$1(e),\n      n = t[0],\n      r = t[1];return 1 === n && 1 === r;\n}function eitherStridesOrDilationsAreOne(e, t) {\n  return tupleValuesAreOne(e) || tupleValuesAreOne(t);\n}function depthwiseConv2dDerInput(e, t, n, r) {\n  var o = t,\n      a = !1;3 === t.rank && (a = !0, o = t.as4D(1, t.shape[0], t.shape[1], t.shape[2]));var i = ENV.engine.runKernel(function (e) {\n    return e.depthwiseConv2DDerInput(o, n, r);\n  }, { dy4D: o });return a ? i.as3D(i.shape[1], i.shape[2], i.shape[3]) : i;\n}function depthwiseConv2dDerFilter(e, t, n, r) {\n  var o = e;3 === e.rank && (o = e.as4D(1, e.shape[0], e.shape[1], e.shape[2]));var a = t;return 3 === a.rank && (a = t.as4D(1, t.shape[0], t.shape[1], t.shape[2])), ENV.engine.runKernel(function (e) {\n    return e.depthwiseConv2DDerFilter(o, a, r);\n  }, { x4D: o, dy4D: a });\n}var conv1d = op({ conv1d_: conv1d_ }),\n    conv2d = op({ conv2d_: conv2d_ }),\n    depthwiseConv2d = op({ depthwiseConv2d_: depthwiseConv2d_ }),\n    separableConv2d = op({ separableConv2d_: separableConv2d_ }),\n    conv2dTranspose = op({ conv2dTranspose_: conv2dTranspose_ });function reverse1d_(e) {\n  var t = convertToTensor(e, \"x\", \"reverse\");return assert(1 === t.rank, \"Error in reverse1D: x must be rank 1 but got\\n             rank \" + t.rank + \".\"), reverse(t, 0);\n}function reverse2d_(e, t) {\n  var n = convertToTensor(e, \"x\", \"reverse\");return assert(2 === n.rank, \"Error in reverse2D: x must be rank 2 but got\\n             rank \" + n.rank + \".\"), reverse(n, t);\n}function reverse3d_(e, t) {\n  var n = convertToTensor(e, \"x\", \"reverse\");return assert(3 === n.rank, \"Error in reverse3D: x must be rank 3 but got\\n             rank \" + n.rank + \".\"), reverse(n, t);\n}function reverse4d_(e, t) {\n  var n = convertToTensor(e, \"x\", \"reverse\");return assert(4 === n.rank, \"Error in reverse4D: x must be rank 4 but got\\n             rank \" + n.rank + \".\"), reverse(n, t);\n}function reverse_(e, t) {\n  var n = convertToTensor(e, \"x\", \"reverse\");if (0 === n.rank) return n.clone();var r = parseAxisParam(t, n.shape);return ENV.engine.runKernel(function (e) {\n    return e.reverse(n, r);\n  }, { $x: n }, function (e) {\n    return { $x: function () {\n        return e.reverse(r);\n      } };\n  }).reshapeAs(n);\n}var reverse = op({ reverse_: reverse_ }),\n    reverse1d = op({ reverse1d_: reverse1d_ }),\n    reverse2d = op({ reverse2d_: reverse2d_ }),\n    reverse3d = op({ reverse3d_: reverse3d_ }),\n    reverse4d = op({ reverse4d_: reverse4d_ });function maxPool_(e, t, n, r, o) {\n  var a = convertToTensor(e, \"x\", \"maxPool\"),\n      i = a,\n      s = !1;3 === a.rank && (s = !0, i = a.as4D(1, a.shape[0], a.shape[1], a.shape[2])), assert(4 === i.rank, \"Error in maxPool: input must be rank 4 but got rank \" + i.rank + \".\"), null != o && assert(isInt(r), \"Error in maxPool: pad must be an integer when using, dimRoundingMode \" + o + \" but got pad \" + r + \".\");var u = computePool2DInfo(i.shape, t, n, r, o),\n      l = ENV.engine.runKernel(function (e, t) {\n    return t(e.maxPool(i, u));\n  }, { x: i }, function (e, o) {\n    var a = o[0];return { x: function () {\n        return maxPoolBackprop(e, i, a, t, n, r);\n      } };\n  });return s ? l.as3D(l.shape[1], l.shape[2], l.shape[3]) : l;\n}function avgPool_(e, t, n, r, o) {\n  var a = convertToTensor(e, \"x\", \"avgPool\");assert(\"float32\" === a.dtype, \"The input dtype to avgPool must be float32\");var i = a,\n      s = !1;3 === a.rank && (s = !0, i = a.as4D(1, a.shape[0], a.shape[1], a.shape[2])), assert(4 === i.rank, \"Error in avgPool: x must be rank 4 but got rank \" + i.rank + \".\"), null != o && assert(isInt(r), \"Error in avgPool: pad must be an integer when using, dimRoundingMode \" + o + \" but got pad \" + r + \".\");var u = computePool2DInfo(i.shape, t, n, r),\n      l = ENV.engine.runKernel(function (e) {\n    return e.avgPool(i, u);\n  }, { x: i }, function (e) {\n    return { x: function () {\n        return avgPoolBackprop(e, i, t, n, r);\n      } };\n  });return l = l.cast(a.dtype), s ? l.as3D(l.shape[1], l.shape[2], l.shape[3]) : l;\n}function maxPoolBackprop(e, t, n, r, o, a, i) {\n  var s = convertToTensor(e, \"dy\", \"maxPoolBackprop\"),\n      u = convertToTensor(t, \"input\", \"maxPoolBackprop\"),\n      l = convertToTensor(n, \"output\", \"maxPoolBackprop\");assert(u.rank === s.rank, \"Rank of input (\" + u.rank + \") does not match rank of dy (\" + s.rank + \")\"), assert(4 === s.rank, \"Error in maxPoolBackprop: dy must be rank 4 but got rank \" + s.rank + \".\"), assert(4 === u.rank, \"Error in maxPoolBackprop: input must be rank 4 but got rank \" + u.rank + \".\"), null != i && assert(isInt(a), \"Error in maxPoolBackprop: pad must be an integer when using, dimRoundingMode \" + i + \" but got pad \" + a + \".\");var c = computePool2DInfo(u.shape, r, o, a, i);return ENV.engine.runKernel(function (e) {\n    return e.maxPoolBackprop(s, u, l, c);\n  }, { $dy: s, $input: u });\n}function avgPoolBackprop(e, t, n, r, o) {\n  var a = convertToTensor(e, \"dy\", \"avgPoolBackprop\"),\n      i = convertToTensor(t, \"input\", \"avgPoolBackprop\");assert(i.rank === a.rank, \"Rank of input (\" + i.rank + \") does not match rank of dy (\" + a.rank + \")\");var s = i,\n      u = a,\n      l = !1;3 === i.rank && (l = !0, s = i.as4D(1, i.shape[0], i.shape[1], i.shape[2]), u = a.as4D(1, a.shape[0], a.shape[1], a.shape[2])), assert(4 === u.rank, \"Error in avgPoolBackprop: dy must be rank 4 but got rank \" + u.rank + \".\"), assert(4 === s.rank, \"Error in avgPoolBackprop: input must be rank 4 but got rank \" + s.rank + \".\");var c = computePool2DInfo(s.shape, n, r, o),\n      p = ENV.engine.runKernel(function (e) {\n    return e.avgPoolBackprop(u, s, c);\n  }, { dy4D: u, input4D: s });return l ? p.as3D(p.shape[1], p.shape[2], p.shape[3]) : p;\n}var maxPool = op({ maxPool_: maxPool_ }),\n    avgPool = op({ avgPool_: avgPool_ });function slice1d_(e, t, n) {\n  var r = convertToTensor(e, \"x\", \"slice1d\");return assert(1 === r.rank, \"slice1d expects a rank-1 tensor, but got a rank-\" + r.rank + \" tensor\"), slice(r, [t], [n]);\n}function slice2d_(e, t, n) {\n  var r = convertToTensor(e, \"x\", \"slice2d\");return assert(2 === r.rank, \"slice1d expects a rank-2 tensor, but got a rank-\" + r.rank + \" tensor\"), slice(r, t, n);\n}function slice3d_(e, t, n) {\n  var r = convertToTensor(e, \"x\", \"slice3d\");return assert(3 === r.rank, \"slice1d expects a rank-3 tensor, but got a rank-\" + r.rank + \" tensor\"), slice(r, t, n);\n}function slice4d_(e, t, n) {\n  var r = convertToTensor(e, \"x\", \"slice4d\");return assert(4 === r.rank, \"slice1d expects a rank-4 tensor, but got a rank-\" + r.rank + \" tensor\"), slice(r, t, n);\n}function slice_(e, t, n) {\n  var r,\n      o,\n      a = convertToTensor(e, \"x\", \"slice\");if (0 === a.rank) throw new Error(\"Slicing scalar is not possible\");r = \"number\" == typeof t ? [t].concat(new Array(a.rank - 1).fill(0)) : t.length < a.rank ? t.concat(new Array(a.rank - t.length).fill(0)) : t.slice(), o = (o = null == n ? new Array(a.rank).fill(-1) : \"number\" == typeof n ? [n].concat(new Array(a.rank - 1).fill(-1)) : n.length < a.rank ? n.concat(new Array(a.rank - n.length).fill(-1)) : n).map(function (e, t) {\n    return e >= 0 ? e : (assert(-1 === e, \"Bad value in size\"), a.shape[t] - r[t]);\n  }), assertParamsValid(a, r, o);var i = a.shape;return ENV.engine.runKernel(function (e) {\n    return e.slice(a, r, o);\n  }, { $x: a }, function (e) {\n    for (var t = [], n = 0; n < e.rank; n++) t.push([r[n], i[n] - r[n] - o[n]]);return { $x: function () {\n        return e.pad(t);\n      } };\n  });\n}var slice = op({ slice_: slice_ }),\n    slice1d = op({ slice1d_: slice1d_ }),\n    slice2d = op({ slice2d_: slice2d_ }),\n    slice3d = op({ slice3d_: slice3d_ }),\n    slice4d = op({ slice4d_: slice4d_ });function logSumExp_(e, t, n) {\n  void 0 === t && (t = null), void 0 === n && (n = !1);var r = convertToTensor(e, \"x\", \"logSumExp\"),\n      o = parseAxisParam(t, r.shape),\n      a = r.max(o, !0),\n      i = r.sub(a).exp().sum(o).log(),\n      s = a.reshape(i.shape).add(i);if (n) {\n    var u = expandShapeToKeepDim(s.shape, o);return s.reshape(u);\n  }return s;\n}function sum_(e, t, n) {\n  void 0 === t && (t = null), void 0 === n && (n = !1);var r = convertToTensor(e, \"x\", \"sum\");\"bool\" === r.dtype && (r = r.toInt());var o = parseAxisParam(t, r.shape);return customGrad(function (e) {\n    var t = getAxesPermutation(o, e.rank),\n        r = o,\n        a = e;null != t && (a = e.transpose(t), r = getInnerMostAxes(r.length, e.rank));var i = ENV.engine.runKernel(function (e) {\n      return e.sum(a, r);\n    }, { permutedX: a });if (n) {\n      var s = expandShapeToKeepDim(i.shape, o);i = i.reshape(s);\n    }return { value: i, gradFunc: function (t) {\n        var n = e.shape.slice();return o.forEach(function (e) {\n          n[e] = 1;\n        }), t.reshape(n).mul(ones$1(e.shape, \"float32\"));\n      } };\n  })(r);\n}function mean_(e, t, n) {\n  void 0 === t && (t = null), void 0 === n && (n = !1);var r = convertToTensor(e, \"x\", \"mean\"),\n      o = parseAxisParam(t, r.shape),\n      a = sizeFromShape(computeOutAndReduceShapes(r.shape, o)[1]);return customGrad(function (e) {\n    var r = scalar(a);return { value: (r.dtype === e.dtype ? e : e.cast(r.dtype)).div(r).sum(t, n), gradFunc: function (t) {\n        var n = e.shape.slice();return o.forEach(function (e) {\n          n[e] = 1;\n        }), t.reshape(n).mul(ones$1(e.shape, \"float32\")).div(r);\n      } };\n  })(r);\n}function gradForMinAndMax(e, t, n, r, o) {\n  var a = t[0];return a.rank < n.rank && (a = a.reshape(expandShapeToKeepDim(a.shape, r))), e.rank < n.rank && (e = e.reshape(expandShapeToKeepDim(e.shape, r))), { $x: function () {\n      var t = e.mul(n.equal(a).cast(e.dtype));return null == o ? t : t.transpose(o);\n    } };\n}function min_(e, t, n) {\n  void 0 === t && (t = null), void 0 === n && (n = !1);var r = convertToTensor(e, \"x\", \"min\"),\n      o = r,\n      a = parseAxisParam(t, r.shape),\n      i = a,\n      s = getAxesPermutation(i, r.rank);null != s && (r = r.transpose(s), i = getInnerMostAxes(i.length, r.rank));var u = ENV.engine.runKernel(function (e, t) {\n    return t(e.min(r, i));\n  }, { $x: r }, function (e, t) {\n    return gradForMinAndMax(e, t, o, a, s);\n  });if (n) {\n    var l = expandShapeToKeepDim(u.shape, a);u = u.reshape(l);\n  }return u;\n}function max_(e, t, n) {\n  void 0 === t && (t = null), void 0 === n && (n = !1);var r = convertToTensor(e, \"x\", \"max\"),\n      o = r,\n      a = parseAxisParam(t, r.shape),\n      i = a,\n      s = getAxesPermutation(i, r.rank);null != s && (r = r.transpose(s), i = getInnerMostAxes(i.length, r.rank));var u = ENV.engine.runKernel(function (e, t) {\n    return t(e.max(r, i));\n  }, { $x: r }, function (e, t) {\n    return gradForMinAndMax(e, t, o, a, s);\n  });if (n) {\n    var l = expandShapeToKeepDim(u.shape, a);u = u.reshape(l);\n  }return u;\n}function argMin_(e, t) {\n  void 0 === t && (t = 0);var n = convertToTensor(e, \"x\", \"argMin\");null == t && (t = 0);var r = parseAxisParam(t, n.shape),\n      o = getAxesPermutation(r, n.rank);null != o && (n = n.transpose(o), r = getInnerMostAxes(r.length, n.rank));return ENV.engine.runKernel(function (e) {\n    return e.argMin(n, r[0]);\n  }, { $x: n }, function (e) {\n    return { $x: function () {\n        return zerosLike(n);\n      } };\n  });\n}function argMax_(e, t) {\n  void 0 === t && (t = 0);var n = convertToTensor(e, \"x\", \"argMax\");null == t && (t = 0);var r = parseAxisParam(t, n.shape),\n      o = getAxesPermutation(r, n.rank);null != o && (n = n.transpose(o), r = getInnerMostAxes(r.length, n.rank));return ENV.engine.runKernel(function (e) {\n    return e.argMax(n, r[0]);\n  }, { $x: n }, function (e) {\n    return { $x: function () {\n        return zerosLike(n);\n      } };\n  });\n}function all_(e, t, n) {\n  void 0 === t && (t = null), void 0 === n && (n = !1);var r = convertToTensor(e, \"x\", \"all\", \"bool\");assert(\"bool\" === r.dtype, \"Error Tensor must be of type bool. Got: \" + r.dtype);var o = parseAxisParam(t, r.shape),\n      a = o,\n      i = getAxesPermutation(a, r.rank);null != i && (r = r.transpose(i), a = getInnerMostAxes(a.length, r.rank));var s = ENV.engine.runKernel(function (e) {\n    return e.all(r, a);\n  }, { $x: r });if (n) {\n    var u = expandShapeToKeepDim(s.shape, o);return s.reshape(u);\n  }return s;\n}function any_(e, t, n) {\n  void 0 === t && (t = null), void 0 === n && (n = !1);var r = convertToTensor(e, \"x\", \"any\", \"bool\");assert(\"bool\" === r.dtype, \"Error Tensor must be of type bool. Got: \" + r.dtype);var o = parseAxisParam(t, r.shape),\n      a = o,\n      i = getAxesPermutation(a, r.rank);null != i && (r = r.transpose(i), a = getInnerMostAxes(a.length, r.rank));var s = ENV.engine.runKernel(function (e) {\n    return e.any(r, a);\n  }, { $x: r });if (n) {\n    var u = expandShapeToKeepDim(s.shape, o);return s.reshape(u);\n  }return s;\n}function moments_(e, t, n) {\n  void 0 === t && (t = null), void 0 === n && (n = !1);var r = parseAxisParam(t, (e = convertToTensor(e, \"x\", \"moments\")).shape),\n      o = e.mean(r, n),\n      a = o.shape;return n || (a = expandShapeToKeepDim(o.shape, r)), { mean: o, variance: e.toFloat().sub(o.reshape(a)).square().mean(r, n) };\n}var all = op({ all_: all_ }),\n    any = op({ any_: any_ }),\n    argMax = op({ argMax_: argMax_ }),\n    argMin = op({ argMin_: argMin_ }),\n    logSumExp = op({ logSumExp_: logSumExp_ }),\n    max = op({ max_: max_ }),\n    mean = op({ mean_: mean_ }),\n    min = op({ min_: min_ }),\n    moments = op({ moments_: moments_ }),\n    sum = op({ sum_: sum_ });function notEqual_(e, t) {\n  var n = convertToTensor(e, \"a\", \"notEqual\"),\n      r = convertToTensor(t, \"b\", \"notEqual\");return assertTypesMatch(n, r), assertAndGetBroadcastShape(n.shape, r.shape), ENV.engine.runKernel(function (e) {\n    return e.notEqual(n, r);\n  }, { $a: n, $b: r });\n}function notEqualStrict_(e, t) {\n  var n = convertToTensor(e, \"a\", \"notEqualStrict\"),\n      r = convertToTensor(t, \"b\", \"notEqualStrict\");return assertShapesMatch(n.shape, r.shape, \"Error in notEqualStrict: \"), n.notEqual(r);\n}function less_(e, t) {\n  var n = convertToTensor(e, \"a\", \"less\"),\n      r = convertToTensor(t, \"b\", \"less\");return assertTypesMatch(n, r), assertAndGetBroadcastShape(n.shape, r.shape), ENV.engine.runKernel(function (e) {\n    return e.less(n, r);\n  }, { $a: n, $b: r });\n}function lessStrict_(e, t) {\n  var n = convertToTensor(e, \"a\", \"lessStrict\"),\n      r = convertToTensor(t, \"b\", \"lessStrict\");return assertShapesMatch(n.shape, r.shape, \"Error in lessStrict: \"), n.less(r);\n}function equal_(e, t) {\n  var n = convertToTensor(e, \"a\", \"equal\"),\n      r = convertToTensor(t, \"b\", \"equal\");return assertTypesMatch(n, r), assertAndGetBroadcastShape(n.shape, r.shape), ENV.engine.runKernel(function (e) {\n    return e.equal(n, r);\n  }, { $a: n, $b: r });\n}function equalStrict_(e, t) {\n  var n = convertToTensor(e, \"a\", \"equalStrict\"),\n      r = convertToTensor(t, \"b\", \"equalStrict\");return assertShapesMatch(n.shape, r.shape, \"Error in equalStrict: \"), n.equal(r);\n}function lessEqual_(e, t) {\n  var n = convertToTensor(e, \"a\", \"lessEqual\"),\n      r = convertToTensor(t, \"b\", \"lessEqual\");return assertTypesMatch(n, r), assertAndGetBroadcastShape(n.shape, r.shape), ENV.engine.runKernel(function (e) {\n    return e.lessEqual(n, r);\n  }, { $a: n, $b: r });\n}function lessEqualStrict_(e, t) {\n  var n = convertToTensor(e, \"a\", \"lessEqualStrict\"),\n      r = convertToTensor(t, \"b\", \"lessEqualStrict\");return assertShapesMatch(n.shape, r.shape, \"Error in lessEqualStrict: \"), n.lessEqual(r);\n}function greater_(e, t) {\n  var n = convertToTensor(e, \"a\", \"greater\"),\n      r = convertToTensor(t, \"b\", \"greater\");return assertTypesMatch(n, r), assertAndGetBroadcastShape(n.shape, r.shape), ENV.engine.runKernel(function (e) {\n    return e.greater(n, r);\n  }, { $a: n, $b: r });\n}function greaterStrict_(e, t) {\n  var n = convertToTensor(e, \"a\", \"greaterStrict\"),\n      r = convertToTensor(t, \"b\", \"greaterStrict\");return assertShapesMatch(n.shape, r.shape, \"Error in greaterStrict: \"), n.greater(r);\n}function greaterEqual_(e, t) {\n  var n = convertToTensor(e, \"a\", \"greaterEqual\"),\n      r = convertToTensor(t, \"b\", \"greaterEqual\");assertTypesMatch(n, r), assertAndGetBroadcastShape(n.shape, r.shape);return ENV.engine.runKernel(function (e) {\n    return e.greaterEqual(n, r);\n  }, { $a: n, $b: r }, function (e) {\n    return { $a: function () {\n        return zerosLike(n);\n      }, $b: function () {\n        return zerosLike(r);\n      } };\n  });\n}function greaterEqualStrict_(e, t) {\n  var n = convertToTensor(e, \"a\", \"greaterEqualStrict\"),\n      r = convertToTensor(t, \"b\", \"greaterEqualStrict\");return assertShapesMatch(n.shape, r.shape, \"Error in greaterEqualStrict: \"), n.greaterEqual(r);\n}var equal = op({ equal_: equal_ }),\n    equalStrict = op({ equalStrict_: equalStrict_ }),\n    greater = op({ greater_: greater_ }),\n    greaterEqual = op({ greaterEqual_: greaterEqual_ }),\n    greaterEqualStrict = op({ greaterEqualStrict_: greaterEqualStrict_ }),\n    greaterStrict = op({ greaterStrict_: greaterStrict_ }),\n    less = op({ less_: less_ }),\n    lessEqual = op({ lessEqual_: lessEqual_ }),\n    lessEqualStrict = op({ lessEqualStrict_: lessEqualStrict_ }),\n    lessStrict = op({ lessStrict_: lessStrict_ }),\n    notEqual = op({ notEqual_: notEqual_ }),\n    notEqualStrict = op({ notEqualStrict_: notEqualStrict_ });function add_(e, t) {\n  var n = convertToTensor(e, \"a\", \"add\"),\n      r = convertToTensor(t, \"b\", \"add\");assertTypesMatch(n, r);var o = assertAndGetBroadcastShape(n.shape, r.shape);return ENV.engine.runKernel(function (e) {\n    return e.add(n, r);\n  }, { $a: n, $b: r }, function (e) {\n    return { $a: function () {\n        var t = e,\n            r = getReductionAxes(n.shape, o);return r.length > 0 && (t = t.sum(r)), t.reshape(n.shape);\n      }, $b: function () {\n        var t = e,\n            n = getReductionAxes(r.shape, o);return n.length > 0 && (t = t.sum(n)), t.reshape(r.shape);\n      } };\n  });\n}function addN_(e) {\n  assert(Array.isArray(e), function () {\n    return \"The argument passed to tf.addN() must be a list of tensors\";\n  }), assert(e.length >= 1, function () {\n    return \"Must pass at least one tensor to tf.addN(), but got \" + e.length;\n  });var t = e.map(function (e, t) {\n    return convertToTensor(e, \"tensors\" + t, \"addN\");\n  }),\n      n = t[0];t.forEach(function (e) {\n    if (e.dtype !== n.dtype) throw new Error(\"All tensors passed to tf.addN() must have the same dtype\");\n  }), t.forEach(function (e) {\n    if (!arraysEqual(e.shape, n.shape)) throw new Error(\"All tensors passed to tf.addN() must have the same shape\");\n  });var r = t;return ENV.engine.runKernel(function (e) {\n    return e.addN(t);\n  }, r, function (e) {\n    var n = {};return t.forEach(function (t, r) {\n      n[r] = function () {\n        return e.clone();\n      };\n    }), n;\n  });\n}function addStrict_(e, t) {\n  return assertShapesMatch(e.shape, t.shape, \"Error in addStrict: \"), e.add(t);\n}function sub_(e, t) {\n  var n = convertToTensor(e, \"a\", \"sub\"),\n      r = convertToTensor(t, \"b\", \"sub\");assertTypesMatch(n, r);var o = assertAndGetBroadcastShape(n.shape, r.shape);return ENV.engine.runKernel(function (e) {\n    return e.subtract(n, r);\n  }, { $a: n, $b: r }, function (e) {\n    return { $a: function () {\n        var t = e,\n            r = getReductionAxes(n.shape, o);return r.length > 0 && (t = t.sum(r)), t.reshape(n.shape);\n      }, $b: function () {\n        var t = e,\n            n = getReductionAxes(r.shape, o);return n.length > 0 && (t = t.sum(n)), t.neg().reshape(r.shape);\n      } };\n  });\n}function subStrict_(e, t) {\n  return assertShapesMatch(e.shape, t.shape, \"Error in subStrict: \"), e.sub(t);\n}function pow_(e, t) {\n  var n = convertToTensor(e, \"base\", \"pow\"),\n      r = convertToTensor(t, \"exp\", \"pow\"),\n      o = assertAndGetBroadcastShape(n.shape, r.shape);e = n.cast(upcastType(n.dtype, r.dtype)), t = r.cast(upcastType(n.dtype, r.dtype));return ENV.engine.runKernel(function (e, t) {\n    return t(e.pow(n, r));\n  }, { $base: n, $exp: r }, function (e, t) {\n    var a = t[0];return { $base: function () {\n        var t = e.mul(r.toFloat().mul(a.div(n))),\n            i = getReductionAxes(n.shape, o);return i.length > 0 && (t = t.sum(i)), t.reshape(n.shape);\n      }, $exp: function () {\n        var t = e.mul(a.mul(n.log()).toFloat()),\n            i = getReductionAxes(r.shape, o);return i.length > 0 && (t = t.sum(i)), t.reshape(r.shape);\n      } };\n  });\n}function powStrict_(e, t) {\n  return assertShapesMatch(e.shape, t.shape, \"Error in powStrict: \"), e.pow(t);\n}function mul_(e, t) {\n  var n = convertToTensor(e, \"a\", \"mul\"),\n      r = convertToTensor(t, \"b\", \"mul\");assertTypesMatch(n, r);var o = assertAndGetBroadcastShape(n.shape, r.shape);return ENV.engine.runKernel(function (e) {\n    return e.multiply(n, r);\n  }, { $a: n, $b: r }, function (e) {\n    return { $a: function () {\n        var t = e.mul(r.toFloat()),\n            a = getReductionAxes(n.shape, o);return a.length > 0 ? t.sum(a).reshape(n.shape) : t;\n      }, $b: function () {\n        var t = e.mul(n.toFloat()),\n            a = getReductionAxes(r.shape, o);return a.length > 0 ? t.sum(a).reshape(r.shape) : t;\n      } };\n  });\n}function mulStrict_(e, t) {\n  return assertShapesMatch(e.shape, t.shape, \"Error in multiplyStrict: \"), e.mul(t);\n}function div_(e, t) {\n  var n,\n      r = convertToTensor(e, \"a\", \"div\"),\n      o = convertToTensor(t, \"b\", \"div\");if (assertTypesMatch(r, o), \"int32\" === r.dtype && \"int32\" === o.dtype) return floorDiv(r, o);n = function (e) {\n    return e.realDivide(r, o);\n  };var a = assertAndGetBroadcastShape(r.shape, o.shape);return ENV.engine.runKernel(n, { $a: r, $b: o }, function (e) {\n    return { $a: function () {\n        var t = e.div(o.toFloat()),\n            n = getReductionAxes(r.shape, a);return n.length > 0 ? t.sum(n).reshape(r.shape) : t;\n      }, $b: function () {\n        var t = e.mul(r.toFloat()),\n            n = getReductionAxes(o.shape, a);n.length > 0 && (t = t.sum(n).reshape(o.shape));var i = o.square();return t.div(i.toFloat()).neg();\n      } };\n  });\n}function floorDiv_(e, t) {\n  var n = convertToTensor(e, \"a\", \"floorDiv\"),\n      r = convertToTensor(t, \"b\", \"floorDiv\");assertTypesMatch(n, r);var o = assertAndGetBroadcastShape(n.shape, r.shape);return ENV.engine.runKernel(function (e) {\n    return e.floorDiv(n, r);\n  }, { $a: n, $b: r }, function (e) {\n    return { $a: function () {\n        var t = e.div(r.toFloat()),\n            a = getReductionAxes(n.shape, o);return a.length > 0 ? t.sum(a).reshape(n.shape) : t;\n      }, $b: function () {\n        var t = e.mul(n.toFloat()),\n            a = getReductionAxes(r.shape, o);a.length > 0 && (t = t.sum(a).reshape(r.shape));var i = r.square();return t.div(i.toFloat()).neg();\n      } };\n  });\n}function divStrict_(e, t) {\n  return assertShapesMatch(e.shape, t.shape, \"Error in divideStrict: \"), e.div(t);\n}function mod_(e, t) {\n  var n = convertToTensor(e, \"a\", \"mod\"),\n      r = convertToTensor(t, \"b\", \"mod\");assertTypesMatch(n, r);var o = assertAndGetBroadcastShape(n.shape, r.shape);return ENV.engine.runKernel(function (e) {\n    return e.mod(n, r);\n  }, { $a: n, $b: r }, function (e) {\n    return { $a: function () {\n        var t = getReductionAxes(n.shape, o);return t.length > 0 ? e.sum(t).reshape(n.shape) : e;\n      }, $b: function () {\n        var t = e.mul(n.div(r).floor().neg()),\n            a = getReductionAxes(r.shape, o);return a.length > 0 ? t.sum(a).reshape(r.shape) : t;\n      } };\n  });\n}function modStrict_(e, t) {\n  return assertShapesMatch(e.shape, t.shape, \"Error in modStrict: \"), e.mod(t);\n}function minimum_(e, t) {\n  var n = convertToTensor(e, \"a\", \"minimum\"),\n      r = convertToTensor(t, \"b\", \"minimum\");assertTypesMatch(n, r), \"bool\" === n.dtype && (n = n.toInt()), \"bool\" === r.dtype && (r = r.toInt()), assertAndGetBroadcastShape(n.shape, r.shape);return ENV.engine.runKernel(function (e) {\n    return e.minimum(n, r);\n  }, { $a: n, $b: r }, function (e) {\n    return { $a: function () {\n        return e.mul(n.lessEqual(r).toFloat());\n      }, $b: function () {\n        return e.mul(n.greater(r).toFloat());\n      } };\n  });\n}function minimumStrict_(e, t) {\n  return assertShapesMatch(e.shape, t.shape, \"Error in minimumStrict: \"), e.minimum(t);\n}function maximum_(e, t) {\n  var n = convertToTensor(e, \"a\", \"maximum\"),\n      r = convertToTensor(t, \"b\", \"maximum\");assertTypesMatch(n, r), \"bool\" === n.dtype && (n = n.toInt()), \"bool\" === r.dtype && (r = r.toInt()), assertAndGetBroadcastShape(n.shape, r.shape);return ENV.engine.runKernel(function (e) {\n    return e.maximum(n, r);\n  }, { $a: n, $b: r }, function (e) {\n    return { $a: function () {\n        return e.mul(n.greaterEqual(r).toFloat());\n      }, $b: function () {\n        return e.mul(n.less(r).toFloat());\n      } };\n  });\n}function maximumStrict_(e, t) {\n  return assertShapesMatch(e.shape, t.shape, \"Error in maximumStrict: \"), e.maximum(t);\n}function squaredDifference_(e, t) {\n  var n = convertToTensor(e, \"a\", \"squaredDifference\"),\n      r = convertToTensor(t, \"b\", \"squaredDifference\");assertTypesMatch(n, r), assertAndGetBroadcastShape(n.shape, r.shape);return ENV.engine.runKernel(function (e) {\n    return e.squaredDifference(n, r);\n  }, { $a: n, $b: r }, function (e) {\n    var t = scalar(2);return { $a: function () {\n        return e.mul(n.sub(r).mul(t));\n      }, $b: function () {\n        return e.mul(r.sub(n).mul(t));\n      } };\n  });\n}function squaredDifferenceStrict_(e, t) {\n  return assertShapesMatch(e.shape, t.shape, \"Error in squaredDifferenceStrict: \"), e.squaredDifference(t);\n}function atan2_(e, t) {\n  var n = convertToTensor(e, \"a\", \"atan2\"),\n      r = convertToTensor(t, \"b\", \"atan2\");assertTypesMatch(n, r);var o = assertAndGetBroadcastShape(n.shape, r.shape);return ENV.engine.runKernel(function (e) {\n    return e.atan2(n, r);\n  }, { $a: n, $b: r }, function (e) {\n    return { $a: function () {\n        var t = add(n.square(), r.square()),\n            a = e.mul(r.div(t)),\n            i = getReductionAxes(n.shape, o);return i.length > 0 && (a = a.sum(i)), a.reshape(n.shape);\n      }, $b: function () {\n        var t = add(n.square(), r.square()),\n            a = neg(e.mul(n.div(t))),\n            i = getReductionAxes(r.shape, o);return i.length > 0 && (a = a.sum(i)), a.reshape(r.shape);\n      } };\n  });\n}var add = op({ add_: add_ }),\n    addN = op({ addN_: addN_ }),\n    addStrict = op({ addStrict_: addStrict_ }),\n    atan2 = op({ atan2_: atan2_ }),\n    div = op({ div_: div_ }),\n    divStrict = op({ divStrict_: divStrict_ }),\n    floorDiv = op({ floorDiv_: floorDiv_ }),\n    maximum = op({ maximum_: maximum_ }),\n    maximumStrict = op({ maximumStrict_: maximumStrict_ }),\n    minimum = op({ minimum_: minimum_ }),\n    minimumStrict = op({ minimumStrict_: minimumStrict_ }),\n    mod = op({ mod_: mod_ }),\n    modStrict = op({ modStrict_: modStrict_ }),\n    mul = op({ mul_: mul_ }),\n    mulStrict = op({ mulStrict_: mulStrict_ }),\n    pow = op({ pow_: pow_ }),\n    powStrict = op({ powStrict_: powStrict_ }),\n    squaredDifference = op({ squaredDifference_: squaredDifference_ }),\n    squaredDifferenceStrict = op({ squaredDifferenceStrict_: squaredDifferenceStrict_ }),\n    sub = op({ sub_: sub_ }),\n    subStrict = op({ subStrict_: subStrict_ });function logicalNot_(e) {\n  var t = convertToTensor(e, \"x\", \"logicalNot\", \"bool\");return assert(\"bool\" === t.dtype, \"Error Array must be of type bool.\"), ENV.engine.runKernel(function (e) {\n    return e.logicalNot(t);\n  }, { $x: t });\n}function logicalAnd_(e, t) {\n  var n = convertToTensor(e, \"a\", \"logicalAnd\", \"bool\"),\n      r = convertToTensor(t, \"b\", \"logicalAnd\", \"bool\");return assert(\"bool\" === n.dtype && \"bool\" === r.dtype, \"Error Array must be of type bool.\"), assertAndGetBroadcastShape(n.shape, r.shape), ENV.engine.runKernel(function (e) {\n    return e.logicalAnd(n, r);\n  }, { $a: n, $b: r });\n}function logicalOr_(e, t) {\n  var n = convertToTensor(e, \"a\", \"logicalOr\", \"bool\"),\n      r = convertToTensor(t, \"b\", \"logicalOr\", \"bool\");return assert(\"bool\" === n.dtype && \"bool\" === r.dtype, \"Error Array must be of type bool.\"), assertAndGetBroadcastShape(n.shape, r.shape), ENV.engine.runKernel(function (e) {\n    return e.logicalOr(n, r);\n  }, { $a: n, $b: r });\n}function logicalXor_(e, t) {\n  var n = convertToTensor(e, \"a\", \"logicalXor\", \"bool\"),\n      r = convertToTensor(t, \"b\", \"logicalXor\", \"bool\");return assert(\"bool\" === n.dtype && \"bool\" === r.dtype, \"Error Array must be of type bool.\"), assertAndGetBroadcastShape(n.shape, r.shape), logicalOr(e, t).logicalAnd(logicalAnd(e, t).logicalNot());\n}function where_(e, t, n) {\n  var r = convertToTensor(t, \"a\", \"where\"),\n      o = convertToTensor(n, \"b\", \"where\"),\n      a = convertToTensor(e, \"condition\", \"where\", \"bool\");assert(\"bool\" === a.dtype, \"Error Condition must be of type bool.\"), assertShapesMatch(r.shape, o.shape, \"Error in where: \"), 1 === a.rank ? assert(a.shape[0] === r.shape[0], \"The first dimension of `a` must match the size of `condition`.\") : assertShapesMatch(a.shape, o.shape, \"Error in where: \");return ENV.engine.runKernel(function (e) {\n    return e.select(a, r, o);\n  }, { $condition: a, $a: r, $b: o }, function (e) {\n    return { $condition: function () {\n        return zerosLike(a);\n      }, $a: function () {\n        return e.mul(a.cast(r.dtype));\n      }, $b: function () {\n        return e.mul(a.logicalNot().cast(o.dtype));\n      } };\n  });\n}function whereAsync_(e) {\n  return __awaiter(this, void 0, void 0, function () {\n    var t, n, r;return __generator(this, function (o) {\n      switch (o.label) {case 0:\n          return assert(\"bool\" === (t = convertToTensor(e, \"condition\", \"where\", \"bool\")).dtype, \"Condition must be of type bool.\"), [4, t.data()];case 1:\n          return n = o.sent(), r = whereImpl(t.shape, n), e !== t && t.dispose(), [2, r];}\n    });\n  });\n}var logicalAnd = op({ logicalAnd_: logicalAnd_ }),\n    logicalNot = op({ logicalNot_: logicalNot_ }),\n    logicalOr = op({ logicalOr_: logicalOr_ }),\n    logicalXor = op({ logicalXor_: logicalXor_ }),\n    where = op({ where_: where_ }),\n    whereAsync = whereAsync_;function relu_(e) {\n  var t = convertToTensor(e, \"x\", \"relu\");if (\"bool\" === t.dtype) return t.toInt();return ENV.engine.runKernel(function (e) {\n    return e.relu(t);\n  }, { $x: t }, function (e) {\n    var n = t.step();return { $x: function () {\n        return e.mulStrict(n.toFloat());\n      } };\n  });\n}function elu_(e) {\n  var t = convertToTensor(e, \"x\", \"elu\");return ENV.engine.runKernel(function (e, n) {\n    return n(e.elu(t));\n  }, { $x: t }, function (e, t) {\n    var n = t[0];return { $x: function () {\n        return ENV.engine.runKernel(function (t) {\n          return t.eluDer(e, n);\n        }, { dy: e, y: n });\n      } };\n  });\n}function selu_(e) {\n  var t = convertToTensor(e, \"x\", \"selu\");return ENV.engine.runKernel(function (e) {\n    return e.selu(t);\n  }, { $x: t }, function (e) {\n    return { $x: function () {\n        var n = t.greater(scalar(0)),\n            r = scalar(SELU_SCALEALPHA),\n            o = scalar(SELU_SCALE),\n            a = e.mul(o),\n            i = e.mul(r).mul(t.toFloat().exp());return where(n, a, i);\n      } };\n  });\n}function leakyRelu_(e, t) {\n  void 0 === t && (t = .2);var n = convertToTensor(e, \"x\", \"leakyRelu\");return maximum(scalar(t).mul(n), n);\n}function prelu_(e, t) {\n  var n = convertToTensor(e, \"x\", \"prelu\"),\n      r = convertToTensor(t, \"alpha\", \"prelu\"),\n      o = scalar(0);return maximum(o, n).add(r.mul(minimum(o, n)));\n}var elu = op({ elu_: elu_ }),\n    leakyRelu = op({ leakyRelu_: leakyRelu_ }),\n    prelu = op({ prelu_: prelu_ }),\n    relu = op({ relu_: relu_ }),\n    selu = op({ selu_: selu_ });function transpose_(e, t) {\n  var n = convertToTensor(e, \"x\", \"transpose\");if (null == t && (t = n.shape.map(function (e, t) {\n    return t;\n  }).reverse()), assert(n.rank === t.length, \"Error in transpose: rank of input \" + n.rank + \" must match length of perm \" + t + \".\"), t.forEach(function (e) {\n    assert(e >= 0 && e < n.rank, \"All entries in 'perm' must be between 0 and \" + (n.rank - 1) + \" but got \" + t);\n  }), n.rank <= 1) return n.clone();return ENV.engine.runKernel(function (e) {\n    return e.transpose(n, t);\n  }, { $x: n }, function (e) {\n    var n = getUndoAxesPermutation(t);return { $x: function () {\n        return e.transpose(n);\n      } };\n  });\n}var transpose = op({ transpose_: transpose_ });function localResponseNormalization_(e, t, n, r, o) {\n  void 0 === t && (t = 5), void 0 === n && (n = 1), void 0 === r && (r = 1), void 0 === o && (o = .5);var a = convertToTensor(e, \"x\", \"localResponseNormalization\");assert(4 === a.rank || 3 === a.rank, \"Error in localResponseNormalization: x must be rank 3 or 4 but got\\n               rank \" + a.rank + \".\"), assert(isInt(t), \"Error in localResponseNormalization: depthRadius must be an integer\\n                     but got depthRadius \" + t + \".\");var i = a,\n      s = !1;3 === a.rank && (s = !0, i = a.as4D(1, a.shape[0], a.shape[1], a.shape[2]));var u = ENV.engine.runKernel(function (e, a) {\n    return a(e.localResponseNormalization4D(i, t, n, r, o));\n  }, { x4D: i }, function (e, a) {\n    var s = a[0];return { x4D: function () {\n        return ENV.engine.runKernel(function (a) {\n          return a.LRNGrad(e, i, s, t, n, r, o);\n        }, {});\n      } };\n  });return s ? u.as3D(u.shape[1], u.shape[2], u.shape[3]) : u;\n}var localResponseNormalization = op({ localResponseNormalization_: localResponseNormalization_ });function norm_(e, t, n, r) {\n  void 0 === t && (t = \"euclidean\"), void 0 === n && (n = null), void 0 === r && (r = !1);var o = normImpl(e = convertToTensor(e, \"x\", \"norm\"), t, n),\n      a = o.shape;if (r) {\n    var i = parseAxisParam(n, e.shape);a = expandShapeToKeepDim(o.shape, i);\n  }return o.reshape(a);\n}function normImpl(e, t, n) {\n  if (void 0 === n && (n = null), 0 === e.rank) return e.abs();if (1 !== e.rank && null === n) return normImpl(e.reshape([-1]), t, n);if (1 === e.rank || \"number\" == typeof n || n instanceof Array && 1 === n.length) {\n    if (1 === t) return e.abs().sum(n);if (t === 1 / 0) return e.abs().max(n);if (t === -1 / 0) return e.abs().min(n);if (\"euclidean\" === t || 2 === t) return e.abs().pow(scalar(2, \"int32\")).sum(n).sqrt();throw new Error(\"Error in norm: invalid ord value: \" + t);\n  }if (n instanceof Array && 2 === n.length) {\n    if (1 === t) return e.abs().sum(n[0]).max(n[1] - 1);if (t === 1 / 0) return e.abs().sum(n[1]).max(n[0]);if (t === -1 / 0) return e.abs().sum(n[1]).min(n[0]);if (\"fro\" === t || \"euclidean\" === t) return e.square().sum(n).sqrt();throw new Error(\"Error in norm: invalid ord value: \" + t);\n  }throw new Error(\"Error in norm: invalid axis: \" + n);\n}var norm = op({ norm_: norm_ });function unsortedSegmentSum_(e, t, n) {\n  var r = convertToTensor(e, \"x\", \"unsortedSegmentSum\"),\n      o = convertToTensor(t, \"segmentIds\", \"unsortedSegmentSum\", \"int32\");assert(\"int32\" === o.dtype, \"segmentIds must be of dtype `int32`\"), assert(isInt(n), \"numSegments must be of dtype int\");return ENV.engine.runKernel(function (e) {\n    return e.unsortedSegmentSum(r, o, n);\n  }, { $x: r }, function (e) {\n    return { $x: function () {\n        return gatherDropNegatives(e, o);\n      } };\n  });\n}function gather_(e, t, n) {\n  void 0 === n && (n = 0);var r = convertToTensor(e, \"x\", \"gather\"),\n      o = convertToTensor(t, \"indices\", \"gather\", \"int32\");assert(\"int32\" === o.dtype, \"Indices must be of dtype `int32`\"), n = parseAxisParam(n, r.shape)[0];return ENV.engine.runKernel(function (e) {\n    return e.gather(r, o, n);\n  }, { $x: r }, function (e) {\n    return { $x: function () {\n        if (0 === n) return unsortedSegmentSum(e, o, r.shape[n]);var t = r.shape,\n            a = o.size,\n            i = t.slice(0, n),\n            s = i.length,\n            u = t.slice(n, t.length).slice(1),\n            l = u.length,\n            c = arrayRange(0, s),\n            p = arrayRange(s + 1, s + 1 + l),\n            d = arrayConcat([i, [a], u]),\n            h = e.reshape(d),\n            f = o.reshape([a]),\n            m = arrayConcat([[s], c, p]),\n            g = h.transpose(m),\n            v = unsortedSegmentSum(g, f, r.shape[n]),\n            x = getUndoAxesPermutation(m);return v = v.transpose(x);\n      } };\n  });\n}function arrayRange(e, t) {\n  for (var n = [], r = e; r < t; ++r) n.push(r);return n;\n}function arrayConcat(e) {\n  for (var t = [], n = 0; n < e.length; ++n) for (var r = 0; r < e[n].length; ++r) t.push(e[n][r]);return t;\n}function gatherDropNegatives(e, t) {\n  for (var n = maximum(t, zerosLike(t)), r = gather(e, n), o = greaterEqual(t, scalar(0, \"int32\")), a = r.rank - o.rank, i = 0; i < a; ++i) o = expandDims(o, i + 1);o = logicalAnd(o, ones$1(r.shape, \"bool\"));var s = zerosLike(r);return where(o, r, s);\n}var gather = op({ gather_: gather_ }),\n    unsortedSegmentSum = op({ unsortedSegmentSum_: unsortedSegmentSum_ });function multiRNNCell_(e, t, n, r) {\n  for (var o = convertToTensor(t, \"data\", \"multiRNNCell\"), a = convertToTensorArray(n, \"c\", \"multiRNNCell\"), i = convertToTensorArray(r, \"h\", \"multiRNNCell\"), s = o, u = [], l = 0; l < e.length; l++) {\n    var c = e[l](s, a[l], i[l]);u.push(c[0]), u.push(c[1]), s = c[1];\n  }var p = [],\n      d = [];for (l = 0; l < u.length; l += 2) p.push(u[l]), d.push(u[l + 1]);return [p, d];\n}function basicLSTMCell_(e, t, n, r, o, a) {\n  var i = convertToTensor(e, \"forgetBias\", \"basicLSTMCell\"),\n      s = convertToTensor(t, \"lstmKernel\", \"basicLSTMCell\"),\n      u = convertToTensor(n, \"lstmBias\", \"basicLSTMCell\"),\n      l = convertToTensor(r, \"data\", \"basicLSTMCell\"),\n      c = convertToTensor(o, \"c\", \"basicLSTMCell\"),\n      p = convertToTensor(a, \"h\", \"basicLSTMCell\"),\n      d = l.concat(p, 1).matMul(s).add(u),\n      h = d.shape[0],\n      f = d.shape[1] / 4,\n      m = [h, f],\n      g = d.slice([0, 0], m),\n      v = d.slice([0, f], m),\n      x = d.slice([0, 2 * f], m),\n      y = d.slice([0, 3 * f], m),\n      T = g.sigmoid().mulStrict(v.tanh()).addStrict(c.mulStrict(i.add(x).sigmoid()));return [T, T.tanh().mulStrict(y.sigmoid())];\n}var basicLSTMCell = op({ basicLSTMCell_: basicLSTMCell_ }),\n    multiRNNCell = op({ multiRNNCell_: multiRNNCell_ });function movingAverage_(e, t, n, r, o) {\n  void 0 === o && (o = !0);var a = convertToTensor(e, \"v\", \"movingAverage\"),\n      i = convertToTensor(t, \"x\", \"movingAverage\"),\n      s = convertToTensor(n, \"decay\", \"movingAverage\");assertTypesMatch(a, i), assert(arraysEqual(a.shape, i.shape), \"Shape mismatch in v and x\");var u = scalar(1),\n      l = u.sub(s),\n      c = i.sub(a).mul(l);if (o) {\n    assert(null != r, \"When using zeroDebias: true, step is required.\");var p = convertToTensor(r, \"step\", \"movingAverage\");c = c.div(u.sub(pow(s, p)));\n  }return a.add(c);\n}var movingAverage = op({ movingAverage_: movingAverage_ });function stridedSlice_(e, t, n, r, o, a, i, s, u) {\n  if (void 0 === o && (o = 0), void 0 === a && (a = 0), void 0 === i && (i = 0), void 0 === s && (s = 0), void 0 === u && (u = 0), 0 !== i) throw new Error(\"ellipsis mask is not yet supported\");if (0 !== s) throw new Error(\"new axis mask is not yet supported\");var l = convertToTensor(e, \"x\", \"stridedSlice\");return ENV.engine.runKernel(function (e) {\n    return e.stridedSlice(l, t, n, r, o, a, i, s, u);\n  }, { $x: l });\n}var stridedSlice = op({ stridedSlice_: stridedSlice_ });function topk_(e, t, n) {\n  void 0 === t && (t = 1), void 0 === n && (n = !0);var r = convertToTensor(e, \"x\", \"topk\");if (0 === r.rank) throw new Error(\"topk() expects the input to be of rank 1 or higher\");var o = r.shape[r.shape.length - 1];if (t > o) throw new Error(\"'k' passed to topk() must be <= the last dimension (\" + o + \") but got \" + t);var a = ENV.engine.runKernel(function (e) {\n    return e.topk(r, t, n);\n  }, { $x: r });return { values: a[0], indices: a[1] };\n}var Reduction,\n    topk = op({ topk_: topk_ });function computeWeightedLoss_(e, t, n) {\n  void 0 === n && (n = Reduction.SUM_BY_NONZERO_WEIGHTS);var r = convertToTensor(e, \"losses\", \"computeWeightedLoss\"),\n      o = null;null != t && (o = convertToTensor(t, \"weights\", \"computeWeightedLoss\"));var a = null == o ? r : r.mul(o);if (n === Reduction.NONE) return a;if (n === Reduction.SUM) return a.sum();if (n === Reduction.MEAN) {\n    if (null == o) return a.mean();var i = sizeFromShape(r.shape) / sizeFromShape(o.shape),\n        s = a.sum().div(o.sum());return i > 1 ? s.div(scalar(i)) : s;\n  }if (n === Reduction.SUM_BY_NONZERO_WEIGHTS) {\n    if (null == o) return a.sum().div(scalar(r.size));var u = o.mul(ones$1(r.shape)).notEqual(scalar(0)).sum().toFloat();return a.sum().div(u);\n  }throw Error(\"Unknown reduction: \" + n);\n}function absoluteDifference_(e, t, n, r) {\n  void 0 === r && (r = Reduction.SUM_BY_NONZERO_WEIGHTS);var o = convertToTensor(e, \"labels\", \"absoluteDifference\"),\n      a = convertToTensor(t, \"predictions\", \"absoluteDifference\"),\n      i = null;null != n && (i = convertToTensor(n, \"weights\", \"absoluteDifference\")), assertShapesMatch(o.shape, a.shape, \"Error in absoluteDifference: \");var s = o.sub(a).abs();return computeWeightedLoss(s, i, r);\n}function meanSquaredError_(e, t, n, r) {\n  void 0 === r && (r = Reduction.SUM_BY_NONZERO_WEIGHTS);var o = convertToTensor(e, \"labels\", \"meanSquaredError\"),\n      a = convertToTensor(t, \"predictions\", \"meanSquaredError\"),\n      i = null;null != n && (i = convertToTensor(n, \"weights\", \"meanSquaredError\")), assertShapesMatch(o.shape, a.shape, \"Error in meanSquaredError: \");var s = o.squaredDifference(a);return computeWeightedLoss(s, i, r);\n}function cosineDistance_(e, t, n, r, o) {\n  void 0 === o && (o = Reduction.SUM_BY_NONZERO_WEIGHTS);var a = convertToTensor(e, \"labels\", \"cosineDistance\"),\n      i = convertToTensor(t, \"predictions\", \"cosineDistance\"),\n      s = null;null != r && (s = convertToTensor(r, \"weights\", \"cosineDistance\")), assertShapesMatch(a.shape, i.shape, \"Error in cosineDistance: \");var u = scalar(1).sub(a.mul(i).sum(n, !0));return computeWeightedLoss(u, s, o);\n}function hingeLoss_(e, t, n, r) {\n  void 0 === r && (r = Reduction.SUM_BY_NONZERO_WEIGHTS);var o = convertToTensor(e, \"labels\", \"hingeLoss\"),\n      a = convertToTensor(t, \"predictions\", \"hingeLoss\"),\n      i = null;null != n && (i = convertToTensor(n, \"weights\", \"hingeLoss\")), assertShapesMatch(o.shape, a.shape, \"Error in hingeLoss: \");var s = scalar(1);o = scalar(2).mul(o).sub(s);var u = s.sub(o.mul(a)).relu();return computeWeightedLoss(u, i, r);\n}function logLoss_(e, t, n, r, o) {\n  void 0 === r && (r = 1e-7), void 0 === o && (o = Reduction.SUM_BY_NONZERO_WEIGHTS);var a = convertToTensor(e, \"labels\", \"logLoss\"),\n      i = convertToTensor(t, \"predictions\", \"logLoss\"),\n      s = null;null != n && (s = convertToTensor(n, \"weights\", \"logLoss\")), assertShapesMatch(a.shape, i.shape, \"Error in logLoss: \");var u = scalar(1),\n      l = scalar(r),\n      c = a.mul(i.add(l).log()).neg().sub(u.sub(a).mul(u.sub(i).add(l).log()));return computeWeightedLoss(c, s, o);\n}function sigmoidCrossEntropyWithLogits_(e, t) {\n  var n = convertToTensor(e, \"labels\", \"sigmoidCrossEntropyWithLogits\"),\n      r = convertToTensor(t, \"logits\", \"sigmoidCrossEntropyWithLogits\");assertShapesMatch(n.shape, r.shape, \"Error in sigmoidCrossEntropyWithLogits: \");var o = r.relu(),\n      a = r.mul(n),\n      i = r.abs().neg().exp().log1p();return o.sub(a).add(i);\n}function sigmoidCrossEntropy_(e, t, n, r, o) {\n  void 0 === r && (r = 0), void 0 === o && (o = Reduction.SUM_BY_NONZERO_WEIGHTS);var a = convertToTensor(e, \"multiClassLabels\", \"sigmoidCrossEntropy\"),\n      i = convertToTensor(t, \"logits\", \"sigmoidCrossEntropy\"),\n      s = null;if (null != n && (s = convertToTensor(n, \"weights\", \"sigmoidCrossEntropy\")), assertShapesMatch(a.shape, i.shape, \"Error in sigmoidCrossEntropy: \"), r > 0) {\n    var u = scalar(r),\n        l = scalar(1),\n        c = scalar(.5);a = a.mul(l.sub(u)).add(c.mul(u));\n  }var p = sigmoidCrossEntropyWithLogits_(a, i);return computeWeightedLoss(p, s, o);\n}function huberLoss_(e, t, n, r, o) {\n  void 0 === r && (r = 1), void 0 === o && (o = Reduction.SUM_BY_NONZERO_WEIGHTS);var a = convertToTensor(e, \"labels\", \"huberLoss\"),\n      i = convertToTensor(t, \"predictions\", \"huberLoss\"),\n      s = null;null != n && (s = convertToTensor(n, \"weights\", \"huberLoss\")), assertShapesMatch(a.shape, i.shape, \"Error in huberLoss: \");var u = scalar(r),\n      l = i.sub(a).abs(),\n      c = minimum(l, u),\n      p = l.sub(c),\n      d = scalar(.5).mul(c.square()).add(u.mul(p));return computeWeightedLoss(d, s, o);\n}function softmaxCrossEntropyWithLogits_(e, t, n) {\n  if (void 0 === n && (n = -1), -1 === n && (n = t.rank - 1), n !== t.rank - 1) throw Error(\"Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank \" + t.rank + \" and dim was \" + n);return customGrad(function (e, t) {\n    var r = t.logSumExp([n], !0),\n        o = t.toFloat().sub(r);return { value: o.mul(e).neg().sum([n]), gradFunc: function (t) {\n        var r = expandShapeToKeepDim(t.shape, [n]);return [t.reshape(r).mul(e.toFloat().sub(o.exp())), t.reshape(r).mul(o.exp().sub(e.toFloat()))];\n      } };\n  })(e, t);\n}function softmaxCrossEntropy_(e, t, n, r, o) {\n  void 0 === r && (r = 0), void 0 === o && (o = Reduction.SUM_BY_NONZERO_WEIGHTS);var a = convertToTensor(e, \"onehotLabels\", \"softmaxCrossEntropy\"),\n      i = convertToTensor(t, \"logits\", \"softmaxCrossEntropy\"),\n      s = null;if (null != n && (s = convertToTensor(n, \"weights\", \"softmaxCrossEntropy\")), assertShapesMatch(a.shape, i.shape, \"Error in softmaxCrossEntropy: \"), r > 0) {\n    var u = scalar(r),\n        l = scalar(1),\n        c = scalar(a.shape[1]);a = a.mul(l.sub(u)).add(u.div(c));\n  }var p = softmaxCrossEntropyWithLogits_(a, i);return computeWeightedLoss(p, s, o);\n}!function (e) {\n  e[e.NONE = 0] = \"NONE\", e[e.MEAN = 1] = \"MEAN\", e[e.SUM = 2] = \"SUM\", e[e.SUM_BY_NONZERO_WEIGHTS = 3] = \"SUM_BY_NONZERO_WEIGHTS\";\n}(Reduction || (exports.Reduction = Reduction = {}));var absoluteDifference = op({ absoluteDifference_: absoluteDifference_ }),\n    computeWeightedLoss = op({ computeWeightedLoss_: computeWeightedLoss_ }),\n    cosineDistance = op({ cosineDistance_: cosineDistance_ }),\n    hingeLoss = op({ hingeLoss_: hingeLoss_ }),\n    huberLoss = op({ huberLoss_: huberLoss_ }),\n    logLoss = op({ logLoss_: logLoss_ }),\n    meanSquaredError = op({ meanSquaredError_: meanSquaredError_ }),\n    sigmoidCrossEntropy = op({ sigmoidCrossEntropy_: sigmoidCrossEntropy_ }),\n    softmaxCrossEntropy = op({ softmaxCrossEntropy_: softmaxCrossEntropy_ }),\n    loss_ops = Object.freeze({ get Reduction() {\n    return Reduction;\n  }, absoluteDifference: absoluteDifference, computeWeightedLoss: computeWeightedLoss, cosineDistance: cosineDistance, hingeLoss: hingeLoss, huberLoss: huberLoss, logLoss: logLoss, meanSquaredError: meanSquaredError, sigmoidCrossEntropy: sigmoidCrossEntropy, softmaxCrossEntropy: softmaxCrossEntropy });function gramSchmidt_(e) {\n  var t;if (Array.isArray(e)) {\n    t = !1, assert(null != e && e.length > 0, \"Gram-Schmidt process: input must not be null, undefined, or empty\");for (var n = e[0].shape[0], r = 1; r < e.length; ++r) assert(e[r].shape[0] === n, \"Gram-Schmidt: Non-unique lengths found in the input vectors: (\" + e[r].shape[0] + \" vs. \" + n + \")\");\n  } else t = !0, e = split$1(e, e.shape[0], 0).map(function (e) {\n    return squeeze(e, [0]);\n  });assert(e.length <= e[0].shape[0], \"Gram-Schmidt: Number of vectors (\" + e.length + \") exceeds number of dimensions (\" + e[0].shape[0] + \").\");var o = [],\n      a = e,\n      i = function (e) {\n    o.push(ENV.engine.tidy(function () {\n      var t = a[e];if (e > 0) for (var n = 0; n < e; ++n) {\n        var r = sum(o[n].mulStrict(t)).mul(o[n]);t = t.sub(r);\n      }return t.div(norm(t, \"euclidean\"));\n    }));\n  };for (r = 0; r < e.length; ++r) i(r);return t ? stack(o, 0) : o;\n}function qr_(e, t) {\n  if (void 0 === t && (t = !1), e.rank < 2) throw new Error(\"qr() requires input tensor to have a rank >= 2, but got rank \" + e.rank);if (2 === e.rank) return qr2d(e, t);var n = e.shape.slice(0, e.shape.length - 2).reduce(function (e, t) {\n    return e * t;\n  }),\n      r = [],\n      o = [];return unstack(e.reshape([n, e.shape[e.shape.length - 2], e.shape[e.shape.length - 1]]), 0).forEach(function (e) {\n    var n = qr2d(e, t),\n        a = n[0],\n        i = n[1];r.push(a), o.push(i);\n  }), [stack(r, 0).reshape(e.shape), stack(o, 0).reshape(e.shape)];\n}function qr2d(e, t) {\n  return void 0 === t && (t = !1), ENV.engine.tidy(function () {\n    if (2 !== e.shape.length) throw new Error(\"qr2d() requires a 2D Tensor, but got a \" + e.shape.length + \"D Tensor.\");for (var n = e.shape[0], r = e.shape[1], o = eye(n), a = e.clone(), i = tensor2d([[1]], [1, 1]), s = i.clone(), u = n >= r ? r : n, l = function (e) {\n      var t,\n          u = a,\n          l = s,\n          c = o;t = ENV.engine.tidy(function () {\n        var t = a.slice([e, e], [n - e, 1]),\n            u = t.norm(),\n            l = a.slice([e, e], [1, 1]),\n            c = l.sign().neg(),\n            p = l.sub(c.mul(u)),\n            d = t.div(p);s = 1 === d.shape[0] ? i.clone() : i.concat(d.slice([1, 0], [d.shape[0] - 1, d.shape[1]]), 0);var h = c.matMul(p).div(u).neg(),\n            f = a.slice([e, 0], [n - e, r]),\n            m = h.mul(s);a = 0 === e ? f.sub(m.matMul(s.transpose().matMul(f))) : a.slice([0, 0], [e, r]).concat(f.sub(m.matMul(s.transpose().matMul(f))), 0);var g = o.slice([0, e], [n, o.shape[1] - e]);return o = 0 === e ? g.sub(g.matMul(s).matMul(m.transpose())) : o.slice([0, 0], [n, e]).concat(g.sub(g.matMul(s).matMul(m.transpose())), 1), [s, a, o];\n      }), s = t[0], a = t[1], o = t[2], dispose([u, l, c]);\n    }, c = 0; c < u; ++c) l(c);return !t && n > r && (o = o.slice([0, 0], [n, r]), a = a.slice([0, 0], [r, r])), [o, a];\n  });\n}var gramSchmidt = op({ gramSchmidt_: gramSchmidt_ }),\n    qr = op({ qr_: qr_ }),\n    linalg_ops = Object.freeze({ gramSchmidt: gramSchmidt, qr: qr });function resizeBilinear_(e, t, n) {\n  void 0 === n && (n = !1);var r = convertToTensor(e, \"images\", \"resizeBilinear\");assert(3 === r.rank || 4 === r.rank, \"Error in resizeBilinear: x must be rank 3 or 4, but got rank \" + r.rank + \".\"), assert(2 === t.length, \"Error in resizeBilinear: new shape must 2D, but got shape \" + t + \".\");var o = r,\n      a = !1;3 === r.rank && (a = !0, o = r.as4D(1, r.shape[0], r.shape[1], r.shape[2]));var i = t[0],\n      s = t[1],\n      u = ENV.engine.runKernel(function (e, t) {\n    return e.resizeBilinear(o, i, s, n);\n  }, { batchImages: o }, function (e, t) {\n    return { batchImages: function () {\n        return ENV.engine.runKernel(function (t) {\n          return t.resizeBilinearBackprop(e, o, n);\n        }, {});\n      } };\n  });return a ? u.as3D(u.shape[1], u.shape[2], u.shape[3]) : u;\n}function resizeNearestNeighbor_(e, t, n) {\n  void 0 === n && (n = !1);var r = convertToTensor(e, \"images\", \"resizeNearestNeighbor\");assert(3 === r.rank || 4 === r.rank, \"Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank \" + r.rank + \".\"), assert(2 === t.length, \"Error in resizeNearestNeighbor: new shape must 2D, but got shape \" + t + \".\"), assert(\"float32\" === r.dtype || \"int32\" === r.dtype, \"`images` must have `int32` or `float32` as dtype\");var o = r,\n      a = !1;3 === r.rank && (a = !0, o = r.as4D(1, r.shape[0], r.shape[1], r.shape[2]));var i = t[0],\n      s = t[1],\n      u = ENV.engine.runKernel(function (e, t) {\n    return e.resizeNearestNeighbor(o, i, s, n);\n  }, { batchImages: o }, function (e, t) {\n    return { batchImages: function () {\n        return ENV.engine.runKernel(function (t) {\n          return t.resizeNearestNeighborBackprop(e, o, n);\n        }, {});\n      } };\n  });return a ? u.as3D(u.shape[1], u.shape[2], u.shape[3]) : u;\n}function nonMaxSuppression_(e, t, n, r, o) {\n  void 0 === r && (r = .5), void 0 === o && (o = Number.NEGATIVE_INFINITY);var a = convertToTensor(e, \"boxes\", \"nonMaxSuppression\"),\n      i = convertToTensor(t, \"scores\", \"nonMaxSuppression\"),\n      s = nonMaxSuppSanityCheck(a, i, n, r, o);return n = s.maxOutputSize, r = s.iouThreshold, o = s.scoreThreshold, ENV.engine.runKernel(function (e) {\n    return e.nonMaxSuppression(a, i, n, r, o);\n  }, { $boxes: a });\n}function nonMaxSuppressionAsync_(e, t, n, r, o) {\n  return void 0 === r && (r = .5), void 0 === o && (o = Number.NEGATIVE_INFINITY), __awaiter(this, void 0, void 0, function () {\n    var a, i, s, u, l, c;return __generator(this, function (p) {\n      switch (p.label) {case 0:\n          return a = convertToTensor(e, \"boxes\", \"nonMaxSuppressionAsync\"), i = convertToTensor(t, \"scores\", \"nonMaxSuppressionAsync\"), s = nonMaxSuppSanityCheck(a, i, n, r, o), n = s.maxOutputSize, r = s.iouThreshold, o = s.scoreThreshold, [4, a.data()];case 1:\n          return u = p.sent(), [4, i.data()];case 2:\n          return l = p.sent(), c = nonMaxSuppressionImpl(u, l, n, r, o), a !== e && a.dispose(), i !== t && i.dispose(), [2, c];}\n    });\n  });\n}function nonMaxSuppSanityCheck(e, t, n, r, o) {\n  null == r && (r = .5), null == o && (o = Number.NEGATIVE_INFINITY);var a = e.shape[0];return n = Math.min(n, a), assert(0 <= r && r <= 1, \"iouThreshold must be in [0, 1], but was '\" + r + \"'\"), assert(2 === e.rank, \"boxes must be a 2D tensor, but was of rank '\" + e.rank + \"'\"), assert(4 === e.shape[1], \"boxes must have 4 columns, but 2nd dimension was \" + e.shape[1]), assert(1 === t.rank, \"scores must be a 1D tensor\"), assert(t.shape[0] === a, \"scores has incompatible shape with boxes. Expected \" + a + \", but was \" + t.shape[0]), { maxOutputSize: n, iouThreshold: r, scoreThreshold: o };\n}function cropAndResize_(e, t, n, r, o, a) {\n  var i = convertToTensor(e, \"image\", \"cropAndResize\", \"float32\"),\n      s = convertToTensor(t, \"boxes\", \"cropAndResize\", \"float32\"),\n      u = convertToTensor(n, \"boxInd\", \"cropAndResize\", \"int32\");o = o || \"bilinear\", a = a || 0;var l = s.shape[0];assert(4 === i.rank, \"Error in cropAndResize: image must be rank 4,but got rank \" + i.rank + \".\"), assert(2 === s.rank && 4 === s.shape[1], \"Error in cropAndResize: boxes must be have size [\" + l + \",4] but had shape \" + s.shape + \".\"), assert(1 === u.rank && u.shape[0] === l, \"Error in cropAndResize: boxInd must be have size [\" + l + \"] but had shape \" + s.shape + \".\"), assert(\"int32\" === u.dtype, \"Error in cropAndResize: boxInd must be of dtype int32, but got dtype \" + u.dtype + \".\"), assert(2 === r.length, \"Error in cropAndResize: cropSize must be of length 2, but got length \" + r.length + \".\"), assert(r[0] >= 1 && r[1] >= 1, \"cropSize must be atleast [1,1], but was \" + r), assert(\"bilinear\" === o || \"nearest\" === o, \"method must be bilinear or nearest, but was \" + o);return ENV.engine.runKernel(function (e, t) {\n    return e.cropAndResize(i, s, u, r, o, a);\n  }, { $image: i, $boxes: s });\n}var resizeBilinear = op({ resizeBilinear_: resizeBilinear_ }),\n    resizeNearestNeighbor = op({ resizeNearestNeighbor_: resizeNearestNeighbor_ }),\n    nonMaxSuppression = op({ nonMaxSuppression_: nonMaxSuppression_ }),\n    nonMaxSuppressionAsync = nonMaxSuppressionAsync_,\n    cropAndResize = cropAndResize_,\n    image_ops = Object.freeze({ resizeBilinear: resizeBilinear, resizeNearestNeighbor: resizeNearestNeighbor, nonMaxSuppression: nonMaxSuppression, nonMaxSuppressionAsync: nonMaxSuppressionAsync, cropAndResize: cropAndResize }),\n    ops = Object.freeze({ image: image_ops, linalg: linalg_ops, losses: loss_ops, op: op, batchNormalization2d: batchNormalization2d, batchNormalization3d: batchNormalization3d, batchNormalization4d: batchNormalization4d, batchNormalization: batchNormalization, complex: complex, real: real, imag: imag, concat: concat, concat1d: concat1d, concat2d: concat2d, concat3d: concat3d, concat4d: concat4d, split: split$1, conv1d: conv1d, conv2d: conv2d, depthwiseConv2d: depthwiseConv2d, separableConv2d: separableConv2d, conv2dTranspose: conv2dTranspose, matMul: matMul, dot: dot, outerProduct: outerProduct, reverse: reverse, reverse1d: reverse1d, reverse2d: reverse2d, reverse3d: reverse3d, reverse4d: reverse4d, maxPool: maxPool, avgPool: avgPool, slice: slice, slice1d: slice1d, slice2d: slice2d, slice3d: slice3d, slice4d: slice4d, abs: abs, acos: acos, acosh: acosh, asin: asin, asinh: asinh, atan: atan, atanh: atanh, ceil: ceil, clipByValue: clipByValue, cos: cos, cosh: cosh, erf: erf, exp: exp, expm1: expm1, floor: floor, log: log$1, log1p: log1p, logSigmoid: logSigmoid, neg: neg, reciprocal: reciprocal, round: round, rsqrt: rsqrt, sigmoid: sigmoid, sign: sign, sin: sin, sinh: sinh, softplus: softplus, sqrt: sqrt, square: square, step: step, tan: tan, tanh: tanh$1, all: all, any: any, argMax: argMax, argMin: argMin, logSumExp: logSumExp, max: max, mean: mean, min: min, moments: moments, sum: sum, equal: equal, equalStrict: equalStrict, greater: greater, greaterEqual: greaterEqual, greaterEqualStrict: greaterEqualStrict, greaterStrict: greaterStrict, less: less, lessEqual: lessEqual, lessEqualStrict: lessEqualStrict, lessStrict: lessStrict, notEqual: notEqual, notEqualStrict: notEqualStrict, add: add, addN: addN, addStrict: addStrict, atan2: atan2, div: div, divStrict: divStrict, floorDiv: floorDiv, maximum: maximum, maximumStrict: maximumStrict, minimum: minimum, minimumStrict: minimumStrict, mod: mod, modStrict: modStrict, mul: mul, mulStrict: mulStrict, pow: pow, powStrict: powStrict, squaredDifference: squaredDifference, squaredDifferenceStrict: squaredDifferenceStrict, sub: sub, subStrict: subStrict, elu: elu, leakyRelu: leakyRelu, prelu: prelu, relu: relu, selu: selu, logicalAnd: logicalAnd, logicalNot: logicalNot, logicalOr: logicalOr, logicalXor: logicalXor, where: where, whereAsync: whereAsync, buffer: buffer, toPixels: toPixels, print: print, batchToSpaceND: batchToSpaceND, cast: cast, clone: clone, cumsum: cumsum, depthToSpace: depthToSpace, expandDims: expandDims, eye: eye, fromPixels: fromPixels, multinomial: multinomial, oneHot: oneHot, pad: pad, pad1d: pad1d, pad2d: pad2d, pad3d: pad3d, pad4d: pad4d, rand: rand, randomNormal: randomNormal, randomUniform: randomUniform, reshape: reshape, spaceToBatchND: spaceToBatchND, squeeze: squeeze, stack: stack, tile: tile, truncatedNormal: truncatedNormal, unstack: unstack, fill: fill, linspace: linspace, ones: ones$1, range: range, scalar: scalar, tensor: tensor, tensor1d: tensor1d, tensor2d: tensor2d, tensor3d: tensor3d, tensor4d: tensor4d, tensor5d: tensor5d, tensor6d: tensor6d, zeros: zeros, onesLike: onesLike, zerosLike: zerosLike, transpose: transpose, softmax: softmax, localResponseNormalization: localResponseNormalization, norm: norm, gather: gather, unsortedSegmentSum: unsortedSegmentSum, basicLSTMCell: basicLSTMCell, multiRNNCell: multiRNNCell, movingAverage: movingAverage, stridedSlice: stridedSlice, topk: topk }),\n    MathBackendCPU = function () {\n  function e() {\n    this.blockSize = 48, this.data = new WeakMap(), this.firstUse = !0, ENV.get(\"IS_BROWSER\") && (this.canvas = document.createElement(\"canvas\"));\n  }return e.prototype.register = function (e, t, n) {\n    if (this.firstUse && (this.firstUse = !1, ENV.get(\"IS_NODE\") && warn(\"\\n============================\\nHi there 👋. Looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, which binds to TensorFlow C++, by running npm i @tensorflow/tfjs-node, or npm i @tensorflow/tfjs-node-gpu if you have CUDA. Then call require('@tensorflow/tfjs-node'); (-gpu suffix for CUDA) at the start of your program. Visit https://github.com/tensorflow/tfjs-node for more details.\\n============================\\n\")), this.data.has(e)) throw new Error(\"Data buffer is already registered\");this.data.set(e, { dtype: n });\n  }, e.prototype.write = function (e, t) {\n    if (null == t) throw new Error(\"MathBackendCPU.write(): values can not be null\");this.throwIfNoData(e), this.data.get(e).values = t;\n  }, e.prototype.fromPixels = function (e, t) {\n    if (null == e) throw new Error(\"pixels passed to tf.fromPixels() can not be null\");var n, r;if (ENV.get(\"IS_NODE\") && null == e.getContext) throw new Error(\"When running in node, pixels must be an HTMLCanvasElement like the one returned by the `canvas` npm package\");if (null != e.getContext) n = e.getContext(\"2d\").getImageData(0, 0, e.width, e.height).data;else if (e instanceof ImageData) n = e.data;else {\n      if (!(e instanceof HTMLImageElement || e instanceof HTMLVideoElement)) throw new Error(\"pixels passed to tf.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement or ImageData, but was \" + e.constructor.name);if (null == this.canvas) throw new Error(\"Can't read pixels from HTMLImageElement outside the browser.\");this.canvas.width = e.width, this.canvas.height = e.height, this.canvas.getContext(\"2d\").drawImage(e, 0, 0, e.width, e.height), n = this.canvas.getContext(\"2d\").getImageData(0, 0, e.width, e.height).data;\n    }if (4 === t) r = new Int32Array(n);else {\n      var o = e.width * e.height;r = new Int32Array(o * t);for (var a = 0; a < o; a++) for (var i = 0; i < t; ++i) r[a * t + i] = n[4 * a + i];\n    }return tensor3d(r, [e.height, e.width, t], \"int32\");\n  }, e.prototype.read = function (e) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (t) {\n        return [2, this.readSync(e)];\n      });\n    });\n  }, e.prototype.readSync = function (e) {\n    this.throwIfNoData(e);var t = this.data.get(e),\n        n = t.dtype,\n        r = t.complexTensors;return \"complex64\" === n ? mergeRealAndImagArrays(r.real.dataSync(), r.imag.dataSync()) : this.data.get(e).values;\n  }, e.prototype.disposeData = function (e) {\n    if (this.data.has(e)) {\n      var t = this.data.get(e).complexTensors;null != t && (t.real.dispose(), t.imag.dispose()), this.data.delete(e);\n    }\n  }, e.prototype.time = function (e) {\n    return __awaiter(this, void 0, void 0, function () {\n      var t;return __generator(this, function (n) {\n        return t = now(), e(), [2, { kernelMs: now() - t }];\n      });\n    });\n  }, e.prototype.memory = function () {\n    return { unreliable: !0 };\n  }, e.prototype.throwIfNoData = function (e) {\n    if (!this.data.has(e)) throw new Error(\"CPU backend: No data found for this tensor. Did you change your backend in the middle of the program? New backends can't use Tensors created with previous backends\");\n  }, e.prototype.complex = function (e, t) {\n    var n = Tensor.make(e.shape, {}, \"complex64\");return this.data.get(n.dataId).complexTensors = { real: ENV.engine.keep(e.clone()), imag: ENV.engine.keep(t.clone()) }, n;\n  }, e.prototype.real = function (e) {\n    return this.data.get(e.dataId).complexTensors.real.clone();\n  }, e.prototype.imag = function (e) {\n    return this.data.get(e.dataId).complexTensors.imag.clone();\n  }, e.prototype.assertNotComplex = function (e, t) {\n    Array.isArray(e) || (e = [e]), e.forEach(function (e) {\n      null != e && assert(\"complex64\" !== e.dtype, t + \" does not support complex64 tensors.\");\n    });\n  }, e.prototype.slice = function (e, t, n) {\n    this.assertNotComplex(e, \"slice\");for (var r = buffer(n, e.dtype), o = 0; o < r.size; ++o) {\n      var a = r.indexToLoc(o),\n          i = a.map(function (e, n) {\n        return e + t[n];\n      });r.set.apply(r, [e.get.apply(e, i)].concat(a));\n    }return r.toTensor();\n  }, e.prototype.stridedSlice = function (e, t, n, r, o, a, i, s, u) {\n    this.assertNotComplex(e, \"stridedSlice\");var l = getStridedSlicedInfo(e.shape, t, n, r, o, a, i, s, u),\n        c = l[0],\n        p = l[1],\n        d = l[2],\n        h = p.filter(function (e, t) {\n      return -1 === d.indexOf(t);\n    });if (h.some(function (e) {\n      return 0 === e;\n    })) return tensor([], h);for (var f = buffer(p, e.dtype), m = 0; m < f.size; m++) {\n      for (var g = f.indexToLoc(m), v = new Array(g.length), x = 0; x < v.length; x++) v[x] = g[x] * r[x] + c[x];f.set.apply(f, [e.get.apply(e, v)].concat(g));\n    }return f.toTensor().reshape(h);\n  }, e.prototype.reverse = function (e, t) {\n    this.assertNotComplex(e, \"reverse\");for (var n = buffer(e.shape, e.dtype), r = e.buffer(), o = function (o) {\n      var a = n.indexToLoc(o),\n          i = a.slice();t.forEach(function (t) {\n        return i[t] = e.shape[t] - 1 - i[t];\n      }), n.set.apply(n, [r.get.apply(r, i)].concat(a));\n    }, a = 0; a < n.size; a++) o(a);return n.toTensor();\n  }, e.prototype.concat = function (e, t) {\n    this.assertNotComplex(e, \"concat\");var n = e.map(function (e) {\n      var n = sizeFromShape(e.shape.slice(t));return e.as2D(-1, n);\n    }),\n        r = computeOutShape(n.map(function (e) {\n      return e.shape;\n    }), 1),\n        o = buffer(r, e[0].dtype).values;if (1 === n[0].shape[0]) {\n      var a = 0;n.forEach(function (e) {\n        o.set(e.dataSync(), a), a += e.size;\n      });\n    } else {\n      var i = 0;n.forEach(function (e) {\n        for (var t = e.dataSync(), n = 0, a = 0; a < e.shape[0]; ++a) for (var s = a * r[1] + i, u = 0; u < e.shape[1]; ++u) o[s + u] = t[n++];i += e.shape[1];\n      });\n    }var s = computeOutShape(e.map(function (e) {\n      return e.shape;\n    }), t);return tensor(o, s, e[0].dtype);\n  }, e.prototype.neg = function (e) {\n    return this.assertNotComplex(e, \"neg\"), this.multiply(scalar(-1), e);\n  }, e.prototype.add = function (e, t) {\n    return \"complex64\" === e.dtype || \"complex64\" === t.dtype ? this.broadcastedBinaryComplexOp(e.cast(\"complex64\"), t.cast(\"complex64\"), function (e, t, n, r) {\n      return { real: e + n, imag: t + r };\n    }) : this.broadcastedBinaryOp(e, t, upcastType(e.dtype, t.dtype), function (e, t) {\n      return e + t;\n    });\n  }, e.prototype.addN = function (e) {\n    this.assertNotComplex(e, \"addN\");for (var t = e.map(function (e) {\n      return e.dataSync();\n    }), n = buffer(e[0].shape, e[0].dtype), r = n.values, o = 0; o < e.length; o++) for (var a = t[o], i = 0; i < r.length; i++) r[i] += a[i];return n.toTensor();\n  }, e.prototype.subtract = function (e, t) {\n    return \"complex64\" === e.dtype || \"complex64\" === t.dtype ? this.broadcastedBinaryComplexOp(e.cast(\"complex64\"), t.cast(\"complex64\"), function (e, t, n, r) {\n      return { real: e - n, imag: t - r };\n    }) : this.broadcastedBinaryOp(e, t, upcastType(e.dtype, t.dtype), function (e, t) {\n      return e - t;\n    });\n  }, e.prototype.pow = function (e, t) {\n    return this.assertNotComplex([e, t], \"pow\"), this.broadcastedBinaryOp(e, t, e.dtype, function (e, t) {\n      return Math.pow(e, t);\n    });\n  }, e.prototype.batchMatMul = function (e, t, n, r) {\n    this.assertNotComplex([e, t], \"matMul\");for (var o = n ? e.shape[1] : e.shape[2], a = n ? e.shape[2] : e.shape[1], i = r ? t.shape[1] : t.shape[2], s = e.shape[0], u = e.dataSync(), l = t.dataSync(), c = n ? [e.strides[0], 1, e.strides[1]] : [e.strides[0], e.strides[1], 1], p = c[0], d = c[1], h = c[2], f = r ? [1, t.strides[1], t.strides[0]] : [t.strides[1], 1, t.strides[0]], m = f[0], g = f[1], v = f[2], x = a * i, y = new Float32Array(s * x), T = this.blockSize, b = 0; b < s; b++) for (var S = 0; S < a; S += T) for (var E = 0; E < i; E += T) for (var w = 0; w < o; w += T) for (var C = Math.min(S + T, a), A = Math.min(E + T, i), _ = Math.min(w + T, o), R = S; R < C; R++) for (var N = E; N < A; N++) {\n      for (var k = 0, I = w; I < _; I++) k += u[b * p + R * d + I * h] * l[I * m + N * g + b * v];y[b * x + (R * i + N)] += k;\n    }return tensor3d(y, [s, a, i]);\n  }, e.prototype.multiply = function (e, t) {\n    return \"complex64\" === e.dtype || \"complex64\" === t.dtype ? this.broadcastedBinaryComplexOp(e.cast(\"complex64\"), t.cast(\"complex64\"), function (e, t, n, r) {\n      return { real: e * n - t * r, imag: e * r + t * n };\n    }) : this.broadcastedBinaryOp(e, t, upcastType(e.dtype, t.dtype), function (e, t) {\n      return e * t;\n    });\n  }, e.prototype.realDivide = function (e, t) {\n    this.assertNotComplex([e, t], \"realDivide\");return this.broadcastedBinaryOp(e, t, \"float32\", function (e, t) {\n      return e / t;\n    });\n  }, e.prototype.floorDiv = function (e, t) {\n    this.assertNotComplex([e, t], \"floorDiv\");return this.broadcastedBinaryOp(e, t, \"int32\", function (e, t) {\n      return Math.floor(e / t);\n    });\n  }, e.prototype.sum = function (e, t) {\n    this.assertNotComplex(e, \"sum\"), assertAxesAreInnerMostDims(\"sum\", t, e.rank);for (var n = computeOutAndReduceShapes(e.shape, t), r = n[0], o = n[1], a = zeros(r, upcastType(e.dtype, \"int32\")), i = sizeFromShape(o), s = a.dataSync(), u = e.dataSync(), l = 0; l < s.length; ++l) {\n      for (var c = l * i, p = 0, d = 0; d < i; ++d) p += u[c + d];s[l] = p;\n    }return a;\n  }, e.prototype.unsortedSegmentSum = function (e, t, n) {\n    this.assertNotComplex(e, \"unsortedSegmentSum\");for (var r = [], o = e.rank - t.rank, a = 0; a < o; ++a) t = t.expandDims(a + 1);for (a = 0; a < n; ++a) {\n      var i = scalar(a, \"int32\"),\n          s = equal(i, t).asType(\"float32\").mul(e).sum(0);r.push(s);\n    }return stack(r);\n  }, e.prototype.argMin = function (e, t) {\n    this.assertNotComplex(e, \"argMin\");var n = [t];assertAxesAreInnerMostDims(\"argMin\", n, e.rank);for (var r = computeOutAndReduceShapes(e.shape, n), o = r[0], a = r[1], i = zeros(o, \"int32\"), s = sizeFromShape(a), u = i.dataSync(), l = e.dataSync(), c = 0; c < u.length; ++c) {\n      for (var p = c * s, d = l[p], h = 0, f = 0; f < s; ++f) {\n        var m = l[p + f];m < d && (d = m, h = f);\n      }u[c] = h;\n    }return i;\n  }, e.prototype.argMax = function (e, t) {\n    this.assertNotComplex(e, \"argMax\");var n = [t];assertAxesAreInnerMostDims(\"argMax\", n, e.rank);for (var r = computeOutAndReduceShapes(e.shape, n), o = r[0], a = r[1], i = zeros(o, \"int32\"), s = sizeFromShape(a), u = i.dataSync(), l = e.dataSync(), c = 0; c < u.length; ++c) {\n      for (var p = c * s, d = l[p], h = 0, f = 0; f < s; ++f) {\n        var m = l[p + f];m > d && (d = m, h = f);\n      }u[c] = h;\n    }return i;\n  }, e.prototype.cumsum = function (e, t, n, r) {\n    if (this.assertNotComplex(e, \"cumsum\"), t !== e.rank - 1) throw new Error(\"backend.cumsum in CPU expects an inner-most axis=\" + (e.rank - 1) + \" but got axis=\" + t);for (var o = upcastType(e.dtype, \"int32\"), a = zeros(e.shape, o), i = a.dataSync(), s = e.dataSync(), u = e.shape[e.rank - 1], l = r ? function (e, t) {\n      return e + u - t - 1;\n    } : function (e, t) {\n      return e + t;\n    }, c = 0; c < s.length; c += u) for (var p = 0; p < u; p++) {\n      var d = l(c, p);if (0 === p) i[d] = n ? 0 : s[d];else {\n        var h = l(c, p - 1);i[d] = n ? s[h] + i[h] : s[d] + i[h];\n      }\n    }return a;\n  }, e.prototype.equal = function (e, t) {\n    return this.assertNotComplex([e, t], \"equal\"), this.broadcastedBinaryOp(e, t, \"bool\", function (e, t) {\n      return e === t ? 1 : 0;\n    });\n  }, e.prototype.notEqual = function (e, t) {\n    return this.assertNotComplex([e, t], \"notEqual\"), this.broadcastedBinaryOp(e, t, \"bool\", function (e, t) {\n      return e !== t ? 1 : 0;\n    });\n  }, e.prototype.less = function (e, t) {\n    return this.assertNotComplex([e, t], \"less\"), this.broadcastedBinaryOp(e, t, \"bool\", function (e, t) {\n      return e < t ? 1 : 0;\n    });\n  }, e.prototype.lessEqual = function (e, t) {\n    return this.assertNotComplex([e, t], \"lessEqual\"), this.broadcastedBinaryOp(e, t, \"bool\", function (e, t) {\n      return e <= t ? 1 : 0;\n    });\n  }, e.prototype.greater = function (e, t) {\n    return this.assertNotComplex([e, t], \"greater\"), this.broadcastedBinaryOp(e, t, \"bool\", function (e, t) {\n      return e > t ? 1 : 0;\n    });\n  }, e.prototype.greaterEqual = function (e, t) {\n    return this.assertNotComplex([e, t], \"greaterEqual\"), this.broadcastedBinaryOp(e, t, \"bool\", function (e, t) {\n      return e >= t ? 1 : 0;\n    });\n  }, e.prototype.logicalNot = function (e) {\n    this.assertNotComplex(e, \"logicalNot\");for (var t = e.dataSync(), n = new Int32Array(t.length), r = 0; r < t.length; ++r) n[r] = t[r] ? 0 : 1;return Tensor.make(e.shape, { values: n }, \"bool\");\n  }, e.prototype.logicalAnd = function (e, t) {\n    return this.assertNotComplex([e, t], \"logicalAnd\"), this.broadcastedBinaryOp(e, t, \"bool\", function (e, t) {\n      return e && t;\n    });\n  }, e.prototype.logicalOr = function (e, t) {\n    return this.assertNotComplex([e, t], \"logicalOr\"), this.broadcastedBinaryOp(e, t, \"bool\", function (e, t) {\n      return e || t;\n    });\n  }, e.prototype.select = function (e, t, n) {\n    this.assertNotComplex([e, t, n], \"select\");for (var r = e.dataSync(), o = t.dataSync(), a = n.dataSync(), i = zeros(t.shape, upcastType(t.dtype, n.dtype)), s = i.dataSync(), u = 0, l = 0 === e.rank || e.rank > 1 || 1 === t.rank ? 1 : t.shape[1], c = 0; c < r.length; c++) for (var p = 0; p < l; p++) 1 === r[c] ? s[u++] = o[c] : s[u++] = a[c];return i;\n  }, e.prototype.where = function (e) {\n    this.assertNotComplex([e], \"where\");var t = e.dataSync();return whereImpl(e.shape, t);\n  }, e.prototype.topk = function (e, t, n) {\n    return this.assertNotComplex(e, \"topk\"), topkImpl(e.dataSync(), e.shape, e.dtype, t, n);\n  }, e.prototype.min = function (e, t) {\n    this.assertNotComplex(e, \"min\"), assertAxesAreInnerMostDims(\"min\", t, e.rank);for (var n = computeOutAndReduceShapes(e.shape, t), r = n[0], o = n[1], a = zeros(r, e.dtype), i = sizeFromShape(o), s = a.dataSync(), u = e.dataSync(), l = 0; l < s.length; ++l) {\n      for (var c = l * i, p = u[c], d = 0; d < i; ++d) {\n        var h = u[c + d];h < p && (p = h);\n      }s[l] = p;\n    }return a;\n  }, e.prototype.minimum = function (e, t) {\n    return this.assertNotComplex([e, t], \"minimum\"), this.broadcastedBinaryOp(e, t, e.dtype, function (e, t) {\n      return Math.min(e, t);\n    });\n  }, e.prototype.mod = function (e, t) {\n    return this.assertNotComplex([e, t], \"mod\"), this.broadcastedBinaryOp(e, t, e.dtype, function (e, t) {\n      var n = e % t;return e < 0 && t < 0 || e >= 0 && t >= 0 ? n : (n + t) % t;\n    });\n  }, e.prototype.max = function (e, t) {\n    this.assertNotComplex(e, \"max\"), assertAxesAreInnerMostDims(\"max\", t, e.rank);for (var n = computeOutAndReduceShapes(e.shape, t), r = n[0], o = n[1], a = zeros(r, e.dtype), i = sizeFromShape(o), s = a.dataSync(), u = e.dataSync(), l = 0; l < s.length; ++l) {\n      for (var c = l * i, p = u[c], d = 0; d < i; ++d) {\n        var h = u[c + d];h > p && (p = h);\n      }s[l] = p;\n    }return a;\n  }, e.prototype.maximum = function (e, t) {\n    return this.assertNotComplex([e, t], \"maximum\"), this.broadcastedBinaryOp(e, t, e.dtype, function (e, t) {\n      return Math.max(e, t);\n    });\n  }, e.prototype.all = function (e, t) {\n    this.assertNotComplex(e, \"all\"), assertAxesAreInnerMostDims(\"all\", t, e.rank);for (var n = computeOutAndReduceShapes(e.shape, t), r = n[0], o = n[1], a = zeros(r, e.dtype), i = sizeFromShape(o), s = a.dataSync(), u = e.dataSync(), l = 0; l < s.length; ++l) {\n      for (var c = l * i, p = u[c], d = 0; d < i; ++d) {\n        var h = u[c + d];p = p && h;\n      }s[l] = p;\n    }return a;\n  }, e.prototype.any = function (e, t) {\n    this.assertNotComplex(e, \"any\"), assertAxesAreInnerMostDims(\"any\", t, e.rank);for (var n = computeOutAndReduceShapes(e.shape, t), r = n[0], o = n[1], a = zeros(r, e.dtype), i = sizeFromShape(o), s = a.dataSync(), u = e.dataSync(), l = 0; l < s.length; ++l) {\n      for (var c = l * i, p = u[c], d = 0; d < i; ++d) {\n        var h = u[c + d];p = p || h;\n      }s[l] = p;\n    }return a;\n  }, e.prototype.squaredDifference = function (e, t) {\n    return this.assertNotComplex([e, t], \"squaredDifference\"), this.broadcastedBinaryOp(e, t, e.dtype, function (e, t) {\n      var n = e - t;return n * n;\n    });\n  }, e.prototype.ceil = function (e) {\n    this.assertNotComplex(e, \"ceil\");for (var t = e.dataSync(), n = new Float32Array(t.length), r = 0; r < t.length; ++r) n[r] = Math.ceil(t[r]);return Tensor.make(e.shape, { values: n });\n  }, e.prototype.floor = function (e) {\n    this.assertNotComplex(e, \"floor\");for (var t = e.dataSync(), n = new Float32Array(t.length), r = 0; r < t.length; ++r) n[r] = Math.floor(t[r]);return Tensor.make(e.shape, { values: n });\n  }, e.prototype.sign = function (e) {\n    this.assertNotComplex(e, \"x\");for (var t = e.dataSync(), n = new Float32Array(t.length), r = 0; r < t.length; ++r) t[r] < 0 ? n[r] = -1 : t[r] > 0 ? n[r] = 1 : n[r] = 0;return Tensor.make(e.shape, { values: n });\n  }, e.prototype.round = function (e) {\n    this.assertNotComplex(e, \"round\");for (var t = e.dataSync(), n = new Float32Array(t.length), r = 0; r < t.length; ++r) {\n      var o = Math.floor(t[r]);t[r] - o < .5 ? n[r] = Math.floor(t[r]) : t[r] - o > .5 ? n[r] = Math.ceil(t[r]) : n[r] = o % 2 == 0 ? o : o + 1;\n    }return Tensor.make(e.shape, { values: n });\n  }, e.prototype.exp = function (e) {\n    this.assertNotComplex(e, \"exp\");for (var t = e.dataSync(), n = new Float32Array(t.length), r = 0; r < t.length; ++r) n[r] = Math.exp(t[r]);return Tensor.make(e.shape, { values: n });\n  }, e.prototype.expm1 = function (e) {\n    this.assertNotComplex(e, \"expm1\");for (var t = e.dataSync(), n = new Float32Array(t.length), r = 0; r < t.length; ++r) n[r] = Math.expm1(t[r]);return Tensor.make(e.shape, { values: n });\n  }, e.prototype.log = function (e) {\n    this.assertNotComplex(e, \"log\");for (var t = e.dataSync(), n = new Float32Array(t.length), r = 0; r < t.length; ++r) {\n      var o = t[r];n[r] = Math.log(o);\n    }return Tensor.make(e.shape, { values: n });\n  }, e.prototype.log1p = function (e) {\n    this.assertNotComplex(e, \"log1p\");for (var t = e.dataSync(), n = new Float32Array(t.length), r = 0; r < t.length; ++r) {\n      var o = t[r];n[r] = Math.log1p(o);\n    }return Tensor.make(e.shape, { values: n });\n  }, e.prototype.sqrt = function (e) {\n    this.assertNotComplex(e, \"sqrt\");for (var t = e.dataSync(), n = new Float32Array(t.length), r = 0; r < t.length; ++r) {\n      var o = t[r];n[r] = Math.sqrt(o);\n    }return Tensor.make(e.shape, { values: n });\n  }, e.prototype.rsqrt = function (e) {\n    this.assertNotComplex(e, \"rsqrt\");for (var t = e.dataSync(), n = new Float32Array(t.length), r = 0; r < t.length; ++r) {\n      var o = t[r];n[r] = 1 / Math.sqrt(o);\n    }return Tensor.make(e.shape, { values: n });\n  }, e.prototype.square = function (e) {\n    this.assertNotComplex(e, \"square\");for (var t = e.dataSync(), n = new Float32Array(t.length), r = 0; r < t.length; ++r) {\n      var o = t[r];n[r] = o * o;\n    }return Tensor.make(e.shape, { values: n });\n  }, e.prototype.reciprocal = function (e) {\n    this.assertNotComplex(e, \"reciprocal\");for (var t = e.dataSync(), n = new Float32Array(t.length), r = 0; r < t.length; ++r) n[r] = 1 / t[r];return Tensor.make(e.shape, { values: n });\n  }, e.prototype.relu = function (e) {\n    this.assertNotComplex(e, \"relu\");for (var t = zeros(e.shape, e.dtype), n = t.dataSync(), r = e.dataSync(), o = 0; o < r.length; ++o) n[o] = Math.max(0, r[o]);return t;\n  }, e.prototype.elu = function (e) {\n    this.assertNotComplex(e, \"elu\");for (var t = new Float32Array(e.size), n = e.dataSync(), r = 0; r < n.length; ++r) {\n      var o = n[r];t[r] = o >= 0 ? o : Math.exp(o) - 1;\n    }return Tensor.make(e.shape, { values: t });\n  }, e.prototype.eluDer = function (e, t) {\n    this.assertNotComplex([e, t], \"eluDer\");for (var n = new Float32Array(t.size), r = t.dataSync(), o = e.dataSync(), a = 0; a < r.length; ++a) {\n      var i = r[a];n[a] = i >= 1 ? o[a] : o[a] * (i + 1);\n    }return Tensor.make(t.shape, { values: n });\n  }, e.prototype.selu = function (e) {\n    this.assertNotComplex(e, \"selu\");for (var t = SELU_SCALEALPHA, n = SELU_SCALE, r = new Float32Array(e.size), o = e.dataSync(), a = 0; a < o.length; ++a) {\n      var i = o[a];r[a] = i >= 0 ? n * i : t * (Math.exp(i) - 1);\n    }return Tensor.make(e.shape, { values: r });\n  }, e.prototype.clip = function (e, t, n) {\n    this.assertNotComplex(e, \"clip\");for (var r = new Float32Array(e.size), o = e.dataSync(), a = 0; a < o.length; ++a) {\n      var i = o[a];r[a] = i > n ? n : i < t ? t : i;\n    }return Tensor.make(e.shape, { values: r });\n  }, e.prototype.abs = function (e) {\n    this.assertNotComplex(e, \"abs\");for (var t = new Float32Array(e.size), n = e.dataSync(), r = 0; r < n.length; ++r) t[r] = Math.abs(n[r]);return Tensor.make(e.shape, { values: t });\n  }, e.prototype.int = function (e) {\n    this.assertNotComplex(e, \"int\");for (var t = new Int32Array(e.size), n = e.dataSync(), r = 0; r < n.length; ++r) t[r] = n[r];return Tensor.make(e.shape, { values: t }, \"int32\");\n  }, e.prototype.sigmoid = function (e) {\n    this.assertNotComplex(e, \"sigmoid\");for (var t = new Float32Array(e.size), n = e.dataSync(), r = 0; r < n.length; ++r) t[r] = 1 / (1 + Math.exp(-n[r]));return Tensor.make(e.shape, { values: t });\n  }, e.prototype.softplus = function (e) {\n    this.assertNotComplex(e, \"softplus\");for (var t = Math.log(1.1920928955078125e-7) + 2, n = new Float32Array(e.size), r = e.dataSync(), o = 0; o < r.length; ++o) {\n      var a = r[o] > -t,\n          i = r[o] < t,\n          s = Math.exp(r[o]),\n          u = void 0;u = i ? s : a ? r[o] : Math.log(1 + s), n[o] = u;\n    }return Tensor.make(e.shape, { values: n });\n  }, e.prototype.sin = function (e) {\n    this.assertNotComplex(e, \"sin\");for (var t = new Float32Array(e.size), n = e.dataSync(), r = 0; r < n.length; ++r) t[r] = Math.sin(n[r]);return Tensor.make(e.shape, { values: t });\n  }, e.prototype.cos = function (e) {\n    this.assertNotComplex(e, \"cos\");for (var t = new Float32Array(e.size), n = e.dataSync(), r = 0; r < n.length; ++r) t[r] = Math.cos(n[r]);return Tensor.make(e.shape, { values: t });\n  }, e.prototype.tan = function (e) {\n    this.assertNotComplex(e, \"tan\");for (var t = new Float32Array(e.size), n = e.dataSync(), r = 0; r < n.length; ++r) t[r] = Math.tan(n[r]);return Tensor.make(e.shape, { values: t });\n  }, e.prototype.asin = function (e) {\n    this.assertNotComplex(e, \"asin\");for (var t = new Float32Array(e.size), n = e.dataSync(), r = 0; r < n.length; ++r) t[r] = Math.asin(n[r]);return Tensor.make(e.shape, { values: t });\n  }, e.prototype.acos = function (e) {\n    this.assertNotComplex(e, \"acos\");for (var t = new Float32Array(e.size), n = e.dataSync(), r = 0; r < n.length; ++r) t[r] = Math.acos(n[r]);return Tensor.make(e.shape, { values: t });\n  }, e.prototype.atan = function (e) {\n    this.assertNotComplex(e, \"atan\");for (var t = new Float32Array(e.size), n = e.dataSync(), r = 0; r < n.length; ++r) t[r] = Math.atan(n[r]);return Tensor.make(e.shape, { values: t });\n  }, e.prototype.atan2 = function (e, t) {\n    return this.assertNotComplex([e, t], \"atan2\"), this.broadcastedBinaryOp(e, t, e.dtype, function (e, t) {\n      return Math.atan2(e, t);\n    });\n  }, e.prototype.sinh = function (e) {\n    this.assertNotComplex(e, \"sinh\");for (var t = new Float32Array(e.size), n = e.dataSync(), r = 0; r < n.length; ++r) t[r] = Math.sinh(n[r]);return Tensor.make(e.shape, { values: t });\n  }, e.prototype.cosh = function (e) {\n    this.assertNotComplex(e, \"cosh\");for (var t = new Float32Array(e.size), n = e.dataSync(), r = 0; r < n.length; ++r) t[r] = Math.cosh(n[r]);return Tensor.make(e.shape, { values: t });\n  }, e.prototype.tanh = function (e) {\n    this.assertNotComplex(e, \"tanh\");for (var t = new Float32Array(e.size), n = e.dataSync(), r = 0; r < n.length; ++r) t[r] = tanh(n[r]);return Tensor.make(e.shape, { values: t });\n  }, e.prototype.asinh = function (e) {\n    this.assertNotComplex(e, \"asinh\");for (var t = new Float32Array(e.size), n = e.dataSync(), r = 0; r < n.length; ++r) t[r] = Math.asinh(n[r]);return Tensor.make(e.shape, { values: t });\n  }, e.prototype.acosh = function (e) {\n    this.assertNotComplex(e, \"acosh\");for (var t = new Float32Array(e.size), n = e.dataSync(), r = 0; r < n.length; ++r) t[r] = Math.acosh(n[r]);return Tensor.make(e.shape, { values: t });\n  }, e.prototype.atanh = function (e) {\n    this.assertNotComplex(e, \"atanh\");for (var t = new Float32Array(e.size), n = e.dataSync(), r = 0; r < n.length; ++r) t[r] = Math.atanh(n[r]);return Tensor.make(e.shape, { values: t });\n  }, e.prototype.erf = function (e) {\n    this.assertNotComplex(e, \"erf\");for (var t = new Float32Array(e.size), n = e.dataSync(), r = ERF_P, o = ERF_A1, a = ERF_A2, i = ERF_A3, s = ERF_A4, u = ERF_A5, l = 0; l < n.length; ++l) {\n      var c = n[l],\n          p = 1 / (1 + r * c);t[l] = 1 - ((((u * p + s) * p + i) * p + a) * p + o) * p * Math.exp(-c * c);\n    }return Tensor.make(e.shape, { values: t });\n  }, e.prototype.step = function (e, t) {\n    void 0 === t && (t = 0), this.assertNotComplex(e, \"step\");for (var n = new Float32Array(e.size), r = e.dataSync(), o = 0; o < r.length; ++o) {\n      var a = r[o];isNaN(a) ? n[o] = NaN : n[o] = a > 0 ? 1 : t;\n    }return Tensor.make(e.shape, { values: n });\n  }, e.prototype.conv2d = function (e, t, n) {\n    this.assertNotComplex([e, t], \"conv2d\");for (var r = n.filterHeight, o = n.filterWidth, a = n.dilationHeight, i = n.dilationWidth, s = n.padInfo.left, u = n.padInfo.top, l = buffer(n.outShape, e.dtype), c = e.dataSync(), p = t.dataSync(), d = l.values, h = 0; h < n.batchSize; ++h) for (var f = h * e.strides[0], m = h * l.strides[0], g = 0; g < n.outHeight; ++g) for (var v = m + g * l.strides[1], x = g * n.strideHeight - s, y = 0; y < r; y++) {\n      var T = x + y * a;if (!(T < 0 || T >= n.inHeight)) for (var b = y * t.strides[0], S = f + T * e.strides[1], E = 0; E < n.outWidth; ++E) for (var w = v + E * n.outChannels, C = E * n.strideWidth - u, A = 0; A < o; A++) {\n        var _ = C + A * i;if (!(_ < 0 || _ >= n.inWidth)) for (var R = b + A * t.strides[1], N = S + _ * n.inChannels, k = R, I = 0; I < n.inChannels; ++I) {\n          for (var D = c[N + I], M = 0; M < n.outChannels; ++M) d[w + M] += D * p[k + M];k += n.outChannels;\n        }\n      }\n    }return l.toTensor();\n  }, e.prototype.conv2dDerInput = function (e, t, n) {\n    this.assertNotComplex([e, t], \"conv2dDerInput\");for (var r = buffer(n.inShape, \"float32\"), o = r.values, a = r.strides, i = a[0], s = a[1], u = a[2], l = e.dataSync(), c = e.strides, p = c[0], d = c[1], h = c[2], f = t.dataSync(), m = t.strides, g = m[0], v = m[1], x = m[2], y = n.batchSize, T = n.filterHeight, b = n.filterWidth, S = n.inChannels, E = n.inHeight, w = n.inWidth, C = n.outChannels, A = n.outHeight, _ = n.outWidth, R = n.strideHeight, N = n.strideWidth, k = T - 1 - n.padInfo.top, I = b - 1 - n.padInfo.left, D = 0; D < y; ++D) for (var M = 0; M < S; ++M) for (var O = 0; O < E; ++O) for (var P = O - k, F = Math.max(0, Math.ceil(P / R)), L = Math.min(A, (T + P) / R), B = 0; B < w; ++B) {\n      for (var U = B - I, z = Math.max(0, Math.ceil(U / N)), V = Math.min(_, (b + U) / N), H = 0, G = F; G < L; ++G) for (var W = G * R - P, q = z; q < V; ++q) for (var $ = p * D + d * G + h * q, X = g * (T - 1 - W) + v * (b - 1 - (q * N - U)) + x * M, K = 0; K < C; ++K) {\n        H += l[$ + K] * f[X + K];\n      }o[i * D + s * O + u * B + M] = H;\n    }return r.toTensor();\n  }, e.prototype.conv2dDerFilter = function (e, t, n) {\n    this.assertNotComplex([e, t], \"conv2dDerFilter\");for (var r = n.strideHeight, o = n.strideWidth, a = n.filterHeight, i = n.filterWidth, s = buffer(n.filterShape, \"float32\"), u = n.padInfo.left, l = n.padInfo.top, c = 0; c < a; ++c) for (var p = Math.max(0, Math.ceil((l - c) / r)), d = Math.min(n.outHeight, (n.inHeight + l - c) / r), h = 0; h < i; ++h) for (var f = Math.max(0, Math.ceil((u - h) / o)), m = Math.min(n.outWidth, (n.inWidth + u - h) / o), g = 0; g < n.inChannels; ++g) for (var v = 0; v < n.outChannels; ++v) {\n      for (var x = 0, y = 0; y < n.batchSize; ++y) for (var T = p; T < d; ++T) for (var b = c + T * r - l, S = f; S < m; ++S) {\n        var E = h + S * o - u;x += e.get(y, b, E, g) * t.get(y, T, S, v);\n      }s.set(x, c, h, g, v);\n    }return s.toTensor();\n  }, e.prototype.depthwiseConv2D = function (e, t, n) {\n    this.assertNotComplex([e, t], \"depthwiseConv2D\");for (var r = n.filterHeight, o = n.filterWidth, a = n.dilationHeight, i = n.dilationWidth, s = n.padInfo.left, u = n.padInfo.top, l = n.outChannels / n.inChannels, c = buffer(n.outShape, e.dtype), p = e.dataSync(), d = t.dataSync(), h = c.values, f = 0; f < n.batchSize; ++f) for (var m = f * e.strides[0], g = f * c.strides[0], v = 0; v < n.outHeight; ++v) for (var x = g + v * c.strides[1], y = v * n.strideHeight - s, T = 0; T < r; ++T) {\n      var b = y + T * a;if (!(b < 0 || b >= n.inHeight)) for (var S = T * t.strides[0], E = m + b * e.strides[1], w = 0; w < n.outWidth; ++w) for (var C = x + w * c.strides[2], A = w * n.strideWidth - u, _ = 0; _ < o; ++_) {\n        var R = A + _ * i;if (!(R < 0 || R >= n.inWidth)) for (var N = S + _ * t.strides[1], k = E + R * n.inChannels, I = C, D = N, M = 0; M < n.inChannels; ++M) {\n          for (var O = p[k + M], P = 0; P < l; ++P) h[I + P] += O * d[D + P];I += l, D += l;\n        }\n      }\n    }return c.toTensor();\n  }, e.prototype.depthwiseConv2DDerInput = function (e, t, n) {\n    this.assertNotComplex([e, t], \"depthwiseConv2DDerInput\");for (var r = buffer(n.inShape, \"float32\"), o = r.values, a = r.strides, i = a[0], s = a[1], u = a[2], l = e.dataSync(), c = e.strides, p = c[0], d = c[1], h = c[2], f = t.dataSync(), m = t.strides, g = m[0], v = m[1], x = m[2], y = n.batchSize, T = n.filterHeight, b = n.filterWidth, S = n.inChannels, E = n.inHeight, w = n.inWidth, C = n.outChannels, A = n.outHeight, _ = n.outWidth, R = n.strideHeight, N = n.strideWidth, k = T - 1 - n.padInfo.top, I = b - 1 - n.padInfo.left, D = C / S, M = 0; M < y; ++M) for (var O = 0; O < S; ++O) for (var P = 0; P < E; ++P) for (var F = P - k, L = Math.max(0, Math.ceil(F / R)), B = Math.min(A, (T + F) / R), U = 0; U < w; ++U) {\n      for (var z = U - I, V = Math.max(0, Math.ceil(z / N)), H = Math.min(_, (b + z) / N), G = 0, W = L; W < B; ++W) for (var q = W * R - F, $ = V; $ < H; ++$) for (var X = p * M + d * W + h * $, K = g * (T - 1 - q) + v * (b - 1 - ($ * N - z)) + x * O, j = 0; j < D; ++j) {\n        G += l[X + (O * D + j)] * f[K + j];\n      }o[i * M + s * P + u * U + O] = G;\n    }return r.toTensor();\n  }, e.prototype.depthwiseConv2DDerFilter = function (e, t, n) {\n    this.assertNotComplex([e, t], \"depthwiseConv2DDerFilter\");for (var r = n.strideHeight, o = n.strideWidth, a = n.filterHeight, i = n.filterWidth, s = buffer(n.filterShape, \"float32\"), u = n.padInfo.left, l = n.padInfo.top, c = n.outChannels / n.inChannels, p = 0; p < a; ++p) for (var d = Math.max(0, Math.ceil((l - p) / r)), h = Math.min(n.outHeight, (n.inHeight + l - p) / r), f = 0; f < i; ++f) for (var m = Math.max(0, Math.ceil((u - f) / o)), g = Math.min(n.outWidth, (n.inWidth + u - f) / o), v = 0; v < n.outChannels; ++v) {\n      for (var x = Math.trunc(v / c), y = v % c, T = 0, b = 0; b < n.batchSize; ++b) for (var S = d; S < h; ++S) for (var E = p + S * r - l, w = m; w < g; ++w) {\n        var C = f + w * o - u;T += e.get(b, E, C, x) * t.get(b, S, w, v);\n      }s.set(T, p, f, x, y);\n    }return s.toTensor();\n  }, e.prototype.tile = function (e, t) {\n    this.assertNotComplex(e, \"tile\");for (var n = new Array(e.rank), r = 0; r < n.length; r++) n[r] = e.shape[r] * t[r];var o = buffer(n, e.dtype),\n        a = e.buffer();for (r = 0; r < o.values.length; ++r) {\n      for (var i = o.indexToLoc(r), s = new Array(e.rank), u = 0; u < s.length; u++) s[u] = i[u] % e.shape[u];var l = a.locToIndex(s);o.values[r] = a.values[l];\n    }return o.toTensor();\n  }, e.prototype.pad = function (e, t, n) {\n    this.assertNotComplex(e, \"pad\");var r = t.map(function (t, n) {\n      return t[0] + e.shape[n] + t[1];\n    }),\n        o = t.map(function (e) {\n      return e[0];\n    }),\n        a = e.buffer(),\n        i = buffer(r, e.dtype);0 !== n && i.values.fill(n);for (var s = 0; s < e.size; s++) {\n      var u = a.indexToLoc(s),\n          l = u.map(function (e, t) {\n        return e + o[t];\n      });i.set.apply(i, [e.get.apply(e, u)].concat(l));\n    }return i.toTensor();\n  }, e.prototype.transpose = function (e, t) {\n    this.assertNotComplex(e, \"transpose\");for (var n = new Array(e.rank), r = 0; r < n.length; r++) n[r] = e.shape[t[r]];var o = e.dataSync(),\n        a = buffer(n, e.dtype),\n        i = e.buffer();for (r = 0; r < e.size; ++r) {\n      for (var s = i.indexToLoc(r), u = new Array(s.length), l = 0; l < u.length; l++) u[l] = s[t[l]];var c = a.locToIndex(u);a.values[c] = o[r];\n    }return a.toTensor();\n  }, e.prototype.gather = function (e, t, n) {\n    this.assertNotComplex([e, t], \"gather\");var r = e.shape.slice(),\n        o = t.dataSync();r[n] = o.length;for (var a = buffer(r, e.dtype), i = e.buffer(), s = 0; s < a.size; ++s) {\n      var u = a.indexToLoc(s),\n          l = u.slice();l[n] = o[u[n]];var c = i.locToIndex(l);a.values[s] = i.values[c];\n    }return a.toTensor();\n  }, e.prototype.batchToSpaceND = function (e, t, n) {\n    this.assertNotComplex([e], \"batchToSpaceND\");var r = t.reduce(function (e, t) {\n      return e * t;\n    }),\n        o = getReshaped(e.shape, t, r),\n        a = getPermuted(o.length, t.length),\n        i = getReshapedPermuted(e.shape, t, r),\n        s = getSliceBeginCoords(n, t.length),\n        u = getSliceSize(i, n, t.length);return e.reshape(o).transpose(a).reshape(i).slice(s, u);\n  }, e.prototype.spaceToBatchND = function (e, t, n) {\n    this.assertNotComplex([e], \"spaceToBatchND\");var r = t.reduce(function (e, t) {\n      return e * t;\n    }),\n        o = [[0, 0]];o.push.apply(o, n);for (var a = 1 + t.length; a < e.shape.length; ++a) o.push([0, 0]);var i = e.pad(o),\n        s = getReshaped(i.shape, t, r, !1),\n        u = getPermuted(s.length, t.length, !1),\n        l = getReshapedPermuted(i.shape, t, r, !1);return i.reshape(s).transpose(u).reshape(l);\n  }, e.prototype.pool = function (e, t, n) {\n    this.assertNotComplex(e, \"pool\");for (var r = t.strideHeight, o = t.strideWidth, a = t.filterHeight, i = t.filterWidth, s = buffer(t.outShape, \"float32\"), u = t.padInfo.top, l = t.padInfo.left, c = \"max\" === n ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY, p = 0; p < t.batchSize; ++p) for (var d = 0; d < t.inChannels; ++d) for (var h = 0; h < t.outHeight; ++h) for (var f = h * r - u, m = Math.max(0, f), g = Math.min(t.inHeight, a + f), v = 0; v < t.outWidth; ++v) {\n      for (var x = v * o - l, y = Math.max(0, x), T = Math.min(t.inWidth, i + x), b = c, S = 0, E = 0, w = m; w < g; ++w) {\n        for (var C = y; C < T; ++C) {\n          var A = e.get(p, w, C, d);\"max\" === n && A > b ? b = A : \"avg\" === n && (S += A, E++);\n        }if (isNaN(b)) break;\n      }s.set(\"avg\" === n ? S / E : b, p, h, v, d);\n    }return s.toTensor();\n  }, e.prototype.maxPool = function (e, t) {\n    return this.pool(e, t, \"max\");\n  }, e.prototype.maxPoolPositions = function (e, t) {\n    for (var n = buffer(t.outShape, \"int32\"), r = t.strideHeight, o = t.strideWidth, a = t.filterHeight, i = t.filterWidth, s = t.padInfo.top, u = t.padInfo.left, l = 0; l < t.batchSize; ++l) for (var c = 0; c < t.inChannels; ++c) for (var p = 0; p < t.outHeight; ++p) for (var d = p * r - s, h = Math.max(0, d), f = Math.min(t.inHeight, a + d), m = 0; m < t.outWidth; ++m) {\n      for (var g = m * o - u, v = Math.max(0, g), x = Math.min(t.inWidth, i + g), y = Number.NEGATIVE_INFINITY, T = -1, b = h; b < f; ++b) for (var S = b - d, E = v; E < x; ++E) {\n        var w = E - g,\n            C = e.get(l, b, E, c);C > y && (y = C, T = S * i + w);\n      }n.set(T, l, p, m, c);\n    }return n.toTensor();\n  }, e.prototype.maxPoolBackprop = function (e, t, n, r) {\n    this.assertNotComplex([t, n], \"maxPoolBackprop\");for (var o = this.maxPoolPositions(t, r), a = r.strideHeight, i = r.strideWidth, s = r.filterHeight, u = r.filterWidth, l = u - 1 - r.padInfo.left, c = s - 1 - r.padInfo.top, p = buffer(t.shape, \"float32\"), d = 0; d < r.batchSize; ++d) for (var h = 0; h < r.inChannels; ++h) for (var f = 0; f < r.inHeight; ++f) for (var m = 0; m < r.inWidth; ++m) {\n      for (var g = f - c, v = m - l, x = 0, y = 0; y < s; ++y) {\n        var T = (g + y) / a;if (!(T < 0 || T >= r.outHeight || Math.floor(T) !== T)) for (var b = 0; b < u; ++b) {\n          var S = (v + b) / i;if (!(S < 0 || S >= r.outWidth || Math.floor(S) !== S)) {\n            var E = s * u - 1 - o.get(d, T, S, h) === y * u + b ? 1 : 0;if (0 !== E) x += e.get(d, T, S, h) * E;\n          }\n        }\n      }p.set(x, d, f, m, h);\n    }return p.toTensor();\n  }, e.prototype.avgPoolBackprop = function (e, t, n) {\n    this.assertNotComplex([e, t], \"avgPoolBackprop\");for (var r = n.strideHeight, o = n.strideWidth, a = n.filterHeight, i = n.filterWidth, s = i - 1 - n.padInfo.left, u = a - 1 - n.padInfo.top, l = buffer(t.shape, \"float32\"), c = 1 / (a * i), p = 0; p < n.batchSize; ++p) for (var d = 0; d < n.inChannels; ++d) for (var h = 0; h < n.inHeight; ++h) for (var f = 0; f < n.inWidth; ++f) {\n      for (var m = h - u, g = f - s, v = 0, x = 0; x < a; ++x) {\n        var y = (m + x) / r;if (!(y < 0 || y >= n.outHeight || Math.floor(y) !== y)) for (var T = 0; T < i; ++T) {\n          var b = (g + T) / o;if (!(b < 0 || b >= n.outWidth || Math.floor(b) !== b)) v += e.get(p, y, b, d);\n        }\n      }l.set(v * c, p, h, f, d);\n    }return l.toTensor();\n  }, e.prototype.cast = function (e, t) {\n    return castTensor(e, t, this);\n  }, e.prototype.reshape = function (e, t) {\n    return reshapeTensor(e, t);\n  }, e.prototype.avgPool = function (e, t) {\n    return this.assertNotComplex(e, \"avgPool\"), this.pool(e, t, \"avg\").toFloat();\n  }, e.prototype.resizeBilinear = function (e, t, n, r) {\n    this.assertNotComplex(e, \"resizeBilinear\");for (var o = e.shape, a = o[0], i = o[1], s = o[2], u = o[3], l = buffer([a, t, n, u], e.dtype), c = [r && t > 1 ? i - 1 : i, r && n > 1 ? s - 1 : s], p = [r && t > 1 ? t - 1 : t, r && n > 1 ? n - 1 : n], d = 0; d < a; d++) for (var h = 0; h < t; h++) for (var f = 0; f < n; f++) for (var m = 0; m < u; m++) {\n      var g = c[0] * h / p[0],\n          v = c[1] * f / p[1],\n          x = Math.floor(g),\n          y = Math.min(i - 1, Math.ceil(g)),\n          T = Math.floor(v),\n          b = Math.min(s - 1, Math.ceil(v)),\n          S = e.get(d, x, T, m),\n          E = e.get(d, y, T, m),\n          w = v - T,\n          C = S + (e.get(d, x, b, m) - S) * w,\n          A = C + (E + (e.get(d, y, b, m) - E) * w - C) * (g - x);l.set(A, d, h, f, m);\n    }return l.toTensor();\n  }, e.prototype.resizeBilinearBackprop = function (e, t, n) {\n    this.assertNotComplex([e, t], \"resizeBilinearBackprop\");for (var r = t.shape, o = r[0], a = r[1], i = r[2], s = r[3], u = e.shape, l = u[1], c = u[2], p = buffer([o, a, i, s], t.dtype), d = [n && l > 1 ? a - 1 : a, n && c > 1 ? i - 1 : i], h = [n && l > 1 ? l - 1 : l, n && c > 1 ? c - 1 : c], f = d[0] / h[0], m = d[1] / h[1], g = 0; g < o; g++) for (var v = 0; v < l; v++) for (var x = v * f, y = Math.floor(x), T = Math.min(Math.ceil(x), a - 1), b = x - y, S = 1 - b, E = 0; E < c; E++) for (var w = E * m, C = Math.floor(w), A = Math.min(Math.ceil(w), i - 1), _ = w - C, R = 1 - _, N = 0; N < s; N++) {\n      var k = e.get(g, v, E, N),\n          I = p.get(g, y, C, N);I += k * S * R, p.set(I, g, y, C, N);var D = p.get(g, y, A, N);D += k * S * _, p.set(D, g, y, A, N);var M = p.get(g, T, C, N);M += k * b * R, p.set(M, g, T, C, N);var O = p.get(g, T, A, N);O += k * b * _, p.set(O, g, T, A, N);\n    }return p.toTensor();\n  }, e.prototype.resizeNearestNeighbor = function (e, t, n, r) {\n    this.assertNotComplex(e, \"resizeNearestNeighbor\");for (var o = e.shape, a = o[0], i = o[1], s = o[2], u = o[3], l = buffer([a, t, n, u], e.dtype), c = [r && t > 1 ? i - 1 : i, r && n > 1 ? s - 1 : s], p = [r && t > 1 ? t - 1 : t, r && n > 1 ? n - 1 : n], d = 0; d < a; d++) for (var h = 0; h < t; h++) for (var f = 0; f < n; f++) for (var m = 0; m < u; m++) {\n      var g = c[0] * h / p[0],\n          v = c[1] * f / p[1],\n          x = Math.min(i - 1, r ? Math.round(g) : Math.floor(g)),\n          y = Math.min(s - 1, r ? Math.round(v) : Math.floor(v)),\n          T = e.get(d, x, y, m);l.set(T, d, h, f, m);\n    }return l.toTensor();\n  }, e.prototype.resizeNearestNeighborBackprop = function (e, t, n) {\n    this.assertNotComplex([e, t], \"resizeNearestNeighborBackprop\");for (var r = t.shape, o = r[0], a = r[1], i = r[2], s = r[3], u = e.shape, l = u[1], c = u[2], p = buffer([o, a, i, s], t.dtype), d = [n && l > 1 ? a - 1 : a, n && c > 1 ? i - 1 : i], h = [n && l > 1 ? l - 1 : l, n && c > 1 ? c - 1 : c], f = 1 / (d[0] / h[0]), m = 1 / (d[1] / h[1]), g = 2 * Math.ceil(f) + 2, v = 2 * Math.ceil(m) + 2, x = 0; x < o; x++) for (var y = 0; y < a; y++) for (var T = 0; T < i; T++) for (var b = Math.floor(y * f), S = Math.floor(b - g / 2), E = Math.floor(T * m), w = Math.floor(E - v / 2), C = 0; C < s; C++) {\n      for (var A = 0, _ = 0; _ < g; _++) {\n        var R = _ + S;if (!(R < 0 || R >= l)) for (var N = 0; N < v; N++) {\n          var k = N + w;if (!(k < 0 || k >= c)) {\n            var I = d[0] * (R / h[0]),\n                D = d[1] * (k / h[1]),\n                M = Math.min(a - 1, n ? Math.round(I) : Math.floor(I)),\n                O = Math.min(i - 1, n ? Math.round(D) : Math.floor(D));y === M && T === O && (A += e.get(x, R, k, C));\n          }\n        }\n      }p.set(A, x, y, T, C);\n    }return p.toTensor();\n  }, e.prototype.batchNormalization = function (e, t, n, r, o, a) {\n    this.assertNotComplex([e, t, n, o, a], \"batchNormalization\");for (var i = e.dataSync(), s = t.dataSync(), u = n.dataSync(), l = o ? o.dataSync() : new Float32Array([1]), c = a ? a.dataSync() : new Float32Array([0]), p = new Float32Array(i.length), d = c.length, h = l.length, f = u.length, m = s.length, g = 0, v = 0, x = 0, y = 0, T = 0; T < i.length; ++T) p[T] = c[g++] + (i[T] - s[v++]) * l[x++] / Math.sqrt(u[y++] + r), g >= d && (g = 0), v >= m && (v = 0), x >= h && (x = 0), y >= f && (y = 0);return tensor4d(p, e.shape);\n  }, e.prototype.localResponseNormalization4D = function (e, t, n, r, o) {\n    this.assertNotComplex(e, \"localResponseNormalization4D\");var a = e.shape[3],\n        i = a - 1,\n        s = e.dataSync(),\n        u = sizeFromShape(e.shape),\n        l = new Float32Array(u);function c(e) {\n      for (var n = e % a, r = e - n + Math.max(0, n - t), o = e - n + Math.min(n + t, i), u = 0; r <= o; r++) {\n        var l = s[r];u += l * l;\n      }return u;\n    }for (var p = 0; p < u; p++) {\n      var d = c(p),\n          h = s[p] * Math.pow(n + r * d, -o);l[p] = h;\n    }return tensor4d(l, e.shape);\n  }, e.prototype.LRNGrad = function (e, t, n, r, o, a, i) {\n    this.assertNotComplex(e, \"LRNGrad\");for (var s = e.shape[3], u = e.dataSync(), l = t.dataSync(), c = n.dataSync(), p = new Float32Array(sizeFromShape(e.shape)), d = sizeFromShape(e.shape), h = 0; h < d; h++) {\n      for (var f = h % s, m = h - f + Math.max(0, f - r), g = h - f + Math.min(s, f + r + 1), v = 0, x = m; x < g; x++) v += Math.pow(l[x], 2);v = a * v + o;for (x = m; x < g; x++) {\n        var y = -2 * a * i * l[x] * c[h] / v;h === x && (y += Math.pow(v, -i)), y *= u[h], p[x] += y;\n      }\n    }return tensor4d(p, e.shape);\n  }, e.prototype.multinomial = function (e, t, n, r) {\n    this.assertNotComplex(e, \"multinomial\");for (var o = t ? e : softmax(e), a = o.shape[0], i = o.shape[1], s = zeros([a, n], \"int32\"), u = s.dataSync(), l = o.dataSync(), c = 0; c < a; ++c) {\n      var p = c * i,\n          d = new Float32Array(i - 1);d[0] = l[p];for (var h = 1; h < d.length; ++h) d[h] = d[h - 1] + l[p + h];for (var f = seedrandom_1(r.toString()), m = c * n, g = 0; g < n; ++g) {\n        var v = f();u[m + g] = d.length;for (var x = 0; x < d.length; x++) if (v < d[x]) {\n          u[m + g] = x;break;\n        }\n      }\n    }return s;\n  }, e.prototype.oneHot = function (e, t, n, r) {\n    this.assertNotComplex(e, \"oneHot\");var o = new Float32Array(e.size * t);o.fill(r);for (var a = 0; a < e.size; ++a) e.get(a) >= 0 && e.get(a) < t && (o[a * t + e.get(a)] = n);return tensor2d(o, [e.size, t], \"int32\");\n  }, e.prototype.nonMaxSuppression = function (e, t, n, r, o) {\n    return this.assertNotComplex(e, \"nonMaxSuppression\"), nonMaxSuppressionImpl(e.dataSync(), t.dataSync(), n, r, o);\n  }, e.prototype.depthToSpace = function (e, t, n) {\n    assert(\"NHWC\" === n, \"Only NHWC dataFormat supported on CPU for depthToSpace. Got \" + n), assert(t > 1, \"blockSize should be > 1 for depthToSpace, but was: \" + t);for (var r = e.shape[0], o = e.shape[1], a = e.shape[2], i = e.shape[3], s = o * t, u = a * t, l = i / (t * t), c = e.dataSync(), p = new Float32Array(r * s * u * l), d = 0, h = 0; h < r; ++h) for (var f = 0; f < s; ++f) for (var m = Math.floor(f / t), g = f % t, v = 0; v < u; ++v) for (var x = Math.floor(v / t), y = (g * t + v % t) * l, T = 0; T < l; ++T) {\n      var b = T + y + i * (x + a * (m + o * h));p[d++] = c[b];\n    }return tensor4d(p, [r, s, u, l]);\n  }, e.prototype.broadcastedBinaryOp = function (e, t, n, r) {\n    var o = assertAndGetBroadcastShape(e.shape, t.shape),\n        a = buffer(o, n),\n        i = e.dataSync(),\n        s = t.dataSync(),\n        u = getBroadcastDims(e.shape, o),\n        l = getBroadcastDims(t.shape, o),\n        c = a.values;if (u.length + l.length === 0) for (var p = 0; p < c.length; ++p) c[p] = r(i[p % i.length], s[p % s.length]);else {\n      var d = e.buffer(),\n          h = t.buffer(),\n          f = function (n) {\n        var o = a.indexToLoc(n),\n            p = o.slice(-e.rank);u.forEach(function (e) {\n          return p[e] = 0;\n        });var f = d.locToIndex(p),\n            m = o.slice(-t.rank);l.forEach(function (e) {\n          return m[e] = 0;\n        });var g = h.locToIndex(m);c[n] = r(i[f], s[g]);\n      };for (p = 0; p < c.length; ++p) f(p);\n    }return a.toTensor();\n  }, e.prototype.broadcastedBinaryComplexOp = function (e, t, n) {\n    var r = assertAndGetBroadcastShape(e.shape, t.shape),\n        o = buffer(r, \"float32\"),\n        a = buffer(r, \"float32\"),\n        i = e.dataSync(),\n        s = t.dataSync(),\n        u = getBroadcastDims(e.shape, r),\n        l = getBroadcastDims(t.shape, r),\n        c = o.values,\n        p = a.values;if (u.length + l.length === 0) for (var d = 0; d < c.length; d++) {\n      var h = d % i.length,\n          f = d % s.length,\n          m = n(i[2 * h], i[2 * h + 1], s[2 * f], s[2 * f + 1]);c[d] = m.real, p[d] = m.imag;\n    } else {\n      var g = this.data.get(e.dataId).complexTensors.real.buffer(),\n          v = this.data.get(t.dataId).complexTensors.real.buffer(),\n          x = function (r) {\n        var a = o.indexToLoc(r),\n            d = a.slice(-e.rank);u.forEach(function (e) {\n          return d[e] = 0;\n        });var h = g.locToIndex(d),\n            f = a.slice(-t.rank);l.forEach(function (e) {\n          return f[e] = 0;\n        });var m = v.locToIndex(f),\n            x = n(i[2 * h], i[2 * h + 1], s[2 * m], s[2 * m + 1]);c[r] = x.real, p[r] = x.imag;\n      };for (d = 0; d < c.length; d++) x(d);\n    }return this.complex(o.toTensor(), a.toTensor());\n  }, e.prototype.split = function (e, t, n) {\n    return split(e, t, n);\n  }, e.prototype.dispose = function () {}, e.prototype.floatPrecision = function () {\n    return 32;\n  }, e.prototype.cropAndResize = function (e, t, n, r, o, a) {\n    for (var i = e.shape, s = i[0], u = i[1], l = i[2], c = i[3], p = t.shape[0], d = r[0], h = r[1], f = buffer([p, d, h, c]), m = t.dataSync(), g = n.dataSync(), v = e.dataSync(), x = e.strides, y = f.strides, T = 0; T < p; T++) {\n      var b = 4 * T,\n          S = m[b],\n          E = m[b + 1],\n          w = m[b + 2],\n          C = m[b + 3],\n          A = g[T];if (!(A >= s)) for (var _ = d > 1 ? (w - S) * (u - 1) / (d - 1) : 0, R = h > 1 ? (C - E) * (l - 1) / (h - 1) : 0, N = 0; N < d; N++) {\n        var k = d > 1 ? S * (u - 1) + N * _ : .5 * (S + w) * (u - 1);if (k < 0 || k > u - 1) for (var I = 0; I < h; I++) for (var D = 0; D < c; D++) {\n          var M = D + I * y[2] + N * y[1] + T * y[0];f.values[M] = a;\n        } else if (\"bilinear\" === o) {\n          var O = Math.floor(k),\n              P = Math.ceil(k),\n              F = k - O;for (I = 0; I < h; I++) {\n            if ((q = h > 1 ? E * (l - 1) + I * R : .5 * (E + C) * (l - 1)) < 0 || q > l - 1) for (D = 0; D < c; D++) {\n              M = D + I * y[2] + N * y[1] + T * y[0];f.values[M] = a;\n            } else {\n              var L = Math.floor(q),\n                  B = Math.ceil(q),\n                  U = q - L;for (D = 0; D < c; D++) {\n                var z = v[M = D + L * x[2] + O * x[1] + A * x[0]],\n                    V = v[M = D + B * x[2] + O * x[1] + A * x[0]],\n                    H = v[M = D + L * x[2] + P * x[1] + A * x[0]],\n                    G = z + (V - z) * U,\n                    W = H + (v[M = D + B * x[2] + P * x[1] + A * x[0]] - H) * U;M = D + I * y[2] + N * y[1] + T * y[0], f.values[M] = G + (W - G) * F;\n              }\n            }\n          }\n        } else for (I = 0; I < h; ++I) {\n          var q;if ((q = h > 1 ? E * (l - 1) + I * R : .5 * (E + C) * (l - 1)) < 0 || q > l - 1) for (D = 0; D < c; D++) {\n            M = D + I * y[2] + N * y[1] + T * y[0];f.values[M] = a;\n          } else {\n            var $ = Math.round(q),\n                X = Math.round(k);for (D = 0; D < c; D++) {\n              var K = D + $ * x[2] + X * x[1] + A * x[0],\n                  j = D + I * y[2] + N * y[1] + T * y[0];f.values[j] = v[K];\n            }\n          }\n        }\n      }\n    }return f.toTensor();\n  }, e;\n}();ENV.registerBackend(\"cpu\", function () {\n  return new MathBackendCPU();\n}, 1, setTensorTracker);var delayCallback = \"undefined\" != typeof requestAnimationFrame ? requestAnimationFrame : setImmediate;function nextFrame() {\n  return new Promise(function (e) {\n    return delayCallback(function () {\n      return e();\n    });\n  });\n}var DTYPE_VALUE_SIZE_MAP = { float32: 4, int32: 4, uint16: 2, uint8: 1, bool: 1 };function encodeWeights(e) {\n  return __awaiter(this, void 0, void 0, function () {\n    var t, n, r, o;return __generator(this, function (a) {\n      switch (a.label) {case 0:\n          for (r in t = [], n = [], e) {\n            if (\"float32\" !== (o = e[r]).dtype && \"int32\" !== o.dtype && \"bool\" !== o.dtype) throw new Error(\"Unsupported dtype in weight '\" + r + \"': \" + o.dtype);t.push({ name: r, shape: o.shape, dtype: o.dtype }), n.push(o.data());\n          }return [4, Promise.all(n)];case 1:\n          return [2, { data: concatenateTypedArrays(a.sent()), specs: t }];}\n    });\n  });\n}function decodeWeights(e, t) {\n  for (var n = {}, r = 0, o = function (t) {\n    var o = t.name,\n        a = t.dtype,\n        i = t.shape,\n        s = sizeFromShape(i),\n        u = void 0;if ((\"quantization\" in t)) {\n      var l = t.quantization;if (\"uint8\" !== l.dtype && \"uint16\" !== l.dtype) throw new Error(\"Weight \" + t.name + \" has unknown quantization dtype \" + l.dtype + \". Supported quantization dtypes are: 'uint8' and 'uint16'.\");var c = DTYPE_VALUE_SIZE_MAP[l.dtype],\n          p = e.slice(r, r + s * c),\n          d = \"uint8\" === l.dtype ? new Uint8Array(p) : new Uint16Array(p);if (\"float32\" === a) u = Float32Array.from(d, function (e) {\n        return e * l.scale + l.min;\n      });else {\n        if (\"int32\" !== a) throw new Error(\"Unsupported dtype in weight '\" + o + \"': \" + a);u = Int32Array.from(d, function (e) {\n          return Math.round(e * l.scale + l.min);\n        });\n      }r += s * c;\n    } else {\n      var h = DTYPE_VALUE_SIZE_MAP[a];p = e.slice(r, r + s * h);if (\"float32\" === a) u = new Float32Array(p);else if (\"int32\" === a) u = new Int32Array(p);else {\n        if (\"bool\" !== a) throw new Error(\"Unsupported dtype in weight '\" + o + \"': \" + a);u = new Uint8Array(p);\n      }r += s * h;\n    }var f = void 0;if (\"float32\" === a) f = tensor(u, i, \"float32\");else if (\"int32\" === a) f = tensor(u, i, \"int32\");else {\n      if (\"bool\" !== a) throw new Error(\"Unsupported dtype in weight '\" + o + \"': \" + a);f = tensor(u, i, \"bool\");\n    }n[o] = f;\n  }, a = 0, i = t; a < i.length; a++) {\n    o(i[a]);\n  }return n;\n}function concatenateTypedArrays(e) {\n  if (null === e) throw new Error(\"Invalid input value: \" + JSON.stringify(e));var t = 0,\n      n = [];e.forEach(function (e) {\n    if (t += e.byteLength, n.push(e.byteLength === e.buffer.byteLength ? e : new e.constructor(e)), !(e instanceof Float32Array || e instanceof Int32Array || e instanceof Uint8Array)) throw new Error(\"Unsupported TypedArray subtype: \" + e.constructor.name);\n  });var r = new Uint8Array(t),\n      o = 0;return n.forEach(function (e) {\n    r.set(new Uint8Array(e.buffer), o), o += e.byteLength;\n  }), r.buffer;\n}var useNodeBuffer = \"undefined\" != typeof Buffer && (\"undefined\" == typeof Blob || \"undefined\" == typeof atob || \"undefined\" == typeof btoa);function stringByteLength(e) {\n  return useNodeBuffer ? Buffer.byteLength(e) : new Blob([e]).size;\n}function arrayBufferToBase64String(e) {\n  return useNodeBuffer ? Buffer.from(e).toString(\"base64\") : btoa(String.fromCharCode.apply(null, new Uint8Array(e)));\n}function base64StringToArrayBuffer(e) {\n  if (useNodeBuffer) {\n    var t = Buffer.from(e, \"base64\");return t.buffer.slice(t.byteOffset, t.byteOffset + t.byteLength);\n  }for (var n = atob(e), r = new Uint8Array(n.length), o = 0; o < n.length; ++o) r.set([n.charCodeAt(o)], o);return r.buffer;\n}function concatenateArrayBuffers(e) {\n  var t = 0;e.forEach(function (e) {\n    t += e.byteLength;\n  });var n = new Uint8Array(t),\n      r = 0;return e.forEach(function (e) {\n    n.set(new Uint8Array(e), r), r += e.byteLength;\n  }), n.buffer;\n}function basename(e) {\n  for (e = e.trim(); e.endsWith(\"/\");) e = e.slice(0, e.length - 1);var t = e.split(\"/\");return t[t.length - 1];\n}function getModelArtifactsInfoForJSON(e) {\n  if (e.modelTopology instanceof ArrayBuffer) throw new Error(\"Expected JSON model topology, received ArrayBuffer.\");return { dateSaved: new Date(), modelTopologyType: \"JSON\", modelTopologyBytes: null == e.modelTopology ? 0 : stringByteLength(JSON.stringify(e.modelTopology)), weightSpecsBytes: null == e.weightSpecs ? 0 : stringByteLength(JSON.stringify(e.weightSpecs)), weightDataBytes: null == e.weightData ? 0 : e.weightData.byteLength };\n}var IORouterRegistry = function () {\n  function e() {\n    this.saveRouters = [], this.loadRouters = [];\n  }return e.getInstance = function () {\n    return null == e.instance && (e.instance = new e()), e.instance;\n  }, e.registerSaveRouter = function (t) {\n    e.getInstance().saveRouters.push(t);\n  }, e.registerLoadRouter = function (t) {\n    e.getInstance().loadRouters.push(t);\n  }, e.getSaveHandlers = function (t) {\n    return e.getHandlers(t, \"save\");\n  }, e.getLoadHandlers = function (t) {\n    return e.getHandlers(t, \"load\");\n  }, e.getHandlers = function (e, t) {\n    var n = [];return (\"load\" === t ? this.getInstance().loadRouters : this.getInstance().saveRouters).forEach(function (t) {\n      var r = t(e);null !== r && n.push(r);\n    }), n;\n  }, e;\n}(),\n    URL_SCHEME_SUFFIX = \"://\",\n    ModelStoreManagerRegistry = function () {\n  function e() {\n    this.managers = {};\n  }return e.getInstance = function () {\n    return null == e.instance && (e.instance = new e()), e.instance;\n  }, e.registerManager = function (t, n) {\n    assert(null != t, \"scheme must not be undefined or null.\"), t.endsWith(URL_SCHEME_SUFFIX) && (t = t.slice(0, t.indexOf(URL_SCHEME_SUFFIX))), assert(t.length > 0, \"scheme must not be an empty string.\");var r = e.getInstance();assert(null == r.managers[t], \"A model store manager is already registered for scheme '\" + t + \"'.\"), r.managers[t] = n;\n  }, e.getManager = function (e) {\n    var t = this.getInstance().managers[e];if (null == t) throw new Error(\"Cannot find model manager for scheme '\" + e + \"'\");return t;\n  }, e.getSchemes = function () {\n    return Object.keys(this.getInstance().managers);\n  }, e;\n}();function parseURL(e) {\n  if (-1 === e.indexOf(URL_SCHEME_SUFFIX)) throw new Error(\"The url string provided does not contain a scheme. Supported schemes are: \" + ModelStoreManagerRegistry.getSchemes().join(\",\"));return { scheme: e.split(URL_SCHEME_SUFFIX)[0], path: e.split(URL_SCHEME_SUFFIX)[1] };\n}function cloneModelInternal(e, t, n) {\n  return void 0 === n && (n = !1), __awaiter(this, void 0, void 0, function () {\n    var r, o, a, i, s, u, l, c, p;return __generator(this, function (d) {\n      switch (d.label) {case 0:\n          return assert(e !== t, \"Old path and new path are the same: '\" + e + \"'\"), assert((r = IORouterRegistry.getLoadHandlers(e)).length > 0, \"Copying failed because no load handler is found for source URL \" + e + \".\"), assert(r.length < 2, \"Copying failed because more than one (\" + r.length + \") load handlers for source URL \" + e + \".\"), o = r[0], assert((a = IORouterRegistry.getSaveHandlers(t)).length > 0, \"Copying failed because no save handler is found for destination URL \" + t + \".\"), assert(a.length < 2, \"Copying failed because more than one (\" + r.length + \") save handlers for destination URL \" + t + \".\"), i = a[0], s = parseURL(e).scheme, u = parseURL(e).path, l = s === parseURL(e).scheme, [4, o.load()];case 1:\n          return c = d.sent(), n && l ? [4, ModelStoreManagerRegistry.getManager(s).removeModel(u)] : [3, 3];case 2:\n          d.sent(), d.label = 3;case 3:\n          return [4, i.save(c)];case 4:\n          return p = d.sent(), !n || l ? [3, 6] : [4, ModelStoreManagerRegistry.getManager(s).removeModel(u)];case 5:\n          d.sent(), d.label = 6;case 6:\n          return [2, p.modelArtifactsInfo];}\n    });\n  });\n}function listModels() {\n  return __awaiter(this, void 0, void 0, function () {\n    var e, t, n, r, o, a, i;return __generator(this, function (s) {\n      switch (s.label) {case 0:\n          e = ModelStoreManagerRegistry.getSchemes(), t = {}, n = 0, r = e, s.label = 1;case 1:\n          return n < r.length ? (o = r[n], [4, ModelStoreManagerRegistry.getManager(o).listModels()]) : [3, 4];case 2:\n          for (i in a = s.sent()) t[o + URL_SCHEME_SUFFIX + i] = a[i];s.label = 3;case 3:\n          return n++, [3, 1];case 4:\n          return [2, t];}\n    });\n  });\n}function removeModel(e) {\n  return __awaiter(this, void 0, void 0, function () {\n    var t;return __generator(this, function (n) {\n      switch (n.label) {case 0:\n          return t = parseURL(e), [4, ModelStoreManagerRegistry.getManager(t.scheme).removeModel(t.path)];case 1:\n          return [2, n.sent()];}\n    });\n  });\n}function copyModel(e, t) {\n  return __awaiter(this, void 0, void 0, function () {\n    return __generator(this, function (n) {\n      switch (n.label) {case 0:\n          return [4, cloneModelInternal(e, t, !1)];case 1:\n          return [2, n.sent()];}\n    });\n  });\n}function moveModel(e, t) {\n  return __awaiter(this, void 0, void 0, function () {\n    return __generator(this, function (n) {\n      switch (n.label) {case 0:\n          return [4, cloneModelInternal(e, t, !0)];case 1:\n          return [2, n.sent()];}\n    });\n  });\n}var DATABASE_NAME = \"tensorflowjs\",\n    DATABASE_VERSION = 1,\n    MODEL_STORE_NAME = \"models_store\",\n    INFO_STORE_NAME = \"model_info_store\";function getIndexedDBFactory() {\n  if (!ENV.get(\"IS_BROWSER\")) throw new Error(\"Failed to obtain IndexedDB factory because the current environmentis not a web browser.\");var e = window,\n      t = e.indexedDB || e.mozIndexedDB || e.webkitIndexedDB || e.msIndexedDB || e.shimIndexedDB;if (null == t) throw new Error(\"The current browser does not appear to support IndexedDB.\");return t;\n}function setUpDatabase(e) {\n  var t = e.result;t.createObjectStore(MODEL_STORE_NAME, { keyPath: \"modelPath\" }), t.createObjectStore(INFO_STORE_NAME, { keyPath: \"modelPath\" });\n}var BrowserIndexedDB = function () {\n  function e(e) {\n    if (this.indexedDB = getIndexedDBFactory(), null == e || !e) throw new Error(\"For IndexedDB, modelPath must not be null, undefined or empty.\");this.modelPath = e;\n  }return e.prototype.save = function (e) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (t) {\n        if (e.modelTopology instanceof ArrayBuffer) throw new Error(\"BrowserLocalStorage.save() does not support saving model topology in binary formats yet.\");return [2, this.databaseAction(this.modelPath, e)];\n      });\n    });\n  }, e.prototype.load = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (e) {\n        return [2, this.databaseAction(this.modelPath)];\n      });\n    });\n  }, e.prototype.databaseAction = function (e, t) {\n    var n = this;return new Promise(function (e, r) {\n      var o = n.indexedDB.open(DATABASE_NAME, DATABASE_VERSION);o.onupgradeneeded = function () {\n        return setUpDatabase(o);\n      }, o.onsuccess = function () {\n        var a = o.result;if (null == t) {\n          var i = a.transaction(MODEL_STORE_NAME, \"readonly\"),\n              s = i.objectStore(MODEL_STORE_NAME).get(n.modelPath);s.onsuccess = function () {\n            if (null == s.result) return a.close(), r(new Error(\"Cannot find model with path '\" + n.modelPath + \"' in IndexedDB.\"));e(s.result.modelArtifacts);\n          }, s.onerror = function (e) {\n            return a.close(), r(s.error);\n          }, i.oncomplete = function () {\n            return a.close();\n          };\n        } else {\n          var u,\n              l = getModelArtifactsInfoForJSON(t),\n              c = a.transaction(INFO_STORE_NAME, \"readwrite\"),\n              p = c.objectStore(INFO_STORE_NAME),\n              d = p.put({ modelPath: n.modelPath, modelArtifactsInfo: l });d.onsuccess = function () {\n            var o = (u = a.transaction(MODEL_STORE_NAME, \"readwrite\")).objectStore(MODEL_STORE_NAME).put({ modelPath: n.modelPath, modelArtifacts: t, modelArtifactsInfo: l });o.onsuccess = function () {\n              return e({ modelArtifactsInfo: l });\n            }, o.onerror = function (e) {\n              var t = (p = c.objectStore(INFO_STORE_NAME)).delete(n.modelPath);t.onsuccess = function () {\n                return a.close(), r(o.error);\n              }, t.onerror = function (e) {\n                return a.close(), r(o.error);\n              };\n            };\n          }, d.onerror = function (e) {\n            return a.close(), r(d.error);\n          }, c.oncomplete = function () {\n            null == u ? a.close() : u.oncomplete = function () {\n              return a.close();\n            };\n          };\n        }\n      }, o.onerror = function (e) {\n        return r(o.error);\n      };\n    });\n  }, e.URL_SCHEME = \"indexeddb://\", e;\n}(),\n    indexedDBRouter = function (e) {\n  return ENV.get(\"IS_BROWSER\") && !Array.isArray(e) && e.startsWith(BrowserIndexedDB.URL_SCHEME) ? browserIndexedDB(e.slice(BrowserIndexedDB.URL_SCHEME.length)) : null;\n};function browserIndexedDB(e) {\n  return new BrowserIndexedDB(e);\n}function maybeStripScheme(e) {\n  return e.startsWith(BrowserIndexedDB.URL_SCHEME) ? e.slice(BrowserIndexedDB.URL_SCHEME.length) : e;\n}IORouterRegistry.registerSaveRouter(indexedDBRouter), IORouterRegistry.registerLoadRouter(indexedDBRouter);var BrowserIndexedDBManager = function () {\n  function e() {\n    this.indexedDB = getIndexedDBFactory();\n  }return e.prototype.listModels = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var e = this;return __generator(this, function (t) {\n        return [2, new Promise(function (t, n) {\n          var r = e.indexedDB.open(DATABASE_NAME, DATABASE_VERSION);r.onupgradeneeded = function () {\n            return setUpDatabase(r);\n          }, r.onsuccess = function () {\n            var e = r.result,\n                o = e.transaction(INFO_STORE_NAME, \"readonly\"),\n                a = o.objectStore(INFO_STORE_NAME).getAll();a.onsuccess = function () {\n              for (var e = {}, n = 0, r = a.result; n < r.length; n++) {\n                var o = r[n];e[o.modelPath] = o.modelArtifactsInfo;\n              }t(e);\n            }, a.onerror = function (t) {\n              return e.close(), n(a.error);\n            }, o.oncomplete = function () {\n              return e.close();\n            };\n          }, r.onerror = function (e) {\n            return n(r.error);\n          };\n        })];\n      });\n    });\n  }, e.prototype.removeModel = function (e) {\n    return __awaiter(this, void 0, void 0, function () {\n      var t = this;return __generator(this, function (n) {\n        return e = maybeStripScheme(e), [2, new Promise(function (n, r) {\n          var o = t.indexedDB.open(DATABASE_NAME, DATABASE_VERSION);o.onupgradeneeded = function () {\n            return setUpDatabase(o);\n          }, o.onsuccess = function () {\n            var t,\n                a = o.result,\n                i = a.transaction(INFO_STORE_NAME, \"readwrite\"),\n                s = i.objectStore(INFO_STORE_NAME),\n                u = s.get(e);u.onsuccess = function () {\n              if (null == u.result) return a.close(), r(new Error(\"Cannot find model with path '\" + e + \"' in IndexedDB.\"));var o = s.delete(e),\n                  i = function () {\n                var o = (t = a.transaction(MODEL_STORE_NAME, \"readwrite\")).objectStore(MODEL_STORE_NAME).delete(e);o.onsuccess = function () {\n                  return n(u.result.modelArtifactsInfo);\n                }, o.onerror = function (e) {\n                  return r(u.error);\n                };\n              };o.onsuccess = i, o.onerror = function (e) {\n                return i(), a.close(), r(u.error);\n              };\n            }, u.onerror = function (e) {\n              return a.close(), r(u.error);\n            }, i.oncomplete = function () {\n              null == t ? a.close() : t.oncomplete = function () {\n                return a.close();\n              };\n            };\n          }, o.onerror = function (e) {\n            return r(o.error);\n          };\n        })];\n      });\n    });\n  }, e;\n}();if (ENV.get(\"IS_BROWSER\")) try {\n  ModelStoreManagerRegistry.registerManager(BrowserIndexedDB.URL_SCHEME, new BrowserIndexedDBManager());\n} catch (e) {}var PATH_SEPARATOR = \"/\",\n    PATH_PREFIX = \"tensorflowjs_models\",\n    INFO_SUFFIX = \"info\",\n    MODEL_TOPOLOGY_SUFFIX = \"model_topology\",\n    WEIGHT_SPECS_SUFFIX = \"weight_specs\",\n    WEIGHT_DATA_SUFFIX = \"weight_data\";function getModelKeys(e) {\n  return { info: [PATH_PREFIX, e, INFO_SUFFIX].join(PATH_SEPARATOR), topology: [PATH_PREFIX, e, MODEL_TOPOLOGY_SUFFIX].join(PATH_SEPARATOR), weightSpecs: [PATH_PREFIX, e, WEIGHT_SPECS_SUFFIX].join(PATH_SEPARATOR), weightData: [PATH_PREFIX, e, WEIGHT_DATA_SUFFIX].join(PATH_SEPARATOR) };\n}function getModelPathFromKey(e) {\n  var t = e.split(PATH_SEPARATOR);if (t.length < 3) throw new Error(\"Invalid key format: \" + e);return t.slice(1, t.length - 1).join(PATH_SEPARATOR);\n}function maybeStripScheme$1(e) {\n  return e.startsWith(BrowserLocalStorage.URL_SCHEME) ? e.slice(BrowserLocalStorage.URL_SCHEME.length) : e;\n}var BrowserLocalStorage = function () {\n  function e(e) {\n    if (!ENV.get(\"IS_BROWSER\") || void 0 === window.localStorage) throw new Error(\"The current environment does not support local storage.\");if (this.LS = window.localStorage, null == e || !e) throw new Error(\"For local storage, modelPath must not be null, undefined or empty.\");this.modelPath = e, this.keys = getModelKeys(this.modelPath);\n  }return e.prototype.save = function (e) {\n    return __awaiter(this, void 0, void 0, function () {\n      var t, n, r, o;return __generator(this, function (a) {\n        if (e.modelTopology instanceof ArrayBuffer) throw new Error(\"BrowserLocalStorage.save() does not support saving model topology in binary formats yet.\");t = JSON.stringify(e.modelTopology), n = JSON.stringify(e.weightSpecs), r = getModelArtifactsInfoForJSON(e);try {\n          return this.LS.setItem(this.keys.info, JSON.stringify(r)), this.LS.setItem(this.keys.topology, t), this.LS.setItem(this.keys.weightSpecs, n), this.LS.setItem(this.keys.weightData, arrayBufferToBase64String(e.weightData)), [2, { modelArtifactsInfo: r }];\n        } catch (e) {\n          for (o in this.keys) this.LS.removeItem(this.keys[o]);throw new Error(\"Failed to save model '\" + this.modelPath + \"' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=\" + r.modelTopologyBytes + \", weightSpecsBytes=\" + r.weightSpecsBytes + \", weightDataBytes=\" + r.weightDataBytes + \".\");\n        }return [2];\n      });\n    });\n  }, e.prototype.load = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var e, t, n, r, o;return __generator(this, function (a) {\n        if (null == (e = JSON.parse(this.LS.getItem(this.keys.info)))) throw new Error(\"In local storage, there is no model with name '\" + this.modelPath + \"'\");if (\"JSON\" !== e.modelTopologyType) throw new Error(\"BrowserLocalStorage does not support loading non-JSON model topology yet.\");if (t = {}, null == (n = JSON.parse(this.LS.getItem(this.keys.topology)))) throw new Error(\"In local storage, the topology of model '\" + this.modelPath + \"' is missing.\");if (t.modelTopology = n, null == (r = JSON.parse(this.LS.getItem(this.keys.weightSpecs)))) throw new Error(\"In local storage, the weight specs of model '\" + this.modelPath + \"' are missing.\");if (t.weightSpecs = r, null == (o = this.LS.getItem(this.keys.weightData))) throw new Error(\"In local storage, the binary weight values of model '\" + this.modelPath + \"' are missing.\");return t.weightData = base64StringToArrayBuffer(o), [2, t];\n      });\n    });\n  }, e.URL_SCHEME = \"localstorage://\", e;\n}(),\n    localStorageRouter = function (e) {\n  return ENV.get(\"IS_BROWSER\") && !Array.isArray(e) && e.startsWith(BrowserLocalStorage.URL_SCHEME) ? browserLocalStorage(e.slice(BrowserLocalStorage.URL_SCHEME.length)) : null;\n};function browserLocalStorage(e) {\n  return new BrowserLocalStorage(e);\n}IORouterRegistry.registerSaveRouter(localStorageRouter), IORouterRegistry.registerLoadRouter(localStorageRouter);var BrowserLocalStorageManager = function () {\n  function e() {\n    assert(ENV.get(\"IS_BROWSER\"), \"Current environment is not a web browser\"), assert(void 0 !== window.localStorage, \"Current browser does not appear to support localStorage\"), this.LS = window.localStorage;\n  }return e.prototype.listModels = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var e, t, n, r, o, a;return __generator(this, function (i) {\n        for (e = {}, t = PATH_PREFIX + PATH_SEPARATOR, n = PATH_SEPARATOR + INFO_SUFFIX, r = 0; r < this.LS.length; ++r) (o = this.LS.key(r)).startsWith(t) && o.endsWith(n) && (a = getModelPathFromKey(o), e[a] = JSON.parse(this.LS.getItem(o)));return [2, e];\n      });\n    });\n  }, e.prototype.removeModel = function (e) {\n    return __awaiter(this, void 0, void 0, function () {\n      var t, n;return __generator(this, function (r) {\n        if (e = maybeStripScheme$1(e), t = getModelKeys(e), null == this.LS.getItem(t.info)) throw new Error(\"Cannot find model at path '\" + e + \"'\");return n = JSON.parse(this.LS.getItem(t.info)), this.LS.removeItem(t.info), this.LS.removeItem(t.topology), this.LS.removeItem(t.weightSpecs), this.LS.removeItem(t.weightData), [2, n];\n      });\n    });\n  }, e;\n}();if (ENV.get(\"IS_BROWSER\")) try {\n  ModelStoreManagerRegistry.registerManager(BrowserLocalStorage.URL_SCHEME, new BrowserLocalStorageManager());\n} catch (e) {}var DEFAULT_FILE_NAME_PREFIX = \"model\",\n    DEFAULT_JSON_EXTENSION_NAME = \".json\",\n    DEFAULT_WEIGHT_DATA_EXTENSION_NAME = \".weights.bin\",\n    BrowserDownloads = function () {\n  function e(t) {\n    if (!ENV.get(\"IS_BROWSER\")) throw new Error(\"triggerDownloads() cannot proceed because the current environment is not a browser.\");t.startsWith(e.URL_SCHEME) && (t = t.slice(e.URL_SCHEME.length)), null != t && 0 !== t.length || (t = DEFAULT_FILE_NAME_PREFIX), this.modelTopologyFileName = t + DEFAULT_JSON_EXTENSION_NAME, this.weightDataFileName = t + DEFAULT_WEIGHT_DATA_EXTENSION_NAME;\n  }return e.prototype.save = function (e) {\n    return __awaiter(this, void 0, void 0, function () {\n      var t, n, r, o, a, i;return __generator(this, function (s) {\n        if (t = window.URL.createObjectURL(new Blob([e.weightData], { type: \"application/octet-stream\" })), e.modelTopology instanceof ArrayBuffer) throw new Error(\"DownloadTrigger.save() does not support saving model topology in binary formats yet.\");return n = [{ paths: [\"./\" + this.weightDataFileName], weights: e.weightSpecs }], r = { modelTopology: e.modelTopology, weightsManifest: n }, o = window.URL.createObjectURL(new Blob([JSON.stringify(r)], { type: \"application/json\" })), (a = null == this.jsonAnchor ? document.createElement(\"a\") : this.jsonAnchor).download = this.modelTopologyFileName, a.href = o, a.click(), null != e.weightData && ((i = null == this.weightDataAnchor ? document.createElement(\"a\") : this.weightDataAnchor).download = this.weightDataFileName, i.href = t, i.click()), [2, { modelArtifactsInfo: getModelArtifactsInfoForJSON(e) }];\n      });\n    });\n  }, e.URL_SCHEME = \"downloads://\", e;\n}(),\n    BrowserFiles = function () {\n  function e(e) {\n    if (null == e || e.length < 1) throw new Error(\"When calling browserFiles, at least 1 file is required, but received \" + e);this.files = e;\n  }return e.prototype.load = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var e,\n          t,\n          n = this;return __generator(this, function (r) {\n        return e = this.files[0], t = this.files.slice(1), [2, new Promise(function (r, o) {\n          var a = new FileReader();a.onload = function (a) {\n            var i = JSON.parse(a.target.result),\n                s = i.modelTopology;if (null != s) {\n              0 === t.length && r({ modelTopology: s });var u = i.weightsManifest;if (null != u) {\n                var l;try {\n                  l = n.checkManifestAndWeightFiles(u, t);\n                } catch (e) {\n                  return void o(e);\n                }var c = [],\n                    p = [],\n                    d = [];u.forEach(function (e) {\n                  e.paths.forEach(function (e) {\n                    p.push(e), d.push(null);\n                  }), c.push.apply(c, e.weights);\n                }), u.forEach(function (e) {\n                  e.paths.forEach(function (e) {\n                    var t = new FileReader();t.onload = function (t) {\n                      var n = t.target.result,\n                          o = p.indexOf(e);d[o] = n, -1 === d.indexOf(null) && r({ modelTopology: s, weightSpecs: c, weightData: concatenateArrayBuffers(d) });\n                    }, t.onerror = function (t) {\n                      o(\"Failed to weights data from file of path '\" + e + \"'.\");\n                    }, t.readAsArrayBuffer(l[e]);\n                  });\n                });\n              } else o(new Error(\"weightManifest field is missing from file \" + e.name));\n            } else o(new Error(\"modelTopology field is missing from file \" + e.name));\n          }, a.onerror = function (t) {\n            o(\"Failed to read model topology and weights manifest JSON from file '\" + e.name + \"'. BrowserFiles supports loading Keras-style tf.Model artifacts only.\");\n          }, a.readAsText(e);\n        })];\n      });\n    });\n  }, e.prototype.checkManifestAndWeightFiles = function (e, t) {\n    for (var n = [], r = t.map(function (e) {\n      return basename(e.name);\n    }), o = {}, a = 0, i = e; a < i.length; a++) {\n      i[a].paths.forEach(function (e) {\n        var a = basename(e);if (-1 !== n.indexOf(a)) throw new Error(\"Duplicate file basename found in weights manifest: '\" + a + \"'\");if (n.push(a), -1 === r.indexOf(a)) throw new Error(\"Weight file with basename '\" + a + \"' is not provided.\");o[e] = t[r.indexOf(a)];\n      });\n    }if (n.length !== t.length) throw new Error(\"Mismatch in the number of files in weights manifest (\" + n.length + \") and the number of weight files provided (\" + t.length + \").\");return o;\n  }, e;\n}(),\n    browserDownloadsRouter = function (e) {\n  return ENV.get(\"IS_BROWSER\") && !Array.isArray(e) && e.startsWith(BrowserDownloads.URL_SCHEME) ? browserDownloads(e.slice(BrowserDownloads.URL_SCHEME.length)) : null;\n};function browserDownloads(e) {\n  return void 0 === e && (e = \"model\"), new BrowserDownloads(e);\n}function browserFiles(e) {\n  return new BrowserFiles(e);\n}function loadWeightsAsArrayBuffer(e, t) {\n  return __awaiter(this, void 0, void 0, function () {\n    var n, r;return __generator(this, function (o) {\n      switch (o.label) {case 0:\n          return n = e.map(function (e) {\n            return fetch(e, t);\n          }), [4, Promise.all(n)];case 1:\n          return r = o.sent(), [4, Promise.all(r.map(function (e) {\n            return e.arrayBuffer();\n          }))];case 2:\n          return [2, o.sent()];}\n    });\n  });\n}function loadWeights(e, t, n, r) {\n  return void 0 === t && (t = \"\"), __awaiter(this, void 0, void 0, function () {\n    var o, a, i, s, u, l, c, p, d, h;return __generator(this, function (f) {\n      switch (f.label) {case 0:\n          if (o = e.map(function () {\n            return !1;\n          }), a = {}, i = null != n ? n.map(function () {\n            return !1;\n          }) : [], s = [], e.forEach(function (e, t) {\n            var r = 0;e.weights.forEach(function (e) {\n              var u = \"quantization\" in e ? e.quantization.dtype : e.dtype,\n                  l = DTYPE_VALUE_SIZE_MAP[u] * sizeFromShape(e.shape),\n                  c = function () {\n                o[t] = !0, null == a[t] && (a[t] = []), a[t].push({ manifestEntry: e, groupOffset: r, sizeBytes: l });\n              };null != n ? n.forEach(function (t, n) {\n                t === e.name && (c(), i[n] = !0);\n              }) : c(), s.push(e.name), r += l;\n            });\n          }), !i.every(function (e) {\n            return e;\n          })) throw u = n.filter(function (e, t) {\n            return !i[t];\n          }), new Error(\"Could not find weights in manifest with names: \" + u.join(\", \") + \". \\nManifest JSON has weights with names: \" + s.join(\", \") + \".\");return l = o.reduce(function (e, t, n) {\n            return t && e.push(n), e;\n          }, []), c = [], l.forEach(function (n) {\n            e[n].paths.forEach(function (e) {\n              var n = t + (t.endsWith(\"/\") ? \"\" : \"/\") + e;c.push(n);\n            });\n          }), [4, loadWeightsAsArrayBuffer(c, r)];case 1:\n          return p = f.sent(), d = {}, h = 0, l.forEach(function (t) {\n            for (var n = e[t].paths.length, r = 0, o = 0; o < n; o++) r += p[h + o].byteLength;for (var i = new ArrayBuffer(r), s = new Uint8Array(i), u = 0, l = 0; l < n; l++) {\n              var c = new Uint8Array(p[h + l]);s.set(c, u), u += c.byteLength;\n            }a[t].forEach(function (e) {\n              var t = decodeWeights(i.slice(e.groupOffset, e.groupOffset + e.sizeBytes), [e.manifestEntry]);for (var n in t) d[n] = t[n];\n            }), h += n;\n          }), [2, d];}\n    });\n  });\n}IORouterRegistry.registerSaveRouter(browserDownloadsRouter);var BrowserHTTPRequest = function () {\n  function e(e, t) {\n    if (this.DEFAULT_METHOD = \"POST\", \"undefined\" == typeof fetch) throw new Error(\"browserHTTPRequest is not supported outside the web browser without a fetch polyfill.\");if (assert(null != e && e.length > 0, \"URL path for browserHTTPRequest must not be null, undefined or empty.\"), Array.isArray(e) && assert(2 === e.length, \"URL paths for browserHTTPRequest must have a length of 2, (actual length is \" + e.length + \").\"), this.path = e, null != t && null != t.body) throw new Error(\"requestInit is expected to have no pre-existing body, but has one.\");this.requestInit = t || {};\n  }return e.prototype.save = function (e) {\n    return __awaiter(this, void 0, void 0, function () {\n      var t, n, r, o;return __generator(this, function (a) {\n        switch (a.label) {case 0:\n            if (e.modelTopology instanceof ArrayBuffer) throw new Error(\"BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.\");return (t = Object.assign({ method: this.DEFAULT_METHOD }, this.requestInit)).body = new FormData(), n = [{ paths: [\"./model.weights.bin\"], weights: e.weightSpecs }], r = { modelTopology: e.modelTopology, weightsManifest: n }, t.body.append(\"model.json\", new Blob([JSON.stringify(r)], { type: \"application/json\" }), \"model.json\"), null != e.weightData && t.body.append(\"model.weights.bin\", new Blob([e.weightData], { type: \"application/octet-stream\" }), \"model.weights.bin\"), [4, fetch(this.path, t)];case 1:\n            if (200 === (o = a.sent()).status) return [2, { modelArtifactsInfo: getModelArtifactsInfoForJSON(e), responses: [o] }];throw new Error(\"BrowserHTTPRequest.save() failed due to HTTP response status \" + o.status + \".\");}\n      });\n    });\n  }, e.prototype.load = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (e) {\n        return [2, Array.isArray(this.path) ? this.loadBinaryModel() : this.loadJSONModel()];\n      });\n    });\n  }, e.prototype.loadBinaryTopology = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var e;return __generator(this, function (t) {\n        switch (t.label) {case 0:\n            return t.trys.push([0, 3,, 4]), [4, fetch(this.path[0], this.requestInit)];case 1:\n            return [4, t.sent().arrayBuffer()];case 2:\n            return [2, t.sent()];case 3:\n            throw e = t.sent(), new Error(this.path[0] + \" not found. \" + e);case 4:\n            return [2];}\n      });\n    });\n  }, e.prototype.loadBinaryModel = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var e, t, n, r, o, a, i, s;return __generator(this, function (u) {\n        switch (u.label) {case 0:\n            return e = this.loadBinaryTopology(), [4, fetch(this.path[1], this.requestInit)];case 1:\n            return t = u.sent(), [4, Promise.all([e, t])];case 2:\n            return n = u.sent(), r = n[0], [4, n[1].json()];case 3:\n            return null == (o = u.sent()) ? [3, 5] : [4, this.loadWeights(o)];case 4:\n            s = u.sent(), a = s[0], i = s[1], u.label = 5;case 5:\n            return [2, { modelTopology: r, weightSpecs: a, weightData: i }];}\n      });\n    });\n  }, e.prototype.loadJSONModel = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var e, t, n, r, o, a, i;return __generator(this, function (s) {\n        switch (s.label) {case 0:\n            return [4, fetch(this.path, this.requestInit)];case 1:\n            return [4, s.sent().json()];case 2:\n            if (e = s.sent(), t = e.modelTopology, n = e.weightsManifest, null == t && null == n) throw new Error(\"The JSON from HTTP path \" + this.path + \" contains neither model topology or manifest for weights.\");return null == n ? [3, 4] : (a = e.weightsManifest, [4, this.loadWeights(a)]);case 3:\n            i = s.sent(), r = i[0], o = i[1], s.label = 4;case 4:\n            return [2, { modelTopology: t, weightSpecs: r, weightData: o }];}\n      });\n    });\n  }, e.prototype.loadWeights = function (e) {\n    return __awaiter(this, void 0, void 0, function () {\n      var t, n, r, o, a, i, s, u, l;return __generator(this, function (c) {\n        switch (c.label) {case 0:\n            for (t = Array.isArray(this.path) ? this.path[1] : this.path, n = [], r = 0, o = e; r < o.length; r++) a = o[r], n.push.apply(n, a.weights);return (i = t.substring(0, t.lastIndexOf(\"/\"))).endsWith(\"/\") || (i += \"/\"), s = [], e.forEach(function (e) {\n              e.paths.forEach(function (e) {\n                s.push(i + e);\n              });\n            }), u = [n], l = concatenateArrayBuffers, [4, loadWeightsAsArrayBuffer(s, this.requestInit)];case 1:\n            return [2, u.concat([l.apply(void 0, [c.sent()])])];}\n      });\n    });\n  }, e.URL_SCHEME_REGEX = /^https?:\\/\\//, e;\n}();function isHTTPScheme(e) {\n  return null != e.match(BrowserHTTPRequest.URL_SCHEME_REGEX);\n}var httpRequestRouter = function (e) {\n  if (\"undefined\" == typeof fetch) return null;return (Array.isArray(e) ? e.every(function (e) {\n    return isHTTPScheme(e);\n  }) : isHTTPScheme(e)) ? browserHTTPRequest(e) : null;\n};function browserHTTPRequest(e, t) {\n  return new BrowserHTTPRequest(e, t);\n}IORouterRegistry.registerSaveRouter(httpRequestRouter), IORouterRegistry.registerLoadRouter(httpRequestRouter);var PassthroughLoader = function () {\n  function e(e, t, n) {\n    this.modelTopology = e, this.weightSpecs = t, this.weightData = n;\n  }return e.prototype.load = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var e;return __generator(this, function (t) {\n        return e = {}, null != this.modelTopology && (e = __assign({ modelTopology: this.modelTopology }, e)), null != this.weightSpecs && this.weightSpecs.length > 0 && (e = __assign({ weightSpecs: this.weightSpecs }, e)), null != this.weightData && this.weightData.byteLength > 0 && (e = __assign({ weightData: this.weightData }, e)), [2, e];\n      });\n    });\n  }, e;\n}(),\n    PassthroughSaver = function () {\n  function e(e) {\n    this.saveHandler = e;\n  }return e.prototype.save = function (e) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (t) {\n        return [2, this.saveHandler(e)];\n      });\n    });\n  }, e;\n}();function fromMemory(e, t, n) {\n  return new PassthroughLoader(e, t, n);\n}function withSaveHandler(e) {\n  return new PassthroughSaver(e);\n}var registerSaveRouter = IORouterRegistry.registerSaveRouter,\n    registerLoadRouter = IORouterRegistry.registerLoadRouter,\n    getSaveHandlers = IORouterRegistry.getSaveHandlers,\n    getLoadHandlers = IORouterRegistry.getLoadHandlers,\n    io = Object.freeze({ browserFiles: browserFiles, browserHTTPRequest: browserHTTPRequest, concatenateArrayBuffers: concatenateArrayBuffers, decodeWeights: decodeWeights, encodeWeights: encodeWeights, fromMemory: fromMemory, getLoadHandlers: getLoadHandlers, getModelArtifactsInfoForJSON: getModelArtifactsInfoForJSON, getSaveHandlers: getSaveHandlers, loadWeights: loadWeights, registerLoadRouter: registerLoadRouter, registerSaveRouter: registerSaveRouter, withSaveHandler: withSaveHandler, copyModel: copyModel, listModels: listModels, moveModel: moveModel, removeModel: removeModel }),\n    Serializable = function () {\n  function e() {}return e.prototype.getClassName = function () {\n    return this.constructor.className;\n  }, e.fromConfig = function (e, t) {\n    return new e(t);\n  }, e;\n}(),\n    SerializationMap = function () {\n  function e() {\n    this.classNameMap = {};\n  }return e.getMap = function () {\n    return null == e.instance && (e.instance = new e()), e.instance;\n  }, e.register = function (t) {\n    e.getMap().classNameMap[t.className] = [t, t.fromConfig];\n  }, e;\n}();function registerClass(e) {\n  assert(null != e.className, \"Class being registered does not have the static className property defined.\"), assert(\"string\" == typeof e.className, \"className is required to be a string, but got type \" + typeof e.className), assert(e.className.length > 0, \"Class being registered has an empty-string as its className, which is disallowed.\"), SerializationMap.register(e);\n}var serialization = Object.freeze({ Serializable: Serializable, SerializationMap: SerializationMap, registerClass: registerClass }),\n    WEBGL_ENVS = { HAS_WEBGL: !0 },\n    NODE_ENVS = { IS_NODE: !0 },\n    CHROME_ENVS = { IS_CHROME: !0 },\n    BROWSER_ENVS = { IS_BROWSER: !0 },\n    CPU_ENVS = { HAS_WEBGL: !1 },\n    ALL_ENVS = {};function expectArraysClose(e, t, n) {\n  if (null == n && (n = ENV.get(\"TEST_EPSILON\")), e instanceof Tensor || t instanceof Tensor) {\n    if (e instanceof Tensor && t instanceof Tensor) {\n      if (e.dtype !== t.dtype) throw new Error(\"Arrays are of different type actual: \" + e.dtype + \" vs expected: \" + t.dtype + \".\");if (!arraysEqual(e.shape, t.shape)) throw new Error(\"Arrays are of different shape actual: \" + e.shape + \" vs expected: \" + t.shape + \".\");\n    }\n  } else {\n    var r = e.constructor.name,\n        o = t.constructor.name;if (r !== o) throw new Error(\"Arrays are of different type actual: \" + r + \" vs expected: \" + o);\n  }var a, i;if (a = e instanceof Tensor ? e.dataSync() : e, i = t instanceof Tensor ? t.dataSync() : t, a.length !== i.length) throw new Error(\"Arrays have different lengths actual: \" + a.length + \" vs expected: \" + i.length + \".\\nActual:   \" + a + \".\\nExpected: \" + i + \".\");for (var s = 0; s < i.length; ++s) {\n    var u = a[s],\n        l = i[s];if (!areClose(u, Number(l), n)) throw new Error(\"Arrays differ: actual[\" + s + \"] = \" + u + \", expected[\" + s + \"] = \" + l + \".\\nActual:   \" + a + \".\\nExpected: \" + i + \".\");\n  }\n}function expectPromiseToFail(e, t) {\n  e().then(function () {\n    return t.fail();\n  }, function () {\n    return t();\n  });\n}function expectArraysEqual(e, t) {\n  return expectArraysClose(e, t, 0);\n}function expectNumbersClose(e, t, n) {\n  if (null == n && (n = ENV.get(\"TEST_EPSILON\")), !areClose(e, t, n)) throw new Error(\"Numbers differ: actual === \" + e + \", expected === \" + t);\n}function areClose(e, t, n) {\n  return !(!isNaN(e) || !isNaN(t)) || !(isNaN(e) || isNaN(t) || Math.abs(e - t) > n);\n}function expectValuesInRange(e, t, n) {\n  var r;r = e instanceof Tensor ? e.dataSync() : e;for (var o = 0; o < r.length; o++) if (r[o] < t || r[o] > n) throw new Error(\"Value out of range:\" + r[o] + \" low: \" + t + \", high: \" + n);\n}function expectArrayBuffersEqual(e, t) {\n  expect(new Float32Array(e)).toEqual(new Float32Array(t));\n}var test_util = Object.freeze({ WEBGL_ENVS: WEBGL_ENVS, NODE_ENVS: NODE_ENVS, CHROME_ENVS: CHROME_ENVS, BROWSER_ENVS: BROWSER_ENVS, CPU_ENVS: CPU_ENVS, ALL_ENVS: ALL_ENVS, expectArraysClose: expectArraysClose, expectPromiseToFail: expectPromiseToFail, expectArraysEqual: expectArraysEqual, expectNumbersClose: expectNumbersClose, expectValuesInRange: expectValuesInRange, expectArrayBuffersEqual: expectArrayBuffersEqual }),\n    version = \"0.13.0\",\n    webgl = Object.freeze({ gpgpu_util: gpgpu_util, webgl_util: webgl_util, MathBackendWebGL: MathBackendWebGL, GPGPUContext: GPGPUContext }),\n    Optimizer = function (e) {\n  function t() {\n    return null !== e && e.apply(this, arguments) || this;\n  }return __extends(t, e), t.prototype.minimize = function (e, t, n) {\n    void 0 === t && (t = !1);var r = this.computeGradients(e, n),\n        o = r.value,\n        a = r.grads;return this.applyGradients(a), Object.keys(a).forEach(function (e) {\n      return a[e].dispose();\n    }), t ? o : (o.dispose(), null);\n  }, t.prototype.computeGradients = function (e, t) {\n    return variableGrads(e, t);\n  }, t;\n}(Serializable),\n    AdadeltaOptimizer = function (e) {\n  function t(t, n, r) {\n    void 0 === r && (r = null);var o = e.call(this) || this;return o.learningRate = t, o.rho = n, o.epsilon = r, o.accumulatedGrads = {}, o.accumulatedUpdates = {}, o.c = keep(scalar(-t)), o.rhoScalar = keep(scalar(n)), o.oneMinusRho = keep(scalar(1 - n)), null === r && (r = ENV.get(\"EPSILON\")), o.epsilonScalar = keep(scalar(r)), o;\n  }return __extends(t, e), t.prototype.applyGradients = function (e) {\n    var t = this,\n        n = function (n) {\n      var o = ENV.engine.registeredVariables[n];if (null == r.accumulatedGrads[n]) {\n        tidy(function () {\n          t.accumulatedGrads[n] = zerosLike(o).variable(!1);\n        });\n      }if (null == r.accumulatedUpdates[n]) {\n        tidy(function () {\n          t.accumulatedUpdates[n] = zerosLike(o).variable(!1);\n        });\n      }var a = e[n],\n          i = r.accumulatedGrads[n],\n          s = r.accumulatedUpdates[n];tidy(function () {\n        var e = t.rhoScalar.mul(i).add(t.oneMinusRho.mul(a.square())),\n            r = s.add(t.epsilonScalar).sqrt().div(i.add(t.epsilonScalar).sqrt()).mul(a),\n            u = t.rhoScalar.mul(s).add(t.oneMinusRho.mul(r.square()));t.accumulatedGrads[n].assign(e), t.accumulatedUpdates[n].assign(u);var l = t.c.mul(r).add(o);o.assign(l);\n      });\n    },\n        r = this;for (var o in e) n(o);\n  }, t.prototype.dispose = function () {\n    var e = this;this.c.dispose(), this.epsilonScalar.dispose(), this.rhoScalar.dispose(), this.oneMinusRho.dispose(), null != this.accumulatedUpdates && (Object.keys(this.accumulatedUpdates).forEach(function (t) {\n      return e.accumulatedUpdates[t].dispose();\n    }), Object.keys(this.accumulatedGrads).forEach(function (t) {\n      return e.accumulatedGrads[t].dispose();\n    }));\n  }, t.prototype.getConfig = function () {\n    return { learningRate: this.learningRate, rho: this.rho, epsilon: this.epsilon };\n  }, t.fromConfig = function (e, t) {\n    return new e(t.learningRate, t.rho, t.epsilon);\n  }, t.className = \"AdadeltaOptimizer\", t;\n}(Optimizer);registerClass(AdadeltaOptimizer);var AdagradOptimizer = function (e) {\n  function t(t, n) {\n    void 0 === n && (n = .1);var r = e.call(this) || this;return r.learningRate = t, r.initialAccumulatorValue = n, r.accumulatedGrads = {}, r.c = keep(scalar(-t)), r.epsilon = keep(scalar(ENV.get(\"EPSILON\"))), r;\n  }return __extends(t, e), t.prototype.applyGradients = function (e) {\n    var t = this,\n        n = function (n) {\n      var o = ENV.engine.registeredVariables[n];if (null == r.accumulatedGrads[n]) {\n        tidy(function () {\n          t.accumulatedGrads[n] = fill(o.shape, t.initialAccumulatorValue).variable(!1);\n        });\n      }var a = e[n],\n          i = r.accumulatedGrads[n];tidy(function () {\n        var e = i.add(a.square());t.accumulatedGrads[n].assign(e);var r = t.c.mul(a.div(e.add(t.epsilon).sqrt())).add(o);o.assign(r);\n      });\n    },\n        r = this;for (var o in e) n(o);\n  }, t.prototype.dispose = function () {\n    var e = this;this.epsilon.dispose(), this.c.dispose(), null != this.accumulatedGrads && Object.keys(this.accumulatedGrads).forEach(function (t) {\n      return e.accumulatedGrads[t].dispose();\n    });\n  }, t.prototype.getConfig = function () {\n    return { learningRate: this.learningRate, initialAccumulatorValue: this.initialAccumulatorValue };\n  }, t.fromConfig = function (e, t) {\n    return new e(t.learningRate, t.initialAccumulatorValue);\n  }, t.className = \"AdagradOptimizer\", t;\n}(Optimizer);registerClass(AdagradOptimizer);var AdamOptimizer = function (e) {\n  function t(t, n, r, o) {\n    void 0 === o && (o = null);var a = e.call(this) || this;return a.learningRate = t, a.beta1 = n, a.beta2 = r, a.epsilon = o, a.accumulatedFirstMoment = {}, a.accumulatedSecondMoment = {}, a.c = keep(scalar(-t)), a.beta1Scalar = keep(scalar(n)), a.beta2Scalar = keep(scalar(r)), tidy(function () {\n      a.accBeta1 = scalar(n).variable(), a.accBeta2 = scalar(r).variable();\n    }), a.oneMinusBeta1 = keep(scalar(1 - n)), a.oneMinusBeta2 = keep(scalar(1 - r)), a.one = keep(scalar(1)), null === o && (o = ENV.get(\"EPSILON\")), a.epsScalar = keep(scalar(o)), a;\n  }return __extends(t, e), t.prototype.applyGradients = function (e) {\n    var t = this;tidy(function () {\n      var n = t.one.sub(t.accBeta1),\n          r = t.one.sub(t.accBeta2);for (var o in e) {\n        var a = ENV.engine.registeredVariables[o];if (null == t.accumulatedFirstMoment[o]) {\n          var i = !1;t.accumulatedFirstMoment[o] = zerosLike(a).variable(i);\n        }if (null == t.accumulatedSecondMoment[o]) {\n          i = !1;t.accumulatedSecondMoment[o] = zerosLike(a).variable(i);\n        }var s = e[o],\n            u = t.accumulatedFirstMoment[o],\n            l = t.accumulatedSecondMoment[o],\n            c = t.beta1Scalar.mul(u).add(t.oneMinusBeta1.mul(s)),\n            p = t.beta2Scalar.mul(l).add(t.oneMinusBeta2.mul(s.square())),\n            d = c.div(n),\n            h = p.div(r);t.accumulatedFirstMoment[o].assign(c), t.accumulatedSecondMoment[o].assign(p);var f = t.c.mul(d.div(t.epsScalar.add(h.sqrt()))).add(a);a.assign(f);\n      }t.accBeta1.assign(t.accBeta1.mul(t.beta1Scalar)), t.accBeta2.assign(t.accBeta2.mul(t.beta2Scalar));\n    });\n  }, t.prototype.dispose = function () {\n    var e = this;this.c.dispose(), this.epsScalar.dispose(), this.beta1Scalar.dispose(), this.beta2Scalar.dispose(), this.accBeta1.dispose(), this.accBeta2.dispose(), this.oneMinusBeta1.dispose(), this.oneMinusBeta2.dispose(), this.one.dispose(), null != this.accumulatedFirstMoment && Object.keys(this.accumulatedFirstMoment).forEach(function (t) {\n      return e.accumulatedFirstMoment[t].dispose();\n    }), null != this.accumulatedSecondMoment && Object.keys(this.accumulatedSecondMoment).forEach(function (t) {\n      return e.accumulatedSecondMoment[t].dispose();\n    });\n  }, t.prototype.getConfig = function () {\n    return { learningRate: this.learningRate, beta1: this.beta1, beta2: this.beta2, epsilon: this.epsilon };\n  }, t.fromConfig = function (e, t) {\n    return new e(t.learningRate, t.beta1, t.beta2, t.epsilon);\n  }, t.className = \"AdamOptimizer\", t;\n}(Optimizer);registerClass(AdamOptimizer);var AdamaxOptimizer = function (e) {\n  function t(t, n, r, o, a) {\n    void 0 === o && (o = null), void 0 === a && (a = 0);var i = e.call(this) || this;return i.learningRate = t, i.beta1 = n, i.beta2 = r, i.epsilon = o, i.decay = a, i.accumulatedFirstMoment = {}, i.accumulatedWeightedInfNorm = {}, i.c = keep(scalar(-t)), i.beta1Scalar = keep(scalar(n)), i.beta2Scalar = keep(scalar(r)), i.decayScalar = keep(scalar(a)), tidy(function () {\n      i.iteration = scalar(0).variable(), i.accBeta1 = scalar(n).variable();\n    }), i.oneMinusBeta1 = keep(scalar(1 - n)), i.one = keep(scalar(1)), null === o && (o = ENV.get(\"EPSILON\")), i.epsScalar = keep(scalar(o)), i;\n  }return __extends(t, e), t.prototype.applyGradients = function (e) {\n    var t = this;tidy(function () {\n      var n = t.one.sub(t.accBeta1),\n          r = t.c.div(t.one.add(t.decayScalar.mul(t.iteration)));for (var o in e) {\n        var a = ENV.engine.registeredVariables[o];if (null == t.accumulatedFirstMoment[o]) {\n          var i = !1;t.accumulatedFirstMoment[o] = zerosLike(a).variable(i);\n        }if (null == t.accumulatedWeightedInfNorm[o]) {\n          i = !1;t.accumulatedWeightedInfNorm[o] = zerosLike(a).variable(i);\n        }var s = e[o],\n            u = t.accumulatedFirstMoment[o],\n            l = t.accumulatedWeightedInfNorm[o],\n            c = t.beta1Scalar.mul(u).add(t.oneMinusBeta1.mul(s)),\n            p = t.beta2Scalar.mul(l),\n            d = s.abs(),\n            h = p.maximum(d);t.accumulatedFirstMoment[o].assign(c), t.accumulatedWeightedInfNorm[o].assign(h);var f = r.div(n).mul(c.div(t.epsScalar.add(h))).add(a);a.assign(f);\n      }t.iteration.assign(t.iteration.add(t.one)), t.accBeta1.assign(t.accBeta1.mul(t.beta1Scalar));\n    });\n  }, t.prototype.dispose = function () {\n    var e = this;this.c.dispose(), this.epsScalar.dispose(), this.accBeta1.dispose(), this.beta1Scalar.dispose(), this.beta2Scalar.dispose(), this.oneMinusBeta1.dispose(), this.decayScalar.dispose(), this.iteration.dispose(), this.one.dispose(), null != this.accumulatedFirstMoment && Object.keys(this.accumulatedFirstMoment).forEach(function (t) {\n      return e.accumulatedFirstMoment[t].dispose();\n    }), null != this.accumulatedWeightedInfNorm && Object.keys(this.accumulatedWeightedInfNorm).forEach(function (t) {\n      return e.accumulatedWeightedInfNorm[t].dispose();\n    });\n  }, t.prototype.getConfig = function () {\n    return { learningRate: this.learningRate, beta1: this.beta1, beta2: this.beta2, epsilon: this.epsilon, decay: this.decay };\n  }, t.fromConfig = function (e, t) {\n    return new e(t.learningRate, t.beta1, t.beta2, t.epsilon, t.decay);\n  }, t.className = \"AdamaxOptimizer\", t;\n}(Optimizer);registerClass(AdamaxOptimizer);var SGDOptimizer = function (e) {\n  function t(t) {\n    var n = e.call(this) || this;return n.learningRate = t, n.setLearningRate(t), n;\n  }return __extends(t, e), t.prototype.applyGradients = function (e) {\n    var t = this;Object.keys(e).forEach(function (n) {\n      var r = e[n],\n          o = ENV.engine.registeredVariables[n];tidy(function () {\n        var e = t.c.mul(r).add(o);o.assign(e);\n      });\n    });\n  }, t.prototype.setLearningRate = function (e) {\n    this.learningRate = e, null != this.c && this.c.dispose(), this.c = keep(scalar(-e));\n  }, t.prototype.dispose = function () {\n    this.c.dispose();\n  }, t.prototype.getConfig = function () {\n    return { learningRate: this.learningRate };\n  }, t.fromConfig = function (e, t) {\n    return new e(t.learningRate);\n  }, t.className = \"SGDOptimizer\", t;\n}(Optimizer);registerClass(SGDOptimizer);var MomentumOptimizer = function (e) {\n  function t(t, n, r) {\n    void 0 === r && (r = !1);var o = e.call(this, t) || this;return o.learningRate = t, o.momentum = n, o.useNesterov = r, o.m = scalar(o.momentum), o.accumulations = {}, o;\n  }return __extends(t, e), t.prototype.applyGradients = function (e) {\n    var t = this,\n        n = function (n) {\n      var o = ENV.engine.registeredVariables[n];if (null == r.accumulations[n]) {\n        tidy(function () {\n          t.accumulations[n] = zerosLike(o).variable(!1);\n        });\n      }var a = r.accumulations[n],\n          i = e[n];tidy(function () {\n        var e,\n            r = t.m.mul(a).add(i);e = t.useNesterov ? t.c.mul(i.add(r.mul(t.m))).add(o) : t.c.mul(r).add(o), t.accumulations[n].assign(r), o.assign(e);\n      });\n    },\n        r = this;for (var o in e) n(o);\n  }, t.prototype.dispose = function () {\n    if (e.prototype.dispose.call(this), this.m.dispose(), null != this.accumulations) for (var t in this.accumulations) this.accumulations[t].dispose();\n  }, t.prototype.setMomentum = function (e) {\n    this.momentum = e;\n  }, t.prototype.getConfig = function () {\n    return { learningRate: this.learningRate, momentum: this.momentum, useNesterov: this.useNesterov };\n  }, t.fromConfig = function (e, t) {\n    return new e(t.learningRate, t.momentum, t.useNesterov);\n  }, t.className = \"MomentumOptimizer\", t;\n}(SGDOptimizer);registerClass(MomentumOptimizer);var RMSPropOptimizer = function (e) {\n  function t(t, n, r, o, a) {\n    void 0 === n && (n = .9), void 0 === r && (r = 0), void 0 === o && (o = null), void 0 === a && (a = !1);var i = e.call(this) || this;return i.learningRate = t, i.decay = n, i.momentum = r, i.epsilon = o, i.accumulatedMeanSquares = {}, i.accumulatedMeanGrads = {}, i.accumulatedMoments = {}, i.c = keep(scalar(t)), i.decayScalar = keep(scalar(n)), i.momentumScalar = keep(scalar(r)), i.oneMinusDecay = keep(scalar(1 - n)), i.centered = a, null === o && (o = ENV.get(\"EPSILON\")), i.epsilonScalar = keep(scalar(o)), i;\n  }return __extends(t, e), t.prototype.applyGradients = function (e) {\n    var t = this,\n        n = function (n) {\n      var o = ENV.engine.registeredVariables[n];if (null == r.accumulatedMeanSquares[n]) {\n        tidy(function () {\n          t.accumulatedMeanSquares[n] = zerosLike(o).variable(!1);\n        });\n      }if (null == r.accumulatedMeanGrads[n] && r.centered) {\n        tidy(function () {\n          t.accumulatedMeanGrads[n] = zerosLike(o).variable(!1);\n        });\n      }if (null == r.accumulatedMoments[n]) {\n        tidy(function () {\n          t.accumulatedMoments[n] = zerosLike(o).variable(!1);\n        });\n      }var a = r.accumulatedMeanSquares[n],\n          i = r.accumulatedMeanGrads[n],\n          s = r.accumulatedMoments[n],\n          u = e[n];tidy(function () {\n        var e = t.decayScalar.mul(a).add(t.oneMinusDecay.mul(u.square()));if (t.centered) {\n          var r = t.decayScalar.mul(i).add(t.oneMinusDecay.mul(u)),\n              l = t.momentumScalar.mul(s).add(t.c.mul(u).div(e.sub(r.square().add(t.epsilonScalar)).sqrt()));t.accumulatedMeanSquares[n].assign(e), t.accumulatedMeanGrads[n].assign(r), t.accumulatedMoments[n].assign(l);var c = o.sub(l);o.assign(c);\n        } else {\n          var p = t.decayScalar.mul(a).add(t.oneMinusDecay.mul(u.square()));l = t.momentumScalar.mul(s).add(t.c.mul(u).div(p.add(t.epsilonScalar).sqrt()));t.accumulatedMeanSquares[n].assign(p), t.accumulatedMoments[n].assign(l);c = o.sub(l);o.assign(c);\n        }\n      });\n    },\n        r = this;for (var o in e) n(o);\n  }, t.prototype.dispose = function () {\n    var e = this;this.c.dispose(), this.epsilonScalar.dispose(), this.decayScalar.dispose(), this.momentumScalar.dispose(), this.oneMinusDecay.dispose(), null != this.accumulatedMeanSquares && Object.keys(this.accumulatedMeanSquares).forEach(function (t) {\n      return e.accumulatedMeanSquares[t].dispose();\n    }), null != this.accumulatedMeanGrads && this.centered && Object.keys(this.accumulatedMeanGrads).forEach(function (t) {\n      return e.accumulatedMeanGrads[t].dispose();\n    }), null != this.accumulatedMoments && Object.keys(this.accumulatedMoments).forEach(function (t) {\n      return e.accumulatedMoments[t].dispose();\n    });\n  }, t.prototype.getConfig = function () {\n    return { learningRate: this.learningRate, decay: this.decay, momentum: this.momentum, epsilon: this.epsilon, centered: this.centered };\n  }, t.fromConfig = function (e, t) {\n    return new e(t.learningRate, t.decay, t.momentum, t.epsilon, t.centered);\n  }, t.className = \"RMSPropOptimizer\", t;\n}(Optimizer);registerClass(RMSPropOptimizer);var OptimizerConstructors = function () {\n  function e() {}return e.sgd = function (e) {\n    return new SGDOptimizer(e);\n  }, e.momentum = function (e, t, n) {\n    return void 0 === n && (n = !1), new MomentumOptimizer(e, t, n);\n  }, e.rmsprop = function (e, t, n, r, o) {\n    return void 0 === t && (t = .9), void 0 === n && (n = 0), void 0 === r && (r = null), void 0 === o && (o = !1), new RMSPropOptimizer(e, t, n, r, o);\n  }, e.adam = function (e, t, n, r) {\n    return void 0 === e && (e = .001), void 0 === t && (t = .9), void 0 === n && (n = .999), void 0 === r && (r = null), new AdamOptimizer(e, t, n, r);\n  }, e.adadelta = function (e, t, n) {\n    return void 0 === e && (e = .001), void 0 === t && (t = .95), void 0 === n && (n = null), new AdadeltaOptimizer(e, t, n);\n  }, e.adamax = function (e, t, n, r, o) {\n    return void 0 === e && (e = .002), void 0 === t && (t = .9), void 0 === n && (n = .999), void 0 === r && (r = null), void 0 === o && (o = 0), new AdamaxOptimizer(e, t, n, r, o);\n  }, e.adagrad = function (e, t) {\n    return void 0 === t && (t = .1), new AdagradOptimizer(e, t);\n  }, e;\n}(),\n    train = { sgd: OptimizerConstructors.sgd, momentum: OptimizerConstructors.momentum, adadelta: OptimizerConstructors.adadelta, adagrad: OptimizerConstructors.adagrad, rmsprop: OptimizerConstructors.rmsprop, adamax: OptimizerConstructors.adamax, adam: OptimizerConstructors.adam },\n    setBackend = Environment.setBackend,\n    getBackend = Environment.getBackend,\n    disposeVariables = Environment.disposeVariables,\n    memory = Environment.memory;setOpHandler(ops);exports.setBackend = setBackend;\nexports.getBackend = getBackend;\nexports.disposeVariables = disposeVariables;\nexports.memory = memory;\nexports.version_core = version;\nexports.nextFrame = nextFrame;\nexports.environment = environment;\nexports.io = io;\nexports.serialization = serialization;\nexports.test_util = test_util;\nexports.util = util;\nexports.webgl = webgl;\nexports.AdadeltaOptimizer = AdadeltaOptimizer;\nexports.AdagradOptimizer = AdagradOptimizer;\nexports.AdamOptimizer = AdamOptimizer;\nexports.AdamaxOptimizer = AdamaxOptimizer;\nexports.MomentumOptimizer = MomentumOptimizer;\nexports.Optimizer = Optimizer;\nexports.RMSPropOptimizer = RMSPropOptimizer;\nexports.SGDOptimizer = SGDOptimizer;\nexports.Tensor = Tensor;\nexports.TensorBuffer = TensorBuffer;\nexports.variable = variable;\nexports.Variable = Variable;\nexports.Rank = Rank;\nexports.Reduction = Reduction;\nexports.ENV = ENV;\nexports.Environment = Environment;\nexports.image = image_ops;\nexports.linalg = linalg_ops;\nexports.losses = loss_ops;\nexports.op = op;\nexports.batchNormalization2d = batchNormalization2d;\nexports.batchNormalization3d = batchNormalization3d;\nexports.batchNormalization4d = batchNormalization4d;\nexports.batchNormalization = batchNormalization;\nexports.complex = complex;\nexports.real = real;\nexports.imag = imag;\nexports.concat = concat;\nexports.concat1d = concat1d;\nexports.concat2d = concat2d;\nexports.concat3d = concat3d;\nexports.concat4d = concat4d;\nexports.split = split$1;\nexports.conv1d = conv1d;\nexports.conv2d = conv2d;\nexports.depthwiseConv2d = depthwiseConv2d;\nexports.separableConv2d = separableConv2d;\nexports.conv2dTranspose = conv2dTranspose;\nexports.matMul = matMul;\nexports.dot = dot;\nexports.outerProduct = outerProduct;\nexports.reverse = reverse;\nexports.reverse1d = reverse1d;\nexports.reverse2d = reverse2d;\nexports.reverse3d = reverse3d;\nexports.reverse4d = reverse4d;\nexports.maxPool = maxPool;\nexports.avgPool = avgPool;\nexports.slice = slice;\nexports.slice1d = slice1d;\nexports.slice2d = slice2d;\nexports.slice3d = slice3d;\nexports.slice4d = slice4d;\nexports.abs = abs;\nexports.acos = acos;\nexports.acosh = acosh;\nexports.asin = asin;\nexports.asinh = asinh;\nexports.atan = atan;\nexports.atanh = atanh;\nexports.ceil = ceil;\nexports.clipByValue = clipByValue;\nexports.cos = cos;\nexports.cosh = cosh;\nexports.erf = erf;\nexports.exp = exp;\nexports.expm1 = expm1;\nexports.floor = floor;\nexports.log = log$1;\nexports.log1p = log1p;\nexports.logSigmoid = logSigmoid;\nexports.neg = neg;\nexports.reciprocal = reciprocal;\nexports.round = round;\nexports.rsqrt = rsqrt;\nexports.sigmoid = sigmoid;\nexports.sign = sign;\nexports.sin = sin;\nexports.sinh = sinh;\nexports.softplus = softplus;\nexports.sqrt = sqrt;\nexports.square = square;\nexports.step = step;\nexports.tan = tan;\nexports.tanh = tanh$1;\nexports.all = all;\nexports.any = any;\nexports.argMax = argMax;\nexports.argMin = argMin;\nexports.logSumExp = logSumExp;\nexports.max = max;\nexports.mean = mean;\nexports.min = min;\nexports.moments = moments;\nexports.sum = sum;\nexports.equal = equal;\nexports.equalStrict = equalStrict;\nexports.greater = greater;\nexports.greaterEqual = greaterEqual;\nexports.greaterEqualStrict = greaterEqualStrict;\nexports.greaterStrict = greaterStrict;\nexports.less = less;\nexports.lessEqual = lessEqual;\nexports.lessEqualStrict = lessEqualStrict;\nexports.lessStrict = lessStrict;\nexports.notEqual = notEqual;\nexports.notEqualStrict = notEqualStrict;\nexports.add = add;\nexports.addN = addN;\nexports.addStrict = addStrict;\nexports.atan2 = atan2;\nexports.div = div;\nexports.divStrict = divStrict;\nexports.floorDiv = floorDiv;\nexports.maximum = maximum;\nexports.maximumStrict = maximumStrict;\nexports.minimum = minimum;\nexports.minimumStrict = minimumStrict;\nexports.mod = mod;\nexports.modStrict = modStrict;\nexports.mul = mul;\nexports.mulStrict = mulStrict;\nexports.pow = pow;\nexports.powStrict = powStrict;\nexports.squaredDifference = squaredDifference;\nexports.squaredDifferenceStrict = squaredDifferenceStrict;\nexports.sub = sub;\nexports.subStrict = subStrict;\nexports.elu = elu;\nexports.leakyRelu = leakyRelu;\nexports.prelu = prelu;\nexports.relu = relu;\nexports.selu = selu;\nexports.logicalAnd = logicalAnd;\nexports.logicalNot = logicalNot;\nexports.logicalOr = logicalOr;\nexports.logicalXor = logicalXor;\nexports.where = where;\nexports.whereAsync = whereAsync;\nexports.buffer = buffer;\nexports.toPixels = toPixels;\nexports.print = print;\nexports.batchToSpaceND = batchToSpaceND;\nexports.cast = cast;\nexports.clone = clone;\nexports.cumsum = cumsum;\nexports.depthToSpace = depthToSpace;\nexports.expandDims = expandDims;\nexports.eye = eye;\nexports.fromPixels = fromPixels;\nexports.multinomial = multinomial;\nexports.oneHot = oneHot;\nexports.pad = pad;\nexports.pad1d = pad1d;\nexports.pad2d = pad2d;\nexports.pad3d = pad3d;\nexports.pad4d = pad4d;\nexports.rand = rand;\nexports.randomNormal = randomNormal;\nexports.randomUniform = randomUniform;\nexports.reshape = reshape;\nexports.spaceToBatchND = spaceToBatchND;\nexports.squeeze = squeeze;\nexports.stack = stack;\nexports.tile = tile;\nexports.truncatedNormal = truncatedNormal;\nexports.unstack = unstack;\nexports.fill = fill;\nexports.linspace = linspace;\nexports.ones = ones$1;\nexports.range = range;\nexports.scalar = scalar;\nexports.tensor = tensor;\nexports.tensor1d = tensor1d;\nexports.tensor2d = tensor2d;\nexports.tensor3d = tensor3d;\nexports.tensor4d = tensor4d;\nexports.tensor5d = tensor5d;\nexports.tensor6d = tensor6d;\nexports.zeros = zeros;\nexports.onesLike = onesLike;\nexports.zerosLike = zerosLike;\nexports.transpose = transpose;\nexports.softmax = softmax;\nexports.localResponseNormalization = localResponseNormalization;\nexports.norm = norm;\nexports.gather = gather;\nexports.unsortedSegmentSum = unsortedSegmentSum;\nexports.basicLSTMCell = basicLSTMCell;\nexports.multiRNNCell = multiRNNCell;\nexports.movingAverage = movingAverage;\nexports.stridedSlice = stridedSlice;\nexports.topk = topk;\nexports.train = train;\nexports.tidy = tidy;\nexports.keep = keep;\nexports.dispose = dispose;\nexports.time = time;\nexports.profile = profile;\nexports.customGrad = customGrad;\nexports.grad = grad;\nexports.grads = grads;\nexports.valueAndGrad = valueAndGrad;\nexports.valueAndGrads = valueAndGrads;\nexports.variableGrads = variableGrads;\n//# sourceMappingURL=tf-core.esm.js.map"},"hash":"b38c90ac6b280dd8078365a6723a060d","cacheData":{"env":{}}}