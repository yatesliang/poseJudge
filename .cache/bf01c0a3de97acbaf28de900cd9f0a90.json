{"dependencies":[{"name":"/Users/chris/Desktop/因特尔杯/TryIt/package.json","includedInParent":true,"mtime":1539397829000},{"name":"/Users/chris/Desktop/因特尔杯/TryIt/.babelrc","includedInParent":true,"mtime":1539397829000},{"name":"/Users/chris/Desktop/因特尔杯/TryIt/node_modules/@tensorflow-models/posenet/package.json","includedInParent":true,"mtime":1541754030176},{"name":"@tensorflow/tfjs","loc":{"line":2,"column":116}}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getBoundingBoxPoints = exports.getBoundingBox = exports.getAdjacentKeyPoints = exports.poseChain = exports.partNames = exports.partIds = exports.checkpoints = exports.PoseNet = exports.load = exports.decodeSinglePose = exports.decodeMultiplePoses = undefined;\n\nvar _tfjs = require(\"@tensorflow/tfjs\");\n\nvar tf = _interopRequireWildcard(_tfjs);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n// @tensorflow/tfjs-models Copyright 2018 Google\nfunction __awaiter(e, t, r, n) {\n  return new (r || (r = Promise))(function (o, i) {\n    function a(e) {\n      try {\n        u(n.next(e));\n      } catch (e) {\n        i(e);\n      }\n    }function s(e) {\n      try {\n        u(n.throw(e));\n      } catch (e) {\n        i(e);\n      }\n    }function u(e) {\n      e.done ? o(e.value) : new r(function (t) {\n        t(e.value);\n      }).then(a, s);\n    }u((n = n.apply(e, t || [])).next());\n  });\n}function __generator(e, t) {\n  var r,\n      n,\n      o,\n      i,\n      a = { label: 0, sent: function () {\n      if (1 & o[0]) throw o[1];return o[1];\n    }, trys: [], ops: [] };return i = { next: s(0), throw: s(1), return: s(2) }, \"function\" == typeof Symbol && (i[Symbol.iterator] = function () {\n    return this;\n  }), i;function s(i) {\n    return function (s) {\n      return function (i) {\n        if (r) throw new TypeError(\"Generator is already executing.\");for (; a;) try {\n          if (r = 1, n && (o = 2 & i[0] ? n.return : i[0] ? n.throw || ((o = n.return) && o.call(n), 0) : n.next) && !(o = o.call(n, i[1])).done) return o;switch (n = 0, o && (i = [2 & i[0], o.value]), i[0]) {case 0:case 1:\n              o = i;break;case 4:\n              return a.label++, { value: i[1], done: !1 };case 5:\n              a.label++, n = i[1], i = [0];continue;case 7:\n              i = a.ops.pop(), a.trys.pop();continue;default:\n              if (!(o = (o = a.trys).length > 0 && o[o.length - 1]) && (6 === i[0] || 2 === i[0])) {\n                a = 0;continue;\n              }if (3 === i[0] && (!o || i[1] > o[0] && i[1] < o[3])) {\n                a.label = i[1];break;\n              }if (6 === i[0] && a.label < o[1]) {\n                a.label = o[1], o = i;break;\n              }if (o && a.label < o[2]) {\n                a.label = o[2], a.ops.push(i);break;\n              }o[2] && a.ops.pop(), a.trys.pop();continue;}i = t.call(e, a);\n        } catch (e) {\n          i = [6, e], n = 0;\n        } finally {\n          r = o = 0;\n        }if (5 & i[0]) throw i[1];return { value: i[0] ? i[1] : void 0, done: !0 };\n      }([i, s]);\n    };\n  }\n}var partNames = [\"nose\", \"leftEye\", \"rightEye\", \"leftEar\", \"rightEar\", \"leftShoulder\", \"rightShoulder\", \"leftElbow\", \"rightElbow\", \"leftWrist\", \"rightWrist\", \"leftHip\", \"rightHip\", \"leftKnee\", \"rightKnee\", \"leftAnkle\", \"rightAnkle\"],\n    NUM_KEYPOINTS = partNames.length,\n    partIds = partNames.reduce(function (e, t, r) {\n  return e[t] = r, e;\n}, {}),\n    connectedPartNames = [[\"leftHip\", \"leftShoulder\"], [\"leftElbow\", \"leftShoulder\"], [\"leftElbow\", \"leftWrist\"], [\"leftHip\", \"leftKnee\"], [\"leftKnee\", \"leftAnkle\"], [\"rightHip\", \"rightShoulder\"], [\"rightElbow\", \"rightShoulder\"], [\"rightElbow\", \"rightWrist\"], [\"rightHip\", \"rightKnee\"], [\"rightKnee\", \"rightAnkle\"], [\"leftShoulder\", \"rightShoulder\"], [\"leftHip\", \"rightHip\"]],\n    poseChain = [[\"nose\", \"leftEye\"], [\"leftEye\", \"leftEar\"], [\"nose\", \"rightEye\"], [\"rightEye\", \"rightEar\"], [\"nose\", \"leftShoulder\"], [\"leftShoulder\", \"leftElbow\"], [\"leftElbow\", \"leftWrist\"], [\"leftShoulder\", \"leftHip\"], [\"leftHip\", \"leftKnee\"], [\"leftKnee\", \"leftAnkle\"], [\"nose\", \"rightShoulder\"], [\"rightShoulder\", \"rightElbow\"], [\"rightElbow\", \"rightWrist\"], [\"rightShoulder\", \"rightHip\"], [\"rightHip\", \"rightKnee\"], [\"rightKnee\", \"rightAnkle\"]],\n    connectedPartIndices = connectedPartNames.map(function (e) {\n  var t = e[0],\n      r = e[1];return [partIds[t], partIds[r]];\n});function eitherPointDoesntMeetConfidence(e, t, r) {\n  return e < r || t < r;\n}function getAdjacentKeyPoints(e, t) {\n  return connectedPartIndices.reduce(function (r, n) {\n    var o = n[0],\n        i = n[1];return eitherPointDoesntMeetConfidence(e[o].score, e[i].score, t) ? r : (r.push([e[o], e[i]]), r);\n  }, []);\n}var NEGATIVE_INFINITY = Number.NEGATIVE_INFINITY,\n    POSITIVE_INFINITY = Number.POSITIVE_INFINITY;function getBoundingBox(e) {\n  return e.reduce(function (e, t) {\n    var r = e.maxX,\n        n = e.maxY,\n        o = e.minX,\n        i = e.minY,\n        a = t.position,\n        s = a.x,\n        u = a.y;return { maxX: Math.max(r, s), maxY: Math.max(n, u), minX: Math.min(o, s), minY: Math.min(i, u) };\n  }, { maxX: NEGATIVE_INFINITY, maxY: NEGATIVE_INFINITY, minX: POSITIVE_INFINITY, minY: POSITIVE_INFINITY });\n}function getBoundingBoxPoints(e) {\n  var t = getBoundingBox(e),\n      r = t.minX,\n      n = t.minY,\n      o = t.maxX,\n      i = t.maxY;return [{ x: r, y: n }, { x: o, y: n }, { x: o, y: i }, { x: r, y: i }];\n}function toTensorBuffer(e, t) {\n  return void 0 === t && (t = \"float32\"), __awaiter(this, void 0, void 0, function () {\n    var r;return __generator(this, function (n) {\n      switch (n.label) {case 0:\n          return [4, e.data()];case 1:\n          return r = n.sent(), [2, new _tfjs.TensorBuffer(e.shape, t, r)];}\n    });\n  });\n}function toTensorBuffers3D(e) {\n  return __awaiter(this, void 0, void 0, function () {\n    return __generator(this, function (t) {\n      return [2, Promise.all(e.map(function (e) {\n        return toTensorBuffer(e, \"float32\");\n      }))];\n    });\n  });\n}function scalePose(e, t, r) {\n  return { score: e.score, keypoints: e.keypoints.map(function (e) {\n      var n = e.score,\n          o = e.part,\n          i = e.position;return { score: n, part: o, position: { x: i.x * t, y: i.y * r } };\n    }) };\n}function scalePoses(e, t, r) {\n  return 1 === r && 1 === t ? e : e.map(function (e) {\n    return scalePose(e, r, t);\n  });\n}function getValidResolution(e, t, r) {\n  var n = t * e - 1;return n - n % r + 1;\n}function half(e) {\n  return Math.floor(e / 2);\n}var MaxHeap = function () {\n  function e(e, t) {\n    this.priorityQueue = new Array(e), this.numberOfElements = -1, this.getElementValue = t;\n  }return e.prototype.enqueue = function (e) {\n    this.priorityQueue[++this.numberOfElements] = e, this.swim(this.numberOfElements);\n  }, e.prototype.dequeue = function () {\n    var e = this.priorityQueue[0];return this.exchange(0, this.numberOfElements--), this.sink(0), this.priorityQueue[this.numberOfElements + 1] = null, e;\n  }, e.prototype.empty = function () {\n    return -1 === this.numberOfElements;\n  }, e.prototype.size = function () {\n    return this.numberOfElements + 1;\n  }, e.prototype.all = function () {\n    return this.priorityQueue.slice(0, this.numberOfElements + 1);\n  }, e.prototype.max = function () {\n    return this.priorityQueue[0];\n  }, e.prototype.swim = function (e) {\n    for (; e > 0 && this.less(half(e), e);) this.exchange(e, half(e)), e = half(e);\n  }, e.prototype.sink = function (e) {\n    for (; 2 * e <= this.numberOfElements;) {\n      var t = 2 * e;if (t < this.numberOfElements && this.less(t, t + 1) && t++, !this.less(e, t)) break;this.exchange(e, t), e = t;\n    }\n  }, e.prototype.getValueAt = function (e) {\n    return this.getElementValue(this.priorityQueue[e]);\n  }, e.prototype.less = function (e, t) {\n    return this.getValueAt(e) < this.getValueAt(t);\n  }, e.prototype.exchange = function (e, t) {\n    var r = this.priorityQueue[e];this.priorityQueue[e] = this.priorityQueue[t], this.priorityQueue[t] = r;\n  }, e;\n}();function scoreIsMaximumInLocalWindow(e, t, r, n, o, i) {\n  for (var a = i.shape, s = a[0], u = a[1], l = !0, c = Math.max(r - o, 0), p = Math.min(r + o + 1, s), f = c; f < p; ++f) {\n    for (var h = Math.max(n - o, 0), d = Math.min(n + o + 1, u), v = h; v < d; ++v) if (i.get(f, v, e) > t) {\n      l = !1;break;\n    }if (!l) break;\n  }return l;\n}function buildPartWithScoreQueue(e, t, r) {\n  for (var n = r.shape, o = n[0], i = n[1], a = n[2], s = new MaxHeap(o * i * a, function (e) {\n    return e.score;\n  }), u = 0; u < o; ++u) for (var l = 0; l < i; ++l) for (var c = 0; c < a; ++c) {\n    var p = r.get(u, l, c);p < e || scoreIsMaximumInLocalWindow(c, p, u, l, t, r) && s.enqueue({ score: p, part: { heatmapY: u, heatmapX: l, id: c } });\n  }return s;\n}function getOffsetPoint(e, t, r, n) {\n  return { y: n.get(e, t, r), x: n.get(e, t, r + NUM_KEYPOINTS) };\n}function getImageCoords(e, t, r) {\n  var n = getOffsetPoint(e.heatmapY, e.heatmapX, e.id, r),\n      o = n.y,\n      i = n.x;return { x: e.heatmapX * t + i, y: e.heatmapY * t + o };\n}function clamp(e, t, r) {\n  return e < t ? t : e > r ? r : e;\n}function squaredDistance(e, t, r, n) {\n  var o = r - e,\n      i = n - t;return o * o + i * i;\n}function addVectors(e, t) {\n  return { x: e.x + t.x, y: e.y + t.y };\n}var parentChildrenTuples = poseChain.map(function (e) {\n  var t = e[0],\n      r = e[1];return [partIds[t], partIds[r]];\n}),\n    parentToChildEdges = parentChildrenTuples.map(function (e) {\n  return e[1];\n}),\n    childToParentEdges = parentChildrenTuples.map(function (e) {\n  return e[0];\n});function getDisplacement(e, t, r) {\n  var n = r.shape[2] / 2;return { y: r.get(t.y, t.x, e), x: r.get(t.y, t.x, n + e) };\n}function getStridedIndexNearPoint(e, t, r, n) {\n  return { y: clamp(Math.round(e.y / t), 0, r - 1), x: clamp(Math.round(e.x / t), 0, n - 1) };\n}function traverseToTargetKeypoint(e, t, r, n, o, i, a) {\n  var s = n.shape,\n      u = s[0],\n      l = s[1],\n      c = getDisplacement(e, getStridedIndexNearPoint(t.position, i, u, l), a),\n      p = getStridedIndexNearPoint(addVectors(t.position, c), i, u, l),\n      f = getOffsetPoint(p.y, p.x, r, o),\n      h = n.get(p.y, p.x, r);return { position: addVectors({ x: p.x * i, y: p.y * i }, { x: f.x, y: f.y }), part: partNames[r], score: h };\n}function decodePose(e, t, r, n, o, i) {\n  var a = t.shape[2],\n      s = parentToChildEdges.length,\n      u = new Array(a),\n      l = e.part,\n      c = e.score,\n      p = getImageCoords(l, n, r);u[l.id] = { score: c, part: partNames[l.id], position: p };for (var f = s - 1; f >= 0; --f) {\n    var h = parentToChildEdges[f],\n        d = childToParentEdges[f];u[h] && !u[d] && (u[d] = traverseToTargetKeypoint(f, u[h], d, t, r, n, i));\n  }for (f = 0; f < s; ++f) {\n    h = childToParentEdges[f], d = parentToChildEdges[f];u[h] && !u[d] && (u[d] = traverseToTargetKeypoint(f, u[h], d, t, r, n, o));\n  }return u;\n}function withinNmsRadiusOfCorrespondingPoint(e, t, r, n) {\n  var o = r.x,\n      i = r.y;return e.some(function (e) {\n    var r = e.keypoints[n].position;return squaredDistance(i, o, r.y, r.x) <= t;\n  });\n}function getInstanceScore(e, t, r) {\n  return r.reduce(function (r, n, o) {\n    var i = n.position,\n        a = n.score;return withinNmsRadiusOfCorrespondingPoint(e, t, i, o) || (r += a), r;\n  }, 0) / r.length;\n}var kLocalMaximumRadius = 1;function decodeMultiplePoses(e, t, r, n, o, i, a, s) {\n  return void 0 === a && (a = .5), void 0 === s && (s = 20), __awaiter(this, void 0, void 0, function () {\n    var u, l, c, p, f, h, d, v, m, g, b, y;return __generator(this, function (w) {\n      switch (w.label) {case 0:\n          return u = [], [4, toTensorBuffers3D([e, t, r, n])];case 1:\n          for (l = w.sent(), c = l[0], p = l[1], f = l[2], h = l[3], d = buildPartWithScoreQueue(a, kLocalMaximumRadius, c), v = s * s; u.length < i && !d.empty();) m = d.dequeue(), g = getImageCoords(m.part, o, p), withinNmsRadiusOfCorrespondingPoint(u, v, g, m.part.id) || (b = decodePose(m, c, p, o, f, h), y = getInstanceScore(u, v, b), u.push({ keypoints: b, score: y }));return [2, u];}\n    });\n  });\n}var MANIFEST_FILE = \"manifest.json\",\n    CheckpointLoader = function () {\n  function e(e) {\n    this.urlPath = e, \"/\" !== this.urlPath.charAt(this.urlPath.length - 1) && (this.urlPath += \"/\");\n  }return e.prototype.loadManifest = function () {\n    var e = this;return new Promise(function (t, r) {\n      var n = new XMLHttpRequest();n.open(\"GET\", e.urlPath + MANIFEST_FILE), n.onload = function () {\n        e.checkpointManifest = JSON.parse(n.responseText), t();\n      }, n.onerror = function (t) {\n        throw new Error(MANIFEST_FILE + \" not found at \" + e.urlPath + \". \" + t);\n      }, n.send();\n    });\n  }, e.prototype.getCheckpointManifest = function () {\n    var e = this;return null == this.checkpointManifest ? new Promise(function (t, r) {\n      e.loadManifest().then(function () {\n        t(e.checkpointManifest);\n      });\n    }) : new Promise(function (t, r) {\n      t(e.checkpointManifest);\n    });\n  }, e.prototype.getAllVariables = function () {\n    var e = this;return null != this.variables ? new Promise(function (t, r) {\n      t(e.variables);\n    }) : new Promise(function (t, r) {\n      e.getCheckpointManifest().then(function (r) {\n        for (var n = Object.keys(e.checkpointManifest), o = [], i = 0; i < n.length; i++) o.push(e.getVariable(n[i]));Promise.all(o).then(function (r) {\n          e.variables = {};for (var o = 0; o < r.length; o++) e.variables[n[o]] = r[o];t(e.variables);\n        });\n      });\n    });\n  }, e.prototype.getVariable = function (e) {\n    var t = this;if (!(e in this.checkpointManifest)) throw new Error(\"Cannot load non-existant variable \" + e);var r = function (r, n) {\n      var o = new XMLHttpRequest();o.responseType = \"arraybuffer\";var i = t.checkpointManifest[e].filename;o.open(\"GET\", t.urlPath + i), o.onload = function () {\n        if (404 === o.status) throw new Error(\"Not found variable \" + e);var n = new Float32Array(o.response),\n            i = _tfjs.Tensor.make(t.checkpointManifest[e].shape, { values: n });r(i);\n      }, o.onerror = function (t) {\n        throw new Error(\"Could not fetch variable \" + e + \": \" + t);\n      }, o.send();\n    };return null == this.checkpointManifest ? new Promise(function (e, n) {\n      t.loadManifest().then(function () {\n        new Promise(r).then(e);\n      });\n    }) : new Promise(r);\n  }, e;\n}(),\n    mobileNet100Architecture = [[\"conv2d\", 2], [\"separableConv\", 1], [\"separableConv\", 2], [\"separableConv\", 1], [\"separableConv\", 2], [\"separableConv\", 1], [\"separableConv\", 2], [\"separableConv\", 1], [\"separableConv\", 1], [\"separableConv\", 1], [\"separableConv\", 1], [\"separableConv\", 1], [\"separableConv\", 2], [\"separableConv\", 1]],\n    mobileNet75Architecture = [[\"conv2d\", 2], [\"separableConv\", 1], [\"separableConv\", 2], [\"separableConv\", 1], [\"separableConv\", 2], [\"separableConv\", 1], [\"separableConv\", 2], [\"separableConv\", 1], [\"separableConv\", 1], [\"separableConv\", 1], [\"separableConv\", 1], [\"separableConv\", 1], [\"separableConv\", 1], [\"separableConv\", 1]],\n    mobileNet50Architecture = [[\"conv2d\", 2], [\"separableConv\", 1], [\"separableConv\", 2], [\"separableConv\", 1], [\"separableConv\", 2], [\"separableConv\", 1], [\"separableConv\", 2], [\"separableConv\", 1], [\"separableConv\", 1], [\"separableConv\", 1], [\"separableConv\", 1], [\"separableConv\", 1], [\"separableConv\", 1], [\"separableConv\", 1]],\n    VALID_OUTPUT_STRIDES = [8, 16, 32];function assertValidOutputStride(e) {\n  _tfjs.util.assert(\"number\" == typeof e, \"outputStride is not a number\"), _tfjs.util.assert(VALID_OUTPUT_STRIDES.indexOf(e) >= 0, \"outputStride of \" + e + \" is invalid. It must be either 8, 16, or 32\");\n}function assertValidScaleFactor(e) {\n  _tfjs.util.assert(\"number\" == typeof e, \"imageScaleFactor is not a number\"), _tfjs.util.assert(e >= .2 && e <= 1, \"imageScaleFactor must be between 0.2 and 1.0\");\n}var mobileNetArchitectures = { 100: mobileNet100Architecture, 75: mobileNet75Architecture, 50: mobileNet50Architecture };function toOutputStridedLayers(e, t) {\n  var r = 1,\n      n = 1;return e.map(function (e, o) {\n    var i,\n        a,\n        s = e[0],\n        u = e[1];return r === t ? (i = 1, a = n, n *= u) : (i = u, a = 1, r *= u), { blockId: o, convType: s, stride: i, rate: a, outputStride: r };\n  });\n}var MobileNet = function () {\n  function e(e, t) {\n    this.PREPROCESS_DIVISOR = (0, _tfjs.scalar)(127.5), this.ONE = (0, _tfjs.scalar)(1), this.variables = e, this.convolutionDefinitions = t;\n  }return e.prototype.predict = function (e, t) {\n    var r = this,\n        n = (0, _tfjs.cast)(e, \"float32\").div(this.PREPROCESS_DIVISOR).sub(this.ONE);return toOutputStridedLayers(this.convolutionDefinitions, t).reduce(function (e, t) {\n      var n = t.blockId,\n          o = t.stride,\n          i = t.convType,\n          a = t.rate;if (\"conv2d\" === i) return r.conv(e, o, n);if (\"separableConv\" === i) return r.separableConv(e, o, n, a);throw Error(\"Unknown conv type of \" + i);\n    }, n);\n  }, e.prototype.convToOutput = function (e, t) {\n    return e.conv2d(this.weights(t), 1, \"same\").add(this.biases(t));\n  }, e.prototype.conv = function (e, t, r) {\n    return e.conv2d(this.weights(\"Conv2d_\" + String(r)), t, \"same\").add(this.biases(\"Conv2d_\" + String(r))).clipByValue(0, 6);\n  }, e.prototype.separableConv = function (e, t, r, n) {\n    void 0 === n && (n = 1);var o = \"Conv2d_\" + String(r) + \"_depthwise\",\n        i = \"Conv2d_\" + String(r) + \"_pointwise\";return e.depthwiseConv2D(this.depthwiseWeights(o), t, \"same\", \"NHWC\", n).add(this.biases(o)).clipByValue(0, 6).conv2d(this.weights(i), [1, 1], \"same\").add(this.biases(i)).clipByValue(0, 6);\n  }, e.prototype.weights = function (e) {\n    return this.variables[\"MobilenetV1/\" + e + \"/weights\"];\n  }, e.prototype.biases = function (e) {\n    return this.variables[\"MobilenetV1/\" + e + \"/biases\"];\n  }, e.prototype.depthwiseWeights = function (e) {\n    return this.variables[\"MobilenetV1/\" + e + \"/depthwise_weights\"];\n  }, e.prototype.dispose = function () {\n    for (var e in this.variables) this.variables[e].dispose();\n  }, e;\n}(),\n    GOOGLE_CLOUD_STORAGE_DIR = \"https://storage.googleapis.com/tfjs-models/weights/posenet/\",\n    checkpoints = { 1.01: { url: GOOGLE_CLOUD_STORAGE_DIR + \"mobilenet_v1_101/\", architecture: mobileNetArchitectures[100] }, 1: { url: GOOGLE_CLOUD_STORAGE_DIR + \"mobilenet_v1_100/\", architecture: mobileNetArchitectures[100] }, .75: { url: GOOGLE_CLOUD_STORAGE_DIR + \"mobilenet_v1_075/\", architecture: mobileNetArchitectures[75] }, .5: { url: GOOGLE_CLOUD_STORAGE_DIR + \"mobilenet_v1_050/\", architecture: mobileNetArchitectures[50] } };function mod(e, t) {\n  return (0, _tfjs.tidy)(function () {\n    var r = e.div((0, _tfjs.scalar)(t, \"int32\"));return e.sub(r.mul((0, _tfjs.scalar)(t, \"int32\")));\n  });\n}function argmax2d(e) {\n  var t = e.shape,\n      r = t[0],\n      n = t[1],\n      o = t[2];return (0, _tfjs.tidy)(function () {\n    var t = e.reshape([r * n, o]).argMax(0),\n        i = t.div((0, _tfjs.scalar)(n, \"int32\")).expandDims(1),\n        a = mod(t, n).expandDims(1);return (0, _tfjs.concat)([i, a], 1);\n  });\n}function getPointsConfidence(e, t) {\n  for (var r = t.shape[0], n = new Float32Array(r), o = 0; o < r; o++) {\n    var i = t.get(o, 0),\n        a = t.get(o, 1);n[o] = e.get(i, a, o);\n  }return n;\n}function getOffsetPoint$1(e, t, r, n) {\n  return { y: n.get(e, t, r), x: n.get(e, t, r + NUM_KEYPOINTS) };\n}function getOffsetVectors(e, t) {\n  for (var r = [], n = 0; n < NUM_KEYPOINTS; n++) {\n    var o = getOffsetPoint$1(e.get(n, 0).valueOf(), e.get(n, 1).valueOf(), n, t),\n        i = o.x,\n        a = o.y;r.push(a), r.push(i);\n  }return (0, _tfjs.tensor2d)(r, [NUM_KEYPOINTS, 2]);\n}function getOffsetPoints(e, t, r) {\n  return (0, _tfjs.tidy)(function () {\n    var n = getOffsetVectors(e, r);return e.toTensor().mul((0, _tfjs.scalar)(t, \"int32\")).toFloat().add(n);\n  });\n}function decodeSinglePose(e, t, r) {\n  return __awaiter(this, void 0, void 0, function () {\n    var n, o, i, a, s, u, l, c, p, f;return __generator(this, function (h) {\n      switch (h.label) {case 0:\n          return n = 0, o = argmax2d(e), [4, Promise.all([toTensorBuffer(e), toTensorBuffer(t), toTensorBuffer(o, \"int32\")])];case 1:\n          return i = h.sent(), a = i[0], s = i[1], u = i[2], [4, toTensorBuffer(l = getOffsetPoints(u, r, s))];case 2:\n          return c = h.sent(), p = Array.from(getPointsConfidence(a, u)), f = p.map(function (e, t) {\n            return n += e, { position: { y: c.get(t, 0), x: c.get(t, 1) }, part: partNames[t], score: e };\n          }), o.dispose(), l.dispose(), [2, { keypoints: f, score: n / f.length }];}\n    });\n  });\n}var _this = void 0;function toInputTensor(e, t, r, n) {\n  var o = e instanceof _tfjs.Tensor ? e : (0, _tfjs.fromPixels)(e);return n ? o.reverse(1).resizeBilinear([t, r]) : o.resizeBilinear([t, r]);\n}var PoseNet = function () {\n  function e(e) {\n    this.mobileNet = e;\n  }return e.prototype.predictForSinglePose = function (e, t) {\n    var r = this;return void 0 === t && (t = 16), assertValidOutputStride(t), (0, _tfjs.tidy)(function () {\n      var n = r.mobileNet.predict(e, t),\n          o = r.mobileNet.convToOutput(n, \"heatmap_2\"),\n          i = r.mobileNet.convToOutput(n, \"offset_2\");return { heatmapScores: o.sigmoid(), offsets: i };\n    });\n  }, e.prototype.predictForMultiPose = function (e, t) {\n    var r = this;return void 0 === t && (t = 16), (0, _tfjs.tidy)(function () {\n      var n = r.mobileNet.predict(e, t),\n          o = r.mobileNet.convToOutput(n, \"heatmap_2\"),\n          i = r.mobileNet.convToOutput(n, \"offset_2\"),\n          a = r.mobileNet.convToOutput(n, \"displacement_fwd_2\"),\n          s = r.mobileNet.convToOutput(n, \"displacement_bwd_2\");return { heatmapScores: o.sigmoid(), offsets: i, displacementFwd: a, displacementBwd: s };\n    });\n  }, e.prototype.estimateSinglePose = function (e, t, r, n) {\n    return void 0 === t && (t = .5), void 0 === r && (r = !1), void 0 === n && (n = 16), __awaiter(this, void 0, void 0, function () {\n      var o,\n          i,\n          a,\n          s,\n          u,\n          l,\n          c,\n          p,\n          f,\n          h = this;return __generator(this, function (d) {\n        switch (d.label) {case 0:\n            return assertValidOutputStride(n), assertValidScaleFactor(t), o = e instanceof _tfjs.Tensor ? [e.shape[0], e.shape[1]] : [e.height, e.width], i = o[0], a = o[1], s = getValidResolution(t, i, n), u = getValidResolution(t, a, n), l = (0, _tfjs.tidy)(function () {\n              var t = toInputTensor(e, s, u, r);return h.predictForSinglePose(t, n);\n            }), c = l.heatmapScores, p = l.offsets, [4, decodeSinglePose(c, p, n)];case 1:\n            return f = d.sent(), c.dispose(), p.dispose(), [2, scalePose(f, i / s, a / u)];}\n      });\n    });\n  }, e.prototype.estimateMultiplePoses = function (e, t, r, n, o, i, a) {\n    return void 0 === t && (t = .5), void 0 === r && (r = !1), void 0 === n && (n = 16), void 0 === o && (o = 5), void 0 === i && (i = .5), void 0 === a && (a = 20), __awaiter(this, void 0, void 0, function () {\n      var s,\n          u,\n          l,\n          c,\n          p,\n          f,\n          h,\n          d,\n          v,\n          m,\n          g,\n          b = this;return __generator(this, function (y) {\n        switch (y.label) {case 0:\n            return assertValidOutputStride(n), assertValidScaleFactor(t), s = e instanceof _tfjs.Tensor ? [e.shape[0], e.shape[1]] : [e.height, e.width], u = s[0], l = s[1], c = getValidResolution(t, u, n), p = getValidResolution(t, l, n), f = (0, _tfjs.tidy)(function () {\n              var t = toInputTensor(e, c, p, r);return b.predictForMultiPose(t, n);\n            }), h = f.heatmapScores, d = f.offsets, v = f.displacementFwd, m = f.displacementBwd, [4, decodeMultiplePoses(h, d, v, m, n, o, i, a)];case 1:\n            return g = y.sent(), h.dispose(), d.dispose(), v.dispose(), m.dispose(), [2, scalePoses(g, u / c, l / p)];}\n      });\n    });\n  }, e.prototype.dispose = function () {\n    this.mobileNet.dispose();\n  }, e;\n}();function load(e) {\n  return void 0 === e && (e = 1.01), __awaiter(this, void 0, void 0, function () {\n    var t, r;return __generator(this, function (n) {\n      switch (n.label) {case 0:\n          if (null == tf) throw new Error(\"Cannot find TensorFlow.js. If you are using a <script> tag, please also include @tensorflow/tfjs on the page before using this model.\");return t = Object.keys(checkpoints), _tfjs.util.assert(\"number\" == typeof e, \"got multiplier type of \" + typeof e + \" when it should be a number.\"), _tfjs.util.assert(t.indexOf(e.toString()) >= 0, \"invalid multiplier value of \" + e + \".  No checkpoint exists for that multiplier. Must be one of \" + t.join(\",\") + \".\"), [4, mobilenetLoader.load(e)];case 1:\n          return r = n.sent(), [2, new PoseNet(r)];}\n    });\n  });\n}var mobilenetLoader = { load: function (e) {\n    return __awaiter(_this, void 0, void 0, function () {\n      var t, r;return __generator(this, function (n) {\n        switch (n.label) {case 0:\n            return t = checkpoints[e], [4, new CheckpointLoader(t.url).getAllVariables()];case 1:\n            return r = n.sent(), [2, new MobileNet(r, t.architecture)];}\n      });\n    });\n  } };exports.decodeMultiplePoses = decodeMultiplePoses;\nexports.decodeSinglePose = decodeSinglePose;\nexports.load = load;\nexports.PoseNet = PoseNet;\nexports.checkpoints = checkpoints;\nexports.partIds = partIds;\nexports.partNames = partNames;\nexports.poseChain = poseChain;\nexports.getAdjacentKeyPoints = getAdjacentKeyPoints;\nexports.getBoundingBox = getBoundingBox;\nexports.getBoundingBoxPoints = getBoundingBoxPoints;"},"hash":"e2fd77fb53f852b784d7b9cb7f6d3d97","cacheData":{"env":{}}}